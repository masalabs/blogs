{"posts":[{"title":"Blazor在IoT领域的前端实践 @.NET开发者日","text":"2023年3月11号，MASA技术团队参加了“.NET开发者日”，IoT项目经理郭浩在活动中做“Blazor 在 IoT 领域的前端实践”的主题分享 郭浩 数闪科技 IoT 项目经理 从事 .NET 开发10余年，目前在数闪科技担任 IoT 项目经理，有大量 IoT 产品的开发经验，在 Android 和 iOS 的 Blazor MAUI 开发上有大量实践经验。 本次分享主要分为两个部分 第一部分 我们为什么要在IoT项目中使用Blazor技术，Blazor给IoT带来了什么? 第二部分 以一个IoT项目举例，使用Blazor 和MAUI技术的落地具体内容，最后还有我们在开发和调试过程中的经验分享。 为什么采用Blazor技术Blazor的优势Web应用程序已经发展了大约30年，在此期间，硬件和软件技术都发生了巨大的变化。然而，Web应用程序和网站的性质基本上没有变化：我们有一个面向用户的前端，以及一个包含内部数据和逻辑的后端。 这意味着构建这样的应用程序至少需要（前端+后端）两个技术层。现在，由于Web应用程序的内部复杂性使许多开发人员只能专注于特定层。前后端分离仍然是市面上主要的开发模式。 微软的早期架构中，也是更倾向于界面和逻辑都是同一个人完成，比如MVC和Webform技术。后期由于网络带宽的提升，对用户界面的要求越来越高，就出现了前后端分离的开发模式。但前后端的分离也导致了沟通成本的增加，尤其对于新手的开发，前后端互相不了解对方的技术，配合的时候就会产生很多问题。这时又催生出全栈工程师这个职位。很多大公司要想赶在对手之前抢先占领市场，就需要一个效率极高的开发团队，提高团队效率一个很有效的方法就是减少沟通成本，那么显而易见全栈工程师是最适合的。 其实，独立技术在前后端都得到了非常大的发展，Javascript和Java就是一个典型的例子，他们之间已经毫无关系，唯一的共同点就只有类C语法。后来，框架出现在市面上，但它们主要为其他技术的提供容器。第一个实际改进来自Node.js，它允许在前端和后端开发以及存储使用单一语言。 Blazor也取得了类似的突破，Blazor允许C#程序员使用单一语言进行后端和前端开发，并充分利用 .NET库和 .NET基础环境来生成客户端应用程序。此外，由于它可以与Javascript相互操作，如果需要，Blazor可以与现有的前端库集成，通过C#调用它们。 Blazor 允许在服务端编写应用程序来生成 UI 组件，并通过 SignalR 实时交互。 受欢迎的Blazor应当具有哪些特点？ 需要全栈开发 具有来自服务端的高频更新的应用程序。 需要通知的应用。 需要仪表板和监控的应用程序 实时协作应用。 IoT就是典型的符合前四项特点的应用，这些特点使 Blazor成为适合为IoT的解决方案提供支持 Blazor Hybrid优势 在Blazor Hybrid应用中，Razor组件在设备上本机运行。组件通过本地互操作通道呈现到嵌入式 Web View 控件。组件不在浏览器中运行，并且不涉及 WebAssembly。Razor 组件可快速加载和执行代码，组件可通过 .NET 平台完全访问设备的本机功能 Blazor Hybrid 支持内置于MAUI框架中。MAUI 包含 BlazorWebView 控件，该控件运行将 Razor 组件呈现到嵌入式 Web View 中。通过结合使用 MAUI 和 Blazor，可以跨移动设备、桌面设备和 Web 重复使用一组 Web UI 组件。 此体系结构的主要结论是，使用 Blazor Hybrid 生成的应用程序是本机应用，使用它们编程意味着可通过 .NET API层完全访问所有设备功能。 Blazor对IoT的支持 在IoT开发中Blazor可以做到什么？ 总结一下，Blazor对于.NET开发者有以上4点的优势：Blazor减少开发者的负担，使开发者专注于后端逻辑根据设备和需求，可以通过多种方式在IoT基础结构中使用以Blazor技术为主的Web应用程序，比如开发IoT的管理后台，大屏看板，产线监控，设备检测，产线PDA等移动设备端的相关功能 标准Web框架仅考虑用户与远程应用程序和数据库之间的通信，但越来越迫切需要一种新的Web框架，该框架可以将用户与其客户端设备以及为了实现业务目的所需的物联网基础设施连接起来 正如我们所看到的，Blazor当然可以满足这些需求，并且可以为构建连接IoT的Web应用程序提供基础。 MAUI Blazor 这是一个MAUI+Blazor开发的app通过MQTT控制树莓派的例子，设备读取距离传感器的数据通过MQTT上报，App实时获取并显示传感器数据。然后通过MQTT向设备发送控制指令，这里是控制一个led灯 可以通过Blazor与通用 I/O（GPIO）和兼容控制器集成。可以通过 Blazor应用进行交互，因为它们通常能够使用外围设备中的功能，例如中断、信号等。驱动程序的NET类可用于实现物联网应用程序，例如GpioController。 通常，.NET IoT库提供了通过C#访问和使用常见 IoT 板（如Raspberry Pi)的设备的方法。 System.Device.Gpio 包不仅支持 GPIO，还支持串行端口和其他具有低级硬件引脚的交互协议。 Iot.Device.Bindings 包提供与物联网中常用的几种设备的设备绑定，例如显示器、GPIO 扩展器、各种传感器、LED 驱动器、USB、加速度计等。如果你的传感器没有现成可用的包，那么通过厂家的c#或者python实例也是很容易迁移到.NET平台的，大部分都是一些高低电平的操作。 这是一个 Blazor实时显示倾斜传感器数据的示例 在IoT设备的生产流程中，我们可以使用Blazor技术快速开发出设备工装注册程序、生产流水线的管理和监控程序，我们还可以通过Blazor快速开发针对传感器、功能模块、整机的检测系统。 这样就可以在设备出现故障时快速的检测出有问题的传感器或者功能模块。 MASA Blazor 在讲具体的实践之前，介绍一些我们项目实践中第一个重要的组件，也就是MASA Blazor组件 MASA Blazor是一个多端组件库，基于Material Design设计包含Vuetify 1:1还原的基础组件，由全职开源团队长期支持和维护。 可以结合echarts可以显示高频更新的图表数据，实现对设备状态的实时观测 第二个重要的技术就是MAUI技术了，MAUI的出现，大幅度的降低了.NET开发者开发移动端的门槛。之前虽然有Xamarin技术，但是Xamarin没有做到统一，MAUI项目是具有多个输出的单个项目，而不是针对每个平台的多个项目。 我们还实现了很多平台相关的功能 MASA Blazor有一个 MAUI Plugin的分支 IoT项目中Blazor的落地实践 这里举例的是一个商用系列饮水机的项目，有PC端的管理平台，除了传统的IoT功能之外，还有比较复杂的销售和租赁业务。有面向代理商和技工的App和面向终端用户的微信小程序。 App Store审核是我们最耗时的工作之一因为我们对App开发和App Store审核策略不了解，所以为了满足审核标准，我们花费了很多时间来修改我们的业务。 但是从技术方案上看，使用MASA Blazor MAUI开发iOS项目，在开发、编译调试、打包以及AppStore审核流程上是没有障碍的。 APP界面 这些是我们App的界面，我们的App使用MASA Blazor实现了UI设计的100%还原，没有出现因为Blazor不兼容等问题而出现不能还原的情况。 同时我们使用了很多平台相关的功能，例如一键本机登录，蓝牙低功耗通讯，扫码拍照，相册选取，Android的自动更新，暗色主题切换，以及消息推送等等。 这些是我们使用MASA Blazor 开发的工业PDA的程序 第一张图是蓝牙OTA的程序，这种功能单一的程序，只要和嵌入式对接好协议，一个人一天就可以完成开发和测试工作 第二张图是注塑机台的状态管理 第三章是是一个工单登录的业务，其实是切换工单，一个工单就对应有物料，物料又和模具型号绑定，模具最终在关联到机台上，是一个生产的环节 第四章是一个打印周转筐标签一个功能 Web页面调试 我们的MAUI项目，可以使用Web Server的方式进行页面调试（Web Server和MAUI项目共同引用页面项目）可以解决95%的页面效果问题。 针对不同平台可以采取依赖注入的方式，在Web Server 和MAUI项目中分别注入不同的实现。这样也可以方便我们在Web端调试的时候跳过某些设备相关的流程，比如下一个步骤必须扫描获取结果之后才能进行，我们可以通过Mock接口的方式在Web Server项目中让注入的方法返回特定值即可。 我们也可以通过部分类或者条件编译的方式编写针对多端的实现代码。 这里是没有覆盖到的那5%，对于与平台功能相关的页面，例如蓝牙，扫码、打开相册之类的调试，或者是页面兼容性的调试，比如页面错误只存在与特定的手机，也可以使用谷歌的真机调试功能进行debug。而且有热重载的支持。 有的时候真机调试可能发现不了USB设备，可以将手机端的App完全卸载 iOS也支持真机调试，只要有开发者账号和iphone设备，但是打包需要有mac电脑支持。 我们会遇到各种平台相关的问题导致应用白屏或者闪退，这时我们可以通过ErrorBoundary组件在引发未处理的异常时呈现错误UI 在MauiProgram中通过FirstChanceException异常通知事件，来获取设备异常信息，将异常打印到vs的输出终端，比如不同Android版本针对于蓝牙的权限是不一样的，我们可以用这种方式发现问题。 MASA Blazor Android 踩坑 第二点和使用的第三方组件相关，对于一些绑定库的类，比如Android绑定库，vs有的时候是没有智能提示的，有的时候还会直接飘红，但是不影响编译打包 MASA Blazor iOS踩坑 在iOS里打包长度很关键，目前看如果某个文件打包路径超过255，就会报文件找不到的IO错误，我们一致以为是某些组件不支持，前后调查了很久。 对于iOS的绑定库，目前只能在Mac 中的vs for mac中进行，无论是引用动态链接库还是打包成nuget的方式虽然可以在windows编译通过，但是运行和调试的时候就会报错。图中是报错没有实现接口，但是其实经过检查已经实现了，在vs for mac中可以完美运行。 MASA Blazor 这里是MASA Stack对IoT的支撑场景 IoT 后台Blazor权限控制也非常简单，在Auth配置好权限后，只需要用特定标签包裹住需要权限控制的内容即可 对Blazor的未来，MASA有以下的展望 1、MASA Blazor会针对于低配置的设备开发极速版，在保证运行流畅的前提下提供良好UI交互 2、而且会针对于移动端做更多的适配，开发更多的移动端组件，也会提供移动端的模板，提供常见的布局模式，比如：列表、标签、网格、满屏切换、卡片、瀑布等常见的，这样开发者就算没有移动端App的开发经验，也可以通过配置快速搭建符合业务场景的布局，开发人员只需要关注具体的业务即可 3、会发布一系列的使用MASA Blazor 和Stack从0搭建IoT平台的技术文章，也会不断的更新MAUI相关技术内容 最后我们已经通过使用MASA Stack为底座前端采用MASA Blazor全场景使用.NET技术完成了IoT平台对数字化营销和智能制造的整个业务闭环。 如果您的企业是传统制造型企业那么可以参考我们的整套MASA Blazor+MASA Stack的解决方案，快速实现企业的数字化转型。 如果您是开发人员，并且现在也有类似的业务需求，那么借助于MASA Blazor+MASA Stack的能力，可以快速的搭建一套IoT平台。 最后如果您是一位想上手App开发的爱好者或者从业人员，并且掌握一些.NET技术。 那么与市面上其他的眼花缭乱混合开发技术相比，MASA Blazor + MAUI的方案技术门槛是最低，也最容易实现。而且 身后还有MASA技术团队的全力支持！ 扫码观看直播回放 如果你对我们的开源项目感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们","link":"/2023/03/13/MASA%20Blazor/Blazor%E5%9C%A8IoT%E9%A2%86%E5%9F%9F%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AE%9E%E8%B7%B5%20@.NET%E5%BC%80%E5%8F%91%E8%80%85%E6%97%A5/"},{"title":"MASA MAUI Plugin IOS蓝牙低功耗（三）蓝牙扫描","text":"项目背景MAUI的出现，赋予了广大Net开发者开发多平台应用的能力，MAUI 是Xamarin.Forms演变而来，但是相比Xamarin性能更好，可扩展性更强，结构更简单。但是MAUI对于平台相关的实现并不完整。所以MASA团队开展了一个实验性项目，意在对微软MAUI的补充和扩展， 项目地址：https://github.com/BlazorComponent/MASA.Blazor/tree/main/src/Masa.Blazor.Maui.Plugin 每个功能都有单独的demo演示项目，考虑到app安装文件体积（虽然MAUI已经集成裁剪功能，但是该功能对于代码本身有影响），届时每一个功能都会以单独的nuget包的形式提供，方便测试，现在项目才刚刚开始，但是相信很快就会有可以交付的内容啦。 前言本系列文章面向移动开发小白，从零开始进行平台相关功能开发，演示如何参考平台的官方文档使用MAUI技术来开发相应功能。 介绍之前两篇文章我们实现了安卓蓝牙BLE的相关功能，本文我们将IOS的BLE功能实现一下。，考虑到Swift语法对于c#开发人员更友好，本文示例代码参考Swift，相关代码来自苹果开发者官网https://developer.apple.com/documentation 开发步骤修改项目在Masa.Blazor.Maui.Plugin.Bluetooth项目中的Platforms-&gt;iOS文件夹下，添加一个部分类MasaMauiBluetoothService，在安卓中有BluetoothManager，在ios中对应的是CBCentralManager，但是不同有安卓还有个适配器Adapter的概念，在ios中关于设备扫描、连接和管理外围设备的对象，都是通过CBCentralManager直接管理的，我们看一下他的初始化方法 12345init( delegate: CBCentralManagerDelegate?, queue: DispatchQueue?, options: [String : Any]? = nil) delegate：接收中心事件的委托。相当于我们在安装中实现的DevicesCallback queue：用于调度中心角色事件的调度队列。如果该值为 nil，则中央管理器将使用主队列分派中心角色事件。这个我们可以简单的理解为和安卓的UI线程或者后台线程对应，更详尽的说明请参考https://developer.apple.com/documentation/dispatch/dispatchqueue options：配置信息，我们这里只用到了ShowPowerAlert，代表蓝牙设备如果不可用，给用户提示信息。就好比你用了不符合标准的数据线，iphone会给你提示是一个意思。 123456789101112131415161718192021222324252627282930313233343536373839public static partial class MasaMauiBluetoothService { private static BluetoothDelegate _delegate = new(); public static CBCentralManager _manager = new CBCentralManager(_delegate, DispatchQueue.DefaultGlobalQueue, new CBCentralInitOptions { ShowPowerAlert = true, }); private sealed class BluetoothDelegate : CBCentralManagerDelegate { private readonly EventWaitHandle _eventWaitHandle = new(false, EventResetMode.AutoReset); public List&lt;BluetoothDevice&gt; Devices { get; } = new(); public void WaitOne() { Task.Run(async () =&gt; { await Task.Delay(5000); _eventWaitHandle.Set(); }); _eventWaitHandle.WaitOne(); } public override void DiscoveredPeripheral(CBCentralManager central, CBPeripheral peripheral, NSDictionary advertisementData, NSNumber RSSI) { System.Diagnostics.Debug.WriteLine(&quot;OnScanResult&quot;); if (!Devices.Contains(peripheral)) { Devices.Add(peripheral); } } [Preserve] public override void UpdatedState(CBCentralManager central) { } } } 我们将MasaMauiBluetoothService修改为静态类，我们自定义的BluetoothDelegate 继承自CBCentralManagerDelegate，篇幅问题我们这里先只重写DiscoveredPeripheral和 UpdatedState，我们这次的演示不需要实现UpdatedState，但是这里的重写必须先放上去，否则调试过程会出现下面的报错 ObjCRuntime.ObjCException: ‘Objective-C exception thrown. Name: NSInvalidArgumentException Reason: -[Masa_Blazor_Maui_Plugin_Bluetooth_MasaMauiBluetoothService_BluetoothDelegate centralManagerDidUpdateState:]: unrecognized selector sent to instance 0x284bfe200 另外有一点需要特别注意，这个UpdatedState方法我没有实现的代码，那么我就需要添加一个[Preserve]，这样是为了防止链接器 在生成nuget包的时候把这个方法帮我优化掉。 实现发现附近设备功能，**_eventWaitHandle和安卓一样，我这里只是实现了一个异步转同步方便直接通过Devices拿到结果，如果小伙伴不喜欢后期我会添加不阻塞的方式。这里之所以可以Devices.Contains和Devices.Add是因为我们在BluetoothDevice类中实现了隐式转换如下是iOS目录下BluetoothDevice.ios.cs**的部分代码 123456789101112131415161718partial class BluetoothDevice{ ... private BluetoothDevice(CBPeripheral peripheral) { _peripheral = peripheral; } public static implicit operator BluetoothDevice(CBPeripheral peripheral) { return peripheral == null ? null : new BluetoothDevice(peripheral); } public static implicit operator CBPeripheral(BluetoothDevice device) { return device._peripheral; } ... ios扫描外围设备是通过scanForPeripherals我们继续在MasaMauiBluetoothService添加一个扫描附件设备的方法，我们看一下Swift的文档 1234func scanForPeripherals( withServices serviceUUIDs: [CBUUID]?, options: [String : Any]? = nil) serviceUUIDs：代表需要过滤的服务UUID，类似安卓的scanFilter对象。option：提供扫描的选项，我们这里用到了AllowDuplicatesKey，该值指定扫描是否应在不重复筛选的情况下运行我们参照实现以下我们的PlatformScanForDevices方法 123456789101112131415161718private static async Task&lt;IReadOnlyCollection&lt;BluetoothDevice&gt;&gt; PlatformScanForDevices(){ if (!_manager.IsScanning) { _manager.ScanForPeripherals(new CBUUID[] { }, new PeripheralScanningOptions { AllowDuplicatesKey = true }); await Task.Run(() =&gt; { _delegate.WaitOne(); }); _manager.StopScan(); _discoveredDevices = _delegate.Devices.AsReadOnly(); } return _discoveredDevices;} 通过 _cbCentralManager.IsScanning来判断是否处于扫描状态，如果没有，那就就通过ScanForPeripherals扫描外围设备，扫描5秒之后（BluetoothDelegate 内部控制）通过StopScan停止扫描，并通过 _discoveredDevices 保存结果。我们还需实现PlatformIsEnabledIsEnabled和PlatformCheckAndRequestBluetoothPermission方法，用来在扫描之前检查蓝牙是否可用并且已经经过用户授权 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static bool PlatformIsEnabledIsEnabled(){ return _manager.State == CBManagerState.PoweredOn;}public static async Task&lt;PermissionStatus&gt; PlatformCheckAndRequestBluetoothPermission(){ PermissionStatus status = await Permissions.CheckStatusAsync&lt;BluetoothPermissions&gt;(); if (status == PermissionStatus.Granted) return status; if (status == PermissionStatus.Denied &amp;&amp; DeviceInfo.Platform == DevicePlatform.iOS) { // Prompt the user to turn on in settings // On iOS once a permission has been denied it may not be requested again from the application return status; } status = await Permissions.RequestAsync&lt;BluetoothPermissions&gt;(); return status;}private class BluetoothPermissions : Permissions.BasePlatformPermission{ protected override Func&lt;IEnumerable&lt;string&gt;&gt; RequiredInfoPlistKeys =&gt; () =&gt; new string[] { &quot;NSBluetoothAlwaysUsageDescription&quot;, &quot;NSBluetoothPeripheralUsageDescription&quot; }; public override Task&lt;PermissionStatus&gt; CheckStatusAsync() { EnsureDeclared(); return Task.FromResult(GetBleStatus()); } private PermissionStatus GetBleStatus() //Todo:Needs to be replenished { var status = _cbCentralManager.State; return status switch { CBManagerState.PoweredOn=&gt; PermissionStatus.Granted, CBManagerState.Unauthorized =&gt; PermissionStatus.Denied, CBManagerState.Resetting =&gt; PermissionStatus.Restricted, _ =&gt; PermissionStatus.Unknown, }; }} 在PlatformIsEnabledIsEnabled方法中通过 _cbCentralManager.State == CBManagerState.PoweredOn 来判断蓝牙是否可用。该状态一共有如下枚举，从字面意思很好理解 Unknown, //手机没有识别到蓝牙 Resetting, //手机蓝牙已断开连接 Unsupported, //手机蓝牙功能没有权限 Unauthorized, //手机蓝牙功能没有权限 PoweredOff,//手机蓝牙功能关闭 PoweredOn //蓝牙开启且可用 权限检查这里和安卓有一些区别，在重写的RequiredInfoPlistKeys方法中指定了需要检查的蓝牙权限，BasePlatformPermission的EnsureDeclared方法用来检查是否在Info.plist文件添加了需要的权限，GetBleStatus方法通过 _cbCentralManager 的状态，来检查授权情况。 我们在Masa.Blazor.Maui.Plugin.Bluetooth的根目录添加部分类MasaMauiBluetoothService.cs，向使用者提供ScanForDevicesAsync等方法，方法内部通过PlatformScanForDevices来调用具体平台的实现。 123456789101112131415161718public static partial class MasaMauiBluetoothService{ private static IReadOnlyCollection&lt;BluetoothDevice&gt; _discoveredDevices; public static Task&lt;IReadOnlyCollection&lt;BluetoothDevice&gt;&gt; ScanForDevicesAsync() { return PlatformScanForDevices(); } public static bool IsEnabled() { return PlatformIsEnabledIsEnabled(); } public static async Task&lt;PermissionStatus&gt; CheckAndRequestBluetoothPermission() { return await PlatformCheckAndRequestBluetoothPermission(); }} 使用右键Masa.Blazor.Maui.Plugin.Bluetooth项目，点击打包，生成一个nuget包，在Masa.Blazor.Maui.Plugin.BlueToothSample项目中离线安装即可，代码的使用与安卓完全一样，只是权限配置方式不同在Masa.Blazor.Maui.Plugin.BlueToothSample项目的Platforms-&gt;iOS-&gt;Info.plist中添加蓝牙相关权限 1234&lt;key&gt;NSBluetoothAlwaysUsageDescription&lt;/key&gt;&lt;string&gt;App required to access Bluetooth&lt;/string&gt;&lt;key&gt;NSBluetoothPeripheralUsageDescription&lt;/key&gt;&lt;string&gt;App required to access Bluetooth&lt;/string&gt; NSBluetoothAlwaysUsageDescription对应iOS 13以上版本，对于iOS 13之前的版本，需要将NSBluetoothAlwaysUsageDescription和NSBluetoothPeripheralUsageDescription同时添加。 蓝牙扫描的效果和安卓机是完全一样的，这里就不展示了。(MASA MAUI Plugin 安卓蓝牙低功耗（一）蓝牙扫描 - 掘金 (juejin.cn)) iOS调试及错误排查目前在windows的vs环境调试MAUI的ios程序，是不需要mac电脑支持的，数据线连上后会显示一个本地设备，但是你仍然需要一个开发者账号，vs会调用apple开发者api自动帮你配置好需要的证书。 1、如果没有显示检查Xamarin-&gt;iOS设置，热重启是否开启 2、调试过程如果提示类似Could not find executable for C:\\Users\\xxx\\AppData\\Local\\Temp\\hbjayi2h.ydn找不到文件的情况，右键选择清理项目即可，如果无法解决手动删除bin和obj目录重试 3、调试过程如果app无故退出，排查一下考虑APP的启动和调试断点时间，iOS要求所有方法必须在17秒之内返回，否则iOS系统将停止该应用 4、调试过程出现Deploy Error: An Lockdown error occurred. The error code was “MuxError”的错误，请检查你的数据线，重新插拔或者更换原装线。 本文到此结束 如果你对我们MASA感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们 WeChat：MasaStackTechOpsQQ：7424099","link":"/2022/10/11/MASA%20Blazor/MASA%20MAUI%20Plugin%20IOS%E8%93%9D%E7%89%99%E4%BD%8E%E5%8A%9F%E8%80%97%EF%BC%88%E4%B8%89%EF%BC%89%E8%93%9D%E7%89%99%E6%89%AB%E6%8F%8F/"},{"title":"MASA MAUI Plugin 安卓蓝牙低功耗（一）蓝牙扫描","text":"项目背景MAUI的出现，赋予了广大Net开发者开发多平台应用的能力，MAUI 是Xamarin.Forms演变而来，但是相比Xamarin性能更好，可扩展性更强，结构更简单。但是MAUI对于平台相关的实现并不完整。所以MASA团队开展了一个实验性项目，意在对微软MAUI的补充和扩展 项目地址：https://github.com/BlazorComponent/MASA.Blazor/tree/main/src/Masa.Blazor.Maui.Plugin 每个功能都有单独的demo演示项目，考虑到app安装文件体积（虽然MAUI已经集成裁剪功能，但是该功能对于代码本身有影响），届时每一个功能都会以单独的nuget包的形式提供，方便测试，现在项目才刚刚开始，但是相信很快就会有可以交付的内容啦。 前言本系列文章面向移动开发小白，从零开始进行平台相关功能开发，演示如何参考平台的官方文档使用MAUI技术来开发相应功能。 介绍微软的MAUI并没有提供蓝牙低功耗设备的相关功能，而物联网开发中蓝牙低功耗是十分常见的，所以我们今天自己集成一个。由于蓝牙功能设计的内容比较多，篇幅有限，本文只集成一个最基本的蓝牙扫描功能，意在抛砖引玉。后续会陆续更新其他蓝牙通讯功能的文章。本文蓝牙低功耗简称为BLE如果你对BLE的相关概念不了解，可以参考 开发者官网链接: 蓝牙低功耗-安卓https://developer.android.google.cn/guide/topics/connectivity/bluetooth-le/ 本文JAVA相关代码均来自安卓开发者官网 开发步骤新建项目在vs中新建一个基于MAUI Blazor的项目MauiBlueToothDemo，然后添加一个MAUI类库项目Masa.Maui.Plugin.Bluetooth 添加权限项目创建好了之后，我们首先介绍一下BLE需要的安卓权限，相信大家对各种APP首次打开的权限确认弹窗应该不会陌生。 在应用中使用蓝牙功能，必须声明 BLUETOOTH 蓝牙权限，需要此权限才能执行任何蓝牙通信，例如请求连接、接受连接和传输数据等。由于 LE 信标通常与位置相关联，还须声明 ACCESS_FINE_LOCATION 权限。没有此权限，扫描将无法返回任何结果。如果适配 Android 9（API 级别 28）或更低版本，可以声明 ACCESS_COARSE_LOCATION 权限而非 ACCESS_FINE_LOCATION 权限如果想让应用启动设备发现或操纵蓝牙设置，还须声明 BLUETOOTH_ADMIN 权限。注意：如果使用 LUETOOTH_ADMIN 权限，则您必须拥有 BLUETOOTH 权限。在MauiBlueToothDemo项目中的AndroidManifest.xml添加权限，我们这里面向Android 9以上版本。 123456&lt;!--蓝牙权限--&gt;&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot; /&gt;&lt;!--让应用启动设备发现或操纵蓝牙设置--&gt;&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_ADMIN&quot; /&gt;&lt;!-- 如果设配Android9及更低版本，可以申请 ACCESS_COARSE_LOCATION --&gt;&lt;uses-permission android:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; /&gt; Android 6.0之后，只在AndroidManifest.xml声明权限已经不够了，出于安全考虑，必须动态申请权限，也就是需要在使用特定功能之前提示用户进行权限确认。我们在Masa.Maui.Plugin.Bluetooth项目的Platforms_Android下新建MasaMauiBluetoothService类，并添加一个内部类BluetoothPermissions ，MAUI的默认权限没有包含蓝牙低功耗，所以我们需要扩展一个自定义的蓝牙权限类，只要继承自 Permissions.BasePermission即可 12345678910private class BluetoothPermissions : Permissions.BasePlatformPermission{ public override (string androidPermission, bool isRuntime)[] RequiredPermissions =&gt; new List&lt;(string androidPermission, bool isRuntime)&gt; { (global::Android.Manifest.Permission.AccessFineLocation, true), (global::Android.Manifest.Permission.Bluetooth, true), (global::Android.Manifest.Permission.BluetoothAdmin, true), }.ToArray();} 我们在MasaMauiBluetoothService类内部添加一个方法，来实现动态获取权限 123456789101112public async Task&lt;bool&gt; CheckAndRequestBluetoothPermission(){ var status = await Permissions.CheckStatusAsync&lt;BluetoothPermissions&gt;(); if (status == PermissionStatus.Granted) return true; status = await Permissions.RequestAsync&lt;BluetoothPermissions&gt;(); if (status == PermissionStatus.Granted) return true; return false;} 检查权限的当前状态，使用 Permissions.CheckStatusAsync 方法。向用户请求权限，使用 Permissions.RequestAsync 方法。 如果用户以前授予了权限，并且尚未撤消该权限，则此方法将返回 Granted 而不向用户显示对话框。 设置BLEBLE的开发第一步骤就是设置BLE为什么要设置BLE，因为我们在使用BLE进行通讯之前，需要验证设备是否支持BLE或者检查BLE是否开启。我们先看一下java的实现方式 1234567JAVA 代码private BluetoothAdapter bluetoothAdapter;...// Initializes Bluetooth adapter.final BluetoothManager bluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);bluetoothAdapter = bluetoothManager.getAdapter(); 在编写平台相关代码时，安卓的系统管理服务都是同getSystemService方法获取的，该方法的参数为系统服务的名称，对应在MAUI中的方法为Android.App.Application.Context.GetSystemService，流程是完全一样的，语法稍有不同，我们如法炮制，在MasaMauiBluetoothService中添加一个构造函数，和两个字段 1234567private readonly BluetoothManager _bluetoothManager;private readonly BluetoothAdapter _bluetoothAdapter;public MasaMauiBluetoothService(){ _bluetoothManager = (BluetoothManager)Android.App.Application.Context.GetSystemService(Android.App.Application.BluetoothService); _bluetoothAdapter = _bluetoothManager?.Adapter;} GetSystemService返回BluetoothManager 实例，然后通过BluetoothManager 获取BluetoothAdapter， BluetoothAdapter代表设备自身的蓝牙适配器，之后的蓝牙操作都需要通过BluetoothAdapter完成继续在MasaMauiBluetoothService添加一个检查蓝牙适配器是否存在并开启的方法 1234public bool IsEnabled(){ return _bluetoothAdapter is {IsEnabled: true};} BLE扫描与BLE设备通讯，首先需要扫描出附近的BLE设备，我们先看看Java怎么实现的 12345678910111213141516171819202122232425262728293031323334JAVA 代码/** * Activity for scanning and displaying available BLE devices. */public class DeviceScanActivity extends ListActivity { private BluetoothAdapter bluetoothAdapter; private boolean mScanning; private Handler handler; // Stops scanning after 10 seconds. private static final long SCAN_PERIOD = 10000; ... private void scanLeDevice(final boolean enable) { if (enable) { // Stops scanning after a pre-defined scan period. handler.postDelayed(new Runnable() { @Override public void run() { mScanning = false; bluetoothAdapter.stopLeScan(leScanCallback); } }, SCAN_PERIOD); mScanning = true; bluetoothAdapter.startLeScan(leScanCallback); } else { mScanning = false; bluetoothAdapter.stopLeScan(leScanCallback); } ... }...} 扫描设备需要使用bluetoothAdapter.startLeScan方法，并指定一个BluetoothAdapter.LeScanCallback回调方法作为参数我们再看一下LeScanCallback的Java实现 123456789101112131415161718JAVA 代码private LeDeviceListAdapter leDeviceListAdapter;...// Device scan callback.private BluetoothAdapter.LeScanCallback leScanCallback = new BluetoothAdapter.LeScanCallback() { @Override public void onLeScan(final BluetoothDevice device, int rssi, byte[] scanRecord) { runOnUiThread(new Runnable() { @Override public void run() { leDeviceListAdapter.addDevice(device); leDeviceListAdapter.notifyDataSetChanged(); } }); }}; 因为扫描很耗费资源，所以示例代码通过runOnUiThread设置扫描进程在设备的前台运行，扫描到设备后触发leScanCallback 回调，然后通过私有的LeDeviceListAdapter字段保存扫描到的设备列表。我们如法炮制这部分功能，在MasaMauiBluetoothService中添加一个继承自ScanCallback内部类DevicesCallback，ScanCallback类 对应安卓的leScanCallback 12345678910111213141516171819202122232425262728private class DevicesCallback : ScanCallback { private readonly EventWaitHandle _eventWaitHandle = new(false, EventResetMode.AutoReset); public List&lt;BluetoothDevice&gt; Devices { get; } = new(); public void WaitOne() { Task.Run(async () =&gt; { await Task.Delay(5000); _eventWaitHandle.Set(); }); _eventWaitHandle.WaitOne(); } public override void OnScanResult(ScanCallbackType callbackType, ScanResult result) { System.Diagnostics.Debug.WriteLine(&quot;OnScanResult&quot;); if (!Devices.Contains(result.Device)) { Devices.Add(result.Device); } base.OnScanResult(callbackType, result); } } 篇幅问题我们这里只重写OnScanResult一个方法。当有设备被扫描到就会触发这个方法，然后就可以通过ScanResult的Device属性来获取设备信息。我们在MAUI中打印调试信息可以使用System.Diagnostics.Debug.WriteLine真机调试的信息会被打印到vs的输出控制台。我们添加一个属性Devices用于汇总收集扫描到的设备信息。这里使用了EventWaitHandle 用于在异步操作时控制线程间的同步，线程在 EventWaitHandle 上将一直受阻，直到未受阻的线程调用 Set 方法，没用过的可以自行查看微软文档。继续在MasaMauiBluetoothService添加字段，并在构造函数初始化。 1234567891011private readonly ScanSettings _settings;private readonly DevicesCallback _callback;public MasaMauiBluetoothService(){ _bluetoothManager = (BluetoothManager)Android.App.Application.Context.GetSystemService(Android.App.Application.BluetoothService); _bluetoothAdapter = _bluetoothManager?.Adapter; _settings = new ScanSettings.Builder() .SetScanMode(Android.Bluetooth.LE.ScanMode.Balanced) ?.Build(); _callback = new DevicesCallback();} 这里也很好理解，ScanSettings通过ScanSettings.Builder() 构造，用来配置蓝牙的扫描模式，我们这里使用平衡模式，具体式有如下三种： ScanSettings.SCAN_MODE_LOW_POWER 低功耗模式(默认扫描模式,如果扫描应用程序不在前台，则强制使用此模式。)ScanSettings.SCAN_MODE_BALANCED 平衡模式ScanSettings.SCAN_MODE_LOW_LATENCY 高功耗模式(建议仅在应用程序在前台运行时才使用此模式。) 最后添加ScanLeDeviceAsync方法 1234567891011public async Task&lt;IReadOnlyCollection&lt;BluetoothDevice&gt;&gt; ScanLeDeviceAsync() { //第一个参数可以设置过滤条件-蓝牙名称，名称前缀，服务号等,这里暂时不设置过滤条件 _bluetoothAdapter.BluetoothLeScanner.StartScan(null, _settings, _callback); await Task.Run(() =&gt; { _callback.WaitOne(); }); _bluetoothAdapter.BluetoothLeScanner.StopScan(_callback); return _callback.Devices.AsReadOnly(); } StartScan方法的第一个参数是过滤条件，可以根据名称等进行过滤，我们暂不设置过滤。 测试编译Masa.Maui.Plugin.Bluetooth项目，然后在MauiBlueToothDemo项目中引用Masa.Maui.Plugin.Bluetooth.dll。修改MauiBlueToothDemo的Index页面，页面使用了对MAUI支持良好的Masa Blazor组件: Masa Blazor 123456789101112131415161718192021222324252627@page &quot;/&quot;&lt;MButton OnClick=&quot;ScanBLEDeviceAsync&quot;&gt;扫描蓝牙设备&lt;/MButton&gt;&lt;div class=&quot;text-center&quot;&gt; &lt;MDialog @bind-Value=&quot;ShowProgress&quot; Width=&quot;500&quot;&gt; &lt;ChildContent&gt; &lt;MCard&gt; &lt;MCardTitle&gt; 正在扫描蓝牙设备 &lt;/MCardTitle&gt; &lt;MCardText&gt; &lt;MProgressCircular Size=&quot;40&quot; Indeterminate Color=&quot;primary&quot;&gt;&lt;/MProgressCircular&gt; &lt;/MCardText&gt; &lt;/MCard&gt; &lt;/ChildContent&gt; &lt;/MDialog&gt;&lt;/div&gt;&lt;MCard Class=&quot;mx-auto&quot; MaxWidth=&quot;400&quot; Tile&gt; @foreach (var item in BluetoothDeviceList) { &lt;MListItem&gt; &lt;MListItemContent&gt; &lt;MListItemTitle&gt;@item&lt;/MListItemTitle&gt; &lt;/MListItemContent&gt; &lt;/MListItem&gt; }&lt;/MCard&gt; 123456789101112131415161718192021222324252627using Masa.Maui.Plugin.Bluetooth;using Microsoft.AspNetCore.Components;namespace MauiBlueToothDemo.Pages{ public partial class Index { private bool ShowProgress { get; set; } private List&lt;string&gt; BluetoothDeviceList { get; set; } = new(); [Inject] private MasaMauiBluetoothService BluetoothService { get; set; } private async Task ScanBLEDeviceAsync() { if (BluetoothService.IsEnabled()) { if (await BluetoothService.CheckAndRequestBluetoothPermission()) { ShowProgress = true; var deviceList = await BluetoothService.ScanLeDeviceAsync(); BluetoothDeviceList = deviceList.Where(o =&gt; !string.IsNullOrEmpty(o.Name)).Select(o =&gt; o.Name).Distinct().ToList(); ShowProgress = false; } } } }} 不要忘记在MauiProgram.cs注入写好的MasaMauiBluetoothService 123#if ANDROID builder.Services.AddSingleton&lt;MasaMauiBluetoothService&gt;();#endif 我们真机运行一下看看效果 同时在vs的输出中可以看到打印的日志 本文到此结束，下一篇我们实现具体的BLE的通讯。 如果你对我们MASA感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们 WeChat：MasaStackTechOps QQ：7424099","link":"/2022/09/20/MASA%20Blazor/MASA%20MAUI%20Plugin%20%E5%AE%89%E5%8D%93%E8%93%9D%E7%89%99%E4%BD%8E%E5%8A%9F%E8%80%97%EF%BC%88%E4%B8%80%EF%BC%89%E8%93%9D%E7%89%99%E6%89%AB%E6%8F%8F/"},{"title":"MASA MAUI Plugin 安卓蓝牙低功耗（二）蓝牙通讯","text":"项目背景MAUI的出现，赋予了广大Net开发者开发多平台应用的能力，MAUI 是Xamarin.Forms演变而来，但是相比Xamarin性能更好，可扩展性更强，结构更简单。但是MAUI对于平台相关的实现并不完整。所以MASA团队开展了一个实验性项目，意在对微软MAUI的补充和扩展 项目地址https://github.com/BlazorComponent/MASA.Blazor/tree/main/src/Masa.Blazor.Maui.Plugin 每个功能都有单独的demo演示项目，考虑到app安装文件体积（虽然MAUI已经集成裁剪功能，但是该功能对于代码本身有影响），届时每一个功能都会以单独的nuget包的形式提供，方便测试，现在项目才刚刚开始，但是相信很快就会有可以交付的内容啦。 前言本系列文章面向移动开发小白，从零开始进行平台相关功能开发，演示如何参考平台的官方文档使用MAUI技术来开发相应功能。 介绍上一篇文章我们实现了蓝牙BLE的扫描功能，这里我们继续实现通讯功能。本文JAVA相关代码均来自安卓开发者官网 开发步骤连接到 GATT 服务器通用属性配置文件Generic Attribute Profile简称GATT。GATT定义了属性类型并规定了如何使用，包括了一个数据传输和存储的框架和一些基本操作。中间包含了一些概念如特性characteristics,服务services等。同时还定义了发现服务，特性和服务间的连接的处理过程，也包括读写特性值。我们使用移远的FC410举例 通过nRF connect工具可以查看设备的配置，该设备有一个前缀为FFFF的主服务，该服务下有一个前缀为FF01的特征，该特征具有通知Notify 和写入Write两种属性（如果有Notify，那么就会有描述符）。换句话说我们可以通过这个特征给设备发送数据，而且可以通过订阅该特征值变化事件，来获取设备通过蓝牙的返回信息。与 BLE 设备交互的第一步便是连接到 GATT 服务器。更具体地说，是连接到设备上的 GATT 服务器。我们先看一下JAVA的实现方式 12JAVA代码bluetoothGatt = device.connectGatt(this, false, gattCallback); 连接到 BLE 设备上的 GATT 服务器，需要使用 connectGatt() 方法。此方法采用三个参数：一个 Context 对象、autoConnect（布尔值，指示是否在可用时自动连接到 BLE 设备），以及对 BluetoothGattCallback 的引用。该方法 BluetoothGatt 实例，然后可使用该实例执行 GATT 客户端操作。调用方（Android 应用）是 GATT 客户端。BluetoothGattCallback 用于向客户端传递结果（例如连接状态），以及任何进一步的 GATT 客户端操作。我们再看一下BluetoothGattCallback 的JAVA实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344JAVA 代码// Various callback methods defined by the BLE API. private final BluetoothGattCallback gattCallback = new BluetoothGattCallback() { @Override public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) { String intentAction; if (newState == BluetoothProfile.STATE_CONNECTED) { intentAction = ACTION_GATT_CONNECTED; connectionState = STATE_CONNECTED; broadcastUpdate(intentAction); Log.i(TAG, &quot;Connected to GATT server.&quot;); Log.i(TAG, &quot;Attempting to start service discovery:&quot; + bluetoothGatt.discoverServices()); } else if (newState == BluetoothProfile.STATE_DISCONNECTED) { intentAction = ACTION_GATT_DISCONNECTED; connectionState = STATE_DISCONNECTED; Log.i(TAG, &quot;Disconnected from GATT server.&quot;); broadcastUpdate(intentAction); } } @Override // New services discovered public void onServicesDiscovered(BluetoothGatt gatt, int status) { if (status == BluetoothGatt.GATT_SUCCESS) { broadcastUpdate(ACTION_GATT_SERVICES_DISCOVERED); } else { Log.w(TAG, &quot;onServicesDiscovered received: &quot; + status); } } @Override // Result of a characteristic read operation public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) { if (status == BluetoothGatt.GATT_SUCCESS) { broadcastUpdate(ACTION_DATA_AVAILABLE, characteristic); } } ... 因为日后还需要实现其他平台的功能，我们的想法是所有公共部分都放到项目根目录，平台相关的实现，放到对应Platforms目录下对应平台的文件夹内，然后通过分部类的方式组织类结构。平台相关的方法起名以Platform为前缀。我们先在Masa.Blazor.Maui.Plugin.Bluetooth项目Platforms-&gt;Android目录新建一个名称为RemoteGattServer.android.cs的分部类，然后添加初始化方法和BluetoothGattCallback 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152 partial class RemoteGattServer { private Android.Bluetooth.BluetoothGatt _gatt; private Android.Bluetooth.BluetoothGattCallback _gattCallback; private void PlatformInit() { _gattCallback = new GattCallback(this); _gatt = ((Android.Bluetooth.BluetoothDevice)Device).ConnectGatt(Android.App.Application.Context, false, _gattCallback); } public static implicit operator Android.Bluetooth.BluetoothGatt(RemoteGattServer gatt) { return gatt._gatt; } internal event EventHandler&lt;CharacteristicEventArgs&gt; CharacteristicRead; internal event EventHandler&lt;GattEventArgs&gt; ServicesDiscovered; private bool _servicesDiscovered = false;... internal class GattCallback : Android.Bluetooth.BluetoothGattCallback { private readonly RemoteGattServer _remoteGattServer; internal GattCallback(RemoteGattServer remoteGattServer) { _remoteGattServer = remoteGattServer; }... public override void OnCharacteristicWrite(Android.Bluetooth.BluetoothGatt gatt, Android.Bluetooth.BluetoothGattCharacteristic characteristic, Android.Bluetooth.GattStatus status) { System.Diagnostics.Debug.WriteLine($&quot;CharacteristicWrite {characteristic.Uuid} Status:{status}&quot;); _remoteGattServer.CharacteristicWrite?.Invoke(_remoteGattServer, new CharacteristicEventArgs { Characteristic = characteristic, Status = status }); } } } ... internal class ConnectionStateEventArgs : GattEventArgs { public Android.Bluetooth.ProfileState State { get; internal set; } } internal class CharacteristicEventArgs : GattEventArgs { public Android.Bluetooth.BluetoothGattCharacteristic Characteristic { get; internal set; } } 在PlatformInit方法中连接到 GATT 服务器。自定义的GattCallback 集成自 Android.Bluetooth.BluetoothGattCallback，篇幅问题，这里只展示CharacteristicWrite一个方法的重写，要实现完整功能还至少需要额外重写ServicesDiscovered、ConnectionStateChanged、CharacteristicChanged、CharacteristicRead、DescriptorRead、DescriptorWrite四个方法，详细请参考源代码。在我们向设备特征值发送数据时，会触发OnCharacteristicWrite方法，方法内部触发我们自定义的CharacteristicWrite。 写入蓝牙指令官方文档示例中没有给出特征值写入的示例，这里我们自己实现。我们新建GattCharacteristic类，在项目根目录新建GattCharacteristic.cs，在Android目录新建GattCharacteristic.android.cs在GattCharacteristic.android.cs中添加PlatformWriteValue方法。 123456789101112131415161718192021222324252627282930313233Task PlatformWriteValue(byte[] value, bool requireResponse){ TaskCompletionSource&lt;bool&gt; tcs = null; if (requireResponse) { tcs = new TaskCompletionSource&lt;bool&gt;(); void handler(object s, CharacteristicEventArgs e) { if (e.Characteristic == _characteristic) { Service.Device.Gatt.CharacteristicWrite -= handler; if (!tcs.Task.IsCompleted) { tcs.SetResult(e.Status == Android.Bluetooth.GattStatus.Success); } } }; Service.Device.Gatt.CharacteristicWrite += handler; } bool written = _characteristic.SetValue(value); _characteristic.WriteType = requireResponse ? Android.Bluetooth.GattWriteType.Default : Android.Bluetooth.GattWriteType.NoResponse; written = ((Android.Bluetooth.BluetoothGatt)Service.Device.Gatt).WriteCharacteristic(_characteristic); if (written &amp;&amp; requireResponse) return tcs.Task; return Task.CompletedTask;} 通过_characteristic.SetValue将需要发送的字节数组存储到该特征值的本地存储中，然后通过WriteCharacteristic发送到远程Gatt服务器。这里用到了TaskCompletionSource，主要还是起到异步转同步作用。安卓蓝牙的写特征属性分为WRITE_TYPE_DEFAULT（写入）和WRITE_TYPE_NO_RESPONSE（写入无返回），参数requireResponse就表示是否需要设备返回，如果需要返回，就将TaskCompletionSource存储的结果以Task形式返回调用者。我们在GattCharacteristic中添加WriteValueWithResponseAsync方法，表示写入并等待返回。 1234567891011121314public Task WriteValueWithResponseAsync(byte[] value){ ThrowOnInvalidValue(value); return PlatformWriteValue(value, true);}private void ThrowOnInvalidValue(byte[] value){ if (value is null) throw new ArgumentNullException(&quot;value&quot;); if (value.Length &gt; 512) throw new ArgumentOutOfRangeException(&quot;value&quot;, &quot;Attribute value cannot be longer than 512 bytes&quot;);} 因为蓝牙限制单次写入的长度最大为512，所以我们这里做一下长度检查。这样的组织结构，当我们再添加其他平台的实现代码时，就可以直接通过调用PlatformWriteValue来调用具体平台的实现代码了。想对蓝牙进行写入操作，当然需要先找到蓝牙设备的服务id和特征值id才行。所以我们继续在GattCallback中添加一个OnConnectionStateChange的重写 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104internal event EventHandler&lt;GattEventArgs&gt; ServicesDiscovered;...internal class GattCallback : Android.Bluetooth.BluetoothGattCallback { ... public override void OnConnectionStateChange(Android.Bluetooth.BluetoothGatt gatt, Android.Bluetooth.GattStatus status, Android.Bluetooth.ProfileState newState) { System.Diagnostics.Debug.WriteLine($&quot;ConnectionStateChanged Status:{status} NewState:{newState}&quot;); _remoteGattServer.ConnectionStateChanged?.Invoke(_remoteGattServer, new ConnectionStateEventArgs { Status = status, State = newState }); if (newState == Android.Bluetooth.ProfileState.Connected) { if (!_remoteGattServer._servicesDiscovered) gatt.DiscoverServices(); } else { _remoteGattServer.Device.OnGattServerDisconnected(); } } } private async Task&lt;bool&gt; WaitForServiceDiscovery() { if (_servicesDiscovered) return true; TaskCompletionSource&lt;bool&gt; tcs = new TaskCompletionSource&lt;bool&gt;(); void handler(object s, GattEventArgs e) { ServicesDiscovered -= handler; if (!tcs.Task.IsCompleted) { tcs.SetResult(true); } }; ServicesDiscovered += handler; return await tcs.Task; } Task PlatformConnect() { TaskCompletionSource&lt;bool&gt; tcs = new TaskCompletionSource&lt;bool&gt;(); void handler(object s, ConnectionStateEventArgs e) { ConnectionStateChanged -= handler; switch (e.Status) { case Android.Bluetooth.GattStatus.Success: tcs.SetResult(e.State == Android.Bluetooth.ProfileState.Connected); break; default: tcs.SetResult(false); break; } } ConnectionStateChanged += handler; bool success = _gatt.Connect(); if (success) { if (IsConnected) return Task.FromResult(true); return tcs.Task; } else { ConnectionStateChanged -= handler; return Task.FromException(new OperationCanceledException()); } } async Task&lt;List&lt;GattService&gt;&gt; PlatformGetPrimaryServices(BluetoothUuid? service) { var services = new List&lt;GattService&gt;(); await WaitForServiceDiscovery(); foreach (var serv in _gatt.Services) { // if a service was specified only add if service uuid is a match if (serv.Type == Android.Bluetooth.GattServiceType.Primary &amp;&amp; (!service.HasValue || service.Value == serv.Uuid)) { services.Add(new GattService(Device, serv)); } } return services; } ... } ... internal class GattEventArgs : EventArgs { public Android.Bluetooth.GattStatus Status { get; internal set; } } 当设备连接或断开与某个设备的连接时，会触发我们重写的OnConnectionStateChange方法，然后我们在方法内部，判断如果是连接的状态（ProfileState.Connected），就去通过gatt服务的DiscoverServices来查找设备的服务及特征值信息等。PlatformGetPrimaryServices方法用来找到BLE设备的所有主服务（通过GattServiceType.Primary来判断是否为主服务），返回一个GattService列表，GattService类是我们自定义的一个类，鉴于篇幅问题这里不全部展示 1234567public sealed partial class GattService { public Task&lt;IReadOnlyList&lt;GattCharacteristic&gt;&gt; GetCharacteristicsAsync() { return PlatformGetCharacteristics(); } ... PlatformGetCharacteristics的具体实现在该类平台对应的部分类中 123456789101112partial class GattService{ private Task&lt;IReadOnlyList&lt;GattCharacteristic&gt;&gt; PlatformGetCharacteristics() { List&lt;GattCharacteristic&gt; characteristics = new List&lt;GattCharacteristic&gt;(); foreach (var characteristic in NativeService.Characteristics) { characteristics.Add(new GattCharacteristic(this, characteristic)); } return Task.FromResult((IReadOnlyList&lt;GattCharacteristic&gt;)characteristics.AsReadOnly()); } ... 打开蓝牙监听以上一系列操作我们已经可以拿到具体的这个设备的服务和具体的特征值了，对于BLE设备，大部分都是通过Notify属性进行广播的。我们需要开启一个广播监听我看参考一下JAVA代码 1234567891011JAVA 代码private BluetoothGatt bluetoothGatt;BluetoothGattCharacteristic characteristic;boolean enabled;...bluetoothGatt.setCharacteristicNotification(characteristic, enabled);...BluetoothGattDescriptor descriptor = characteristic.getDescriptor( UUID.fromString(SampleGattAttributes.CLIENT_CHARACTERISTIC_CONFIG));descriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);bluetoothGatt.writeDescriptor(descriptor); 开启广播监听的方式是向对应描述符写入一个指令（BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE）即可开启广播。我们在GattCharacteristic.android.cs添加PlatformStartNotifications方法 123456789101112131415private async Task PlatformStartNotifications() { byte[] data; if (_characteristic.Properties.HasFlag(Android.Bluetooth.GattProperty.Notify)) data = Android.Bluetooth.BluetoothGattDescriptor.EnableNotificationValue.ToArray(); else if (_characteristic.Properties.HasFlag(Android.Bluetooth.GattProperty.Indicate)) data = Android.Bluetooth.BluetoothGattDescriptor.EnableIndicationValue.ToArray(); else return; ((Android.Bluetooth.BluetoothGatt)Service.Device.Gatt).SetCharacteristicNotification(_characteristic, true); var descriptor = await GetDescriptorAsync(GattDescriptorUuids.ClientCharacteristicConfiguration); await descriptor.WriteValueAsync(data); } 这里判断是否支持Notify，然后调用EnableNotificationValue构造一个打开监听的指令data，然后通过GetDescriptorAsync拿到这个特征值对应的描述符，这里很简单只要调用安卓对应特征值的GetDescriptor即可，这里就不展示代码了。一个BLE设备如果有通知的属性，那么他一定会有描述符，打开或者关闭通知都需要通过描述符写入指令来控制，所有对特征值的操作然后通过WriteValueAsync-&gt;PlatformWriteValue来实现。 12345678910111213141516171819202122232425Task PlatformWriteValue(byte[] value){ TaskCompletionSource&lt;bool&gt; tcs = new TaskCompletionSource&lt;bool&gt;(); void handler(object s, DescriptorEventArgs e) { if (e.Descriptor == _descriptor) { Characteristic.Service.Device.Gatt.DescriptorWrite -= handler; if (!tcs.Task.IsCompleted) { tcs.SetResult(e.Status == Android.Bluetooth.GattStatus.Success); } } }; Characteristic.Service.Device.Gatt.DescriptorWrite += handler; bool written = _descriptor.SetValue(value); written = ((Android.Bluetooth.BluetoothGatt)Characteristic.Service.Device.Gatt).WriteDescriptor(_descriptor); if (written) return tcs.Task; return Task.FromException(new OperationCanceledException());} 接收 GATT 通知到此我们已经实现了连接设备、获取主服务和特征值、写入数据、打开通知监听，最后还剩一个就是监听特征值的变化，为某个特征启用通知后，如果远程设备上的特征发生更改（我们收到消息），则会触发 onCharacteristicChanged() 回调： 1234567JAVA代码@Override// Characteristic notificationpublic void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) { broadcastUpdate(ACTION_DATA_AVAILABLE, characteristic);} 在GattCharacteristic.cs中添加 123456789101112131415161718192021222324252627 void OnCharacteristicValueChanged(GattCharacteristicValueChangedEventArgs args) { characteristicValueChanged?.Invoke(this, args); } public event EventHandler&lt;GattCharacteristicValueChangedEventArgs&gt; CharacteristicValueChanged { add { characteristicValueChanged += value; AddCharacteristicValueChanged(); } remove { characteristicValueChanged -= value; RemoveCharacteristicValueChanged(); } } ... public sealed class GattCharacteristicValueChangedEventArgs : EventArgs { internal GattCharacteristicValueChangedEventArgs(byte[] newValue) { Value = newValue; } public byte[] Value { get; private set; }} 在平台对应的GattCharacteristic.android.cs添加 12345678910111213void AddCharacteristicValueChanged(){ Service.Device.Gatt.CharacteristicChanged += Gatt_CharacteristicChanged;}void RemoveCharacteristicValueChanged(){ Service.Device.Gatt.CharacteristicChanged -= Gatt_CharacteristicChanged;}private void Gatt_CharacteristicChanged(object sender, CharacteristicEventArgs e){ if (e.Characteristic == _characteristic) OnCharacteristicValueChanged(new GattCharacteristicValueChangedEventArgs(e.Characteristic.GetValue()));} 这里的实现思路和之前是一样的。 测试我们在MasaMauiBluetoothService添加一个发送数据的方法 123456789101112131415161718public async Task SendDataAsync(string deviceName,Guid servicesUuid,Guid? characteristicsUuid, byte[] dataBytes, EventHandler&lt;GattCharacteristicValueChangedEventArgs&gt; gattCharacteristicValueChangedEventArgs){ BluetoothDevice blueDevice = _discoveredDevices.FirstOrDefault(o =&gt; o.Name == deviceName); var primaryServices = await blueDevice.Gatt.GetPrimaryServicesAsync(); var primaryService = primaryServices.First(o =&gt; o.Uuid.Value == servicesUuid); var characteristics = await primaryService.GetCharacteristicsAsync(); var characteristic = characteristics.FirstOrDefault(o =&gt; (o.Properties &amp; GattCharacteristicProperties.Write) != 0); if (characteristicsUuid != null) { characteristic = characteristics.FirstOrDefault(o =&gt; o.Uuid.Value == characteristicsUuid); } await characteristic.StartNotificationsAsync(); characteristic.CharacteristicValueChanged += gattCharacteristicValueChangedEventArgs; await characteristic.WriteValueWithResponseAsync(dataBytes);} 在Masa.Blazor.Maui.Plugin.BlueToothSample项目的Index.razor.cs添加测试代码 12345678910111213141516171819202122232425262728293031 public partial class Index { private string SelectedDevice; private List&lt;string&gt; _allDeviceResponse = new List&lt;string&gt;(); [Inject] private MasaMauiBluetoothService BluetoothService { get; set; }... private async Task SendDataAsync(string cmd= &quot;AT+QVERSION&quot;) { var byteData = System.Text.Encoding.Default.GetBytes(cmd); await SendDataAsync(SelectedDevice, byteData); } private async Task SendDataAsync(string deviceSerialNo, byte[] byteData) { if (byteData.Any()) { _allDeviceResponse = new List&lt;string&gt;();#if ANDROID await BluetoothService.SendDataAsync(deviceSerialNo,Guid.Parse(&quot;0000ffff-0000-1000-8000-00805f9b34fb&quot;),null, byteData, onCharacteristicChanged);#endif } } void onCharacteristicChanged(object sender, GattCharacteristicValueChangedEventArgs e) { var deviceResponse = System.Text.Encoding.Default.GetString(e.Value); _allDeviceResponse.Add(deviceResponse); InvokeAsync(() =&gt; { StateHasChanged(); }); } } 向设备发送查询版本号的指令“AT+QVERSION”，设备返回通过onCharacteristicChanged方法获取，设备返回的是二进制数组，所以需要转成字符串显示出来。简单在写个界面修改Index.razorMasa Blazor组件: Masa Blazor 1234567891011121314151617181920212223242526272829303132333435363738394041424344@page &quot;/&quot;&lt;MButton OnClick=&quot;ScanBLEDeviceAsync&quot;&gt;扫描蓝牙设备&lt;/MButton&gt;&lt;div class=&quot;text-center&quot;&gt; &lt;MDialog @bind-Value=&quot;ShowProgress&quot; Width=&quot;500&quot;&gt; &lt;ChildContent&gt; &lt;MCard&gt; &lt;MCardTitle&gt; 正在扫描蓝牙设备 &lt;/MCardTitle&gt; &lt;MCardText&gt; &lt;MProgressCircular Size=&quot;40&quot; Indeterminate Color=&quot;primary&quot;&gt;&lt;/MProgressCircular&gt; &lt;/MCardText&gt; &lt;/MCard&gt; &lt;/ChildContent&gt; &lt;/MDialog&gt;&lt;/div&gt;@if (BluetoothDeviceList.Any()){ &lt;MSelect style=&quot;margin-top:10px&quot; Outlined Items=&quot;BluetoothDeviceList&quot; ItemText=&quot;u=&gt;u&quot; ItemValue=&quot;u=&gt;u&quot; TItem=&quot;string&quot; TValue=&quot;string&quot; TItemValue=&quot;string&quot; @bind-Value=&quot;SelectedDevice&quot; OnSelectedItemUpdate=&quot;item =&gt; SelectedDevice = item&quot;&gt; &lt;/MSelect&gt;}@if (!string.IsNullOrEmpty(SelectedDevice)){ &lt;MButton OnClick=&quot;() =&gt; SendDataAsync()&quot;&gt;发送查询版本指令&lt;/MButton&gt;}@if (_allDeviceResponse.Any()){ &lt;MCard&gt; &lt;MTextarea Value=&quot;@string.Join(' ',_allDeviceResponse)&quot;&gt;&lt;/MTextarea&gt; &lt;/MCard&gt;} 我们看一下效果 本文到此结束 如果你对我们的开源项目感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们 WeChat：MasaStackTechOps QQ：7424099","link":"/2022/09/23/MASA%20Blazor/MASA%20MAUI%20Plugin%20%E5%AE%89%E5%8D%93%E8%93%9D%E7%89%99%E4%BD%8E%E5%8A%9F%E8%80%97%EF%BC%88%E4%BA%8C%EF%BC%89%E8%93%9D%E7%89%99%E9%80%9A%E8%AE%AF/"},{"title":"MASA MAUI Plugin （七）应用通知角标（小红点）Android+iOS","text":"背景MAUI的出现，赋予了广大Net开发者开发多平台应用的能力，MAUI 是Xamarin.Forms演变而来，但是相比Xamarin性能更好，可扩展性更强，结构更简单。但是MAUI对于平台相关的实现并不完整。所以MASA团队开展了一个实验性项目，意在对微软MAUI的补充和扩展 项目地址https://github.com/BlazorComponent/MASA.Blazor/tree/feature/Maui/src/Masa.Blazor.Maui.Plugin 每个功能都有单独的demo演示项目，考虑到app安装文件体积（虽然MAUI已经集成裁剪功能，但是该功能对于代码本身有影响），届时每一个功能都会以单独的nuget包的形式提供，方便测试，现在项目才刚刚开始，但是相信很快就会有可以交付的内容啦。 前言本系列文章面向移动开发小白，从零开始进行平台相关功能开发，演示如何参考平台的官方文档使用MAUI技术来开发相应功能。 介绍上一篇文章我们集成了个推的消息通知，那么消息到达移动端之后，除了会在通知栏显示之外，在应用的角标也会显示未读消息的数量（小红点），然后用户点击查看消息之后，这些数字角标也可以自动消除，这个功能在MAUI中如何实现呢。 一、iOS部分思路 https://developer.apple.com/documentation/uikit/uiapplication/1622918-applicationiconbadgenumber 我们参考一下官方文档，UIApplication下有一个applicationIconBadgeNumber的属性 1var applicationIconBadgeNumber: Int { get set } 我们只需要给这个属性赋值具体的整数即可， https://developer.apple.com/documentation/uikit/uiapplication/1622975-shared 我们可以通过shared获取当前UIApplication的实例，然后就可以给applicationIconBadgeNumber赋值了，但是如果你直接这样做，你会发现并没有效果，因为 iOS 8 以后，需要注册用户通知，以获得用户的授权。 https://developer.apple.com/documentation/usernotifications/unusernotificationcenter/1649527-requestauthorization 我们可以通过UNUserNotificationCenter的RequestAuthorization方法获取请求用户本地和远程的通知权限。 开发步骤我们新建一个目录Badger，并在下面新建MAUI类库项目Masa.Blazor.Maui.Plugin.Badger，在Platforms下的iOS文件夹新建MasaMauiBadgerService部分类 1234567891011121314151617using UIKit;using UserNotifications;namespace Masa.Blazor.Maui.Plugin.Badger{ public static partial class MasaMauiBadgerService { private static void PlatformSetNotificationCount(int count) { // Requests the user’s authorization to allow local and remote notifications for your app. UNUserNotificationCenter.Current.RequestAuthorization(UNAuthorizationOptions.Badge, (r, e) =&gt;{}); // The number currently set as the badge of the app icon on the Home screen // Set to 0 (zero) to hide the badge number. The default value of this property is 0. UIApplication.SharedApplication.ApplicationIconBadgeNumber = count; } }} RequestAuthorization方法有两个参数 1、UNAuthorizationOptions 代表应用请求的授权选项，这里我们使用Badge2、completionHandle 这是一个Action，有两个参数，第一个参数是一个bool值，代表是否已授予授权，第二个参数是一个NSError类型，表示包含错误信息或未发生错误的对象。我们这里暂不处理出错的情况 我们通过UIApplication.SharedApplication获取当前的UIApplication实例，然后直接给ApplicationIconBadgeNumber 赋值，这里如果我们想清除角标，就直接赋值0即可。我们继续在项目根目录新建MasaMauiBadgerService类，通过SetNotificationCount来调用不同平台的PlatformSetNotificationCount方法。 1234567891011namespace Masa.Blazor.Maui.Plugin.Badger{ // All the code in this file is included in all platforms. public static partial class MasaMauiBadgerService { public static void SetNotificationCount(int count) { PlatformSetNotificationCount(count); } }} 二、安卓部分思路安卓部分比iOS相对复杂，我们本着不造轮子的思想，找了一个现成的aar包，ShortcutBadger 项目maven地址：https://repo1.maven.org/maven2/me/leolin/ShortcutBadger 开发步骤1、我们下载最新的ShortcutBadger-1.1.22.aar包，并新建Android Java 库绑定项目Masa.Blazor.Maui.Plugin.BadgerBinding 在根目录创建Jars文件夹，并将下载的aar文件添加进去。添加进去的文件属性中，生成操作默认选择的是AndroidLibrary，如果不对请手动更正。右键生成这个项目，这里很顺利没有任何报错。 2、我们在Masa.Blazor.Maui.Plugin.Badger项目中引用Masa.Blazor.Maui.Plugin.BadgerBinding项目，由于我们只有在安卓平台需要项目引用，所以我们手动修改一下项目文件中的引用部分，添加Android平台的判断。 123&lt;ItemGroup Condition=&quot;'$(TargetFramework)' == 'net7.0-android'&quot;&gt; &lt;ProjectReference Include=&quot;..\\Masa.Blazor.Maui.Plugin.BadgerBinding\\Masa.Blazor.Maui.Plugin.BadgerBinding.csproj&quot; /&gt;&lt;/ItemGroup&gt; 3、从 Android 8.0（API 级别 26）开始，所有通知都必须分配到相应的渠道，关于通知通道的信息，可以参考以下官方文档 https://developer.android.google.cn/training/notify-user/channels?hl=zh-cn 1234567891011121314151617Java 代码 private void createNotificationChannel() { // Create the NotificationChannel, but only on API 26+ because // the NotificationChannel class is new and not in the support library if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) { CharSequence name = getString(R.string.channel_name); String description = getString(R.string.channel_description); int importance = NotificationManager.IMPORTANCE_DEFAULT; NotificationChannel channel = new NotificationChannel(CHANNEL_ID, name, importance); channel.setDescription(description); // Register the channel with the system; you can't change the importance // or other notification behaviors after this NotificationManager notificationManager = getSystemService(NotificationManager.class); notificationManager.createNotificationChannel(channel); } } 我们参照以上写法，在Masa.Blazor.Maui.Plugin.Badger项目的Android平台目录下新建MasaMauiBadgerService 类，添加一个CreateNotificationChannel方法 12345678910111213141516171819202122using Android.App;using AndroidX.Core.App;namespace Masa.Blazor.Maui.Plugin.Badger{ // All the code in this file is included in all platforms. public static partial class MasaMauiBadgerService { private static void CreateNotificationChannel() { if (OperatingSystem.IsAndroidVersionAtLeast(26)) { using var channel = new NotificationChannel($&quot;{Android.App.Application.Context.PackageName}.channel&quot;, &quot;Notification channel&quot;, NotificationImportance.Default) { Description = &quot;Masa notification channel&quot; }; var notificationManager = NotificationManager.FromContext(Android.App.Application.Context); notificationManager?.CreateNotificationChannel(channel); } } }} 1、通过OperatingSystem.IsAndroidVersionAtLeast来判断当前的Android版本。2、NotificationChannel的创建方式与Java一致，三个参数分别为ChannelID，name、Importance这里注意第三个参数代表重要性级别，我们这里使用了NotificationImportance.Default。 用户可见的重要性级别 重要性（Android 8.0 及更高版本） 紧急：发出提示音，并以浮动通知的形式显示 IMPORTANCE_HIG 高：发出提示音 IMPORTANCE_DEFAULT 中：无提示音 IMPORTANCE_LOW 低：无提示音，且不会在状态栏中显示 IMPORTANCE_MIN 3、Description 指定用户在系统设置中看到的说明。4、通过NotificationManager.FromContext 创建 notificationManager，然后调用CreateNotificationChannel来创建通知通道。 我们继续添加SetNotificationCount方法 12345678910111213private static void PlatformSetNotificationCount(int count){ ME.Leolin.Shortcutbadger.ShortcutBadger.ApplyCount(Android.App.Application.Context, count); NotificationCompat.Builder builder = new(Android.App.Application.Context, $&quot;{Android.App.Application.Context.PackageName}.channel&quot;); builder.SetNumber(count); builder.SetContentTitle(&quot; &quot;); builder.SetContentText(&quot;&quot;); builder.SetSmallIcon(Android.Resource.Drawable.SymDefAppIcon); var notification = builder.Build(); var notificationManager = NotificationManager.FromContext(Android.App.Application.Context); CreateNotificationChannel(); notificationManager?.Notify((int)DateTimeOffset.UtcNow.ToUnixTimeMilliseconds(), notification);} 1、调用ShortcutBadger的ApplyCount方法来添加角标2、创建NotificationCompat.Builder示例，并以此设置角标显示数量（SetNumber），通知的标题（SetContentTitle）和内容（SetContentText），以及通知图标（SetSmallIcon）。3、调用我们刚写好的方法创建通知通道。4、通过NotificationManager.Notify方法在状态栏发布一条通知。该方法有两个参数，第一个参数是一个int类型id，这个id是通知的标识符，在应用程序中应该唯一。这里需要注意：如果你发布了相同id的通知，并且前一个并没有取消，那么该id对应的通知会被更新。第二个参数是一个notification 对象，是通过NotificationCompat.Builder创建出来的。 三、创建Demo项目1、新建一个MAUI Blazor项目：BadgerSample,添加对Masa.Blazor.Maui.Plugin.Badger项目的引用2、添加Android权限：修改Android平台目录中的AndroidManifest.xml文件，添加必要的权限。 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/appicon&quot; android:roundIcon=&quot;@mipmap/appicon_round&quot; android:supportsRtl=&quot;true&quot;&gt;&lt;/application&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.POST_NOTIFICATIONS&quot;/&gt; &lt;uses-permission android:name=&quot;android.permission.READ_APP_BADGE&quot; /&gt; &lt;uses-permission android:name=&quot;com.android.launcher.permission.READ_SETTINGS&quot;/&gt; &lt;uses-permission android:name=&quot;com.android.launcher.permission.WRITE_SETTINGS&quot;/&gt; &lt;uses-permission android:name=&quot;com.android.launcher.permission.INSTALL_SHORTCUT&quot; /&gt; &lt;uses-permission android:name=&quot;com.android.launcher.permission.UNINSTALL_SHORTCUT&quot; /&gt;&lt;/manifest&gt; 注意：国内不同手机厂家可能需要额外的权限配置，需要参考具体厂家的配置说明。 3、修改Index.razor文件 实际的使用场景应该是移动端接收消息推送，在处理消息推送的方法内修改角标，我们这里为了简化，在页面直接通过按钮触发修改角标显示的数量。 1234567891011121314151617181920212223@page &quot;/&quot;@using Masa.Blazor.Maui.Plugin.Badger;&lt;h1&gt;Masa blazor badger sample&lt;/h1&gt;Masa blazor badger sample.&lt;button @onclick=&quot;OnIncrementClicked&quot;&gt;Add&lt;/button&gt;&lt;button @onclick=&quot;OnClearClicked&quot;&gt;Clear&lt;/button&gt;@code{ int count; private void OnIncrementClicked() { count++; MasaMauiBadgerService.SetNotificationCount(count); } private void OnClearClicked() { count = 0; MasaMauiBadgerService.SetNotificationCount(count); }} Android 演示：演示机：vivo x70 pro+ iOS 演示：演示机：iPhone 14 iOS16 模拟器 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们 WeChat：MasaStackTechOps QQ：7424099","link":"/2022/12/28/MASA%20Blazor/MASA%20MAUI%20Plugin%20%EF%BC%88%E4%B8%83%EF%BC%89%E5%BA%94%E7%94%A8%E9%80%9A%E7%9F%A5%E8%A7%92%E6%A0%87%EF%BC%88%E5%B0%8F%E7%BA%A2%E7%82%B9%EF%BC%89Android+iOS/"},{"title":"MASA MAUI Plugin （九）Android相册多选照片（使用Android Jetpack套件库）","text":"背景MAUI的出现，赋予了广大Net开发者开发多平台应用的能力，MAUI 是Xamarin.Forms演变而来，但是相比Xamarin性能更好，可扩展性更强，结构更简单。但是MAUI对于平台相关的实现并不完整。所以MASA团队开展了一个实验性项目，意在对微软MAUI的补充和扩展 项目地址https://github.com/BlazorComponent/MASA.Blazor/tree/feature/Maui/src/Masa.Blazor.Maui.Plugin 每个功能都有单独的demo演示项目，考虑到app安装文件体积（虽然MAUI已经集成裁剪功能，但是该功能对于代码本身有影响），届时每一个功能都会以单独的nuget包的形式提供，方便测试，现在项目才刚刚开始，但是相信很快就会有可以交付的内容啦。 前言本系列文章面向移动开发小白，从零开始进行平台相关功能开发，演示如何参考平台的官方文档使用MAUI技术来开发相应功能。 介绍Jetpack 包含一系列 Android 库，它们都采用最佳做法并在 Android 应用中提供向后兼容性。 https://developer.android.google.cn/jetpack?hl=zh-cn 上一篇我们是通过Intent实现的，今天我们用Jetpack 实现相册的多选功能。 一、实现方式可以使用以下 activity 结果协定来启动照片选择器：PickVisualMedia，用于选择单张图片或单个视频。PickMultipleVisualMedia，用于选择多张图片或多个视频。我们的需求是可以多选照片，我们主要介绍PickMultipleVisualMedia的使用方法。我们先看一下JAVA的示例代码 1234567891011121314151617181920JAVA代码// Registering Photo Picker activity launcher with multiple selects (5 max in this example)ActivityResultLauncher&lt;PickVisualMediaRequest&gt; pickMultipleMedia = registerForActivityResult(new PickMultipleVisualMedia(5), uris -&gt; { // Callback is invoked after the user selects media items or closes the // photo picker. if (!uris.isEmpty()) { Log.d(&quot;PhotoPicker&quot;, &quot;Number of items selected: &quot; + uris.size()); } else { Log.d(&quot;PhotoPicker&quot;, &quot;No media selected&quot;); }});// For this example, launch the photo picker and allow the user to choose images// and videos. If you want the user to select a specific type of media file,// use the overloaded versions of launch(), as shown in the section about how// to select a single media item.pickMultipleMedia.launch(new PickVisualMediaRequest.Builder() .setMediaType(PickVisualMedia.ImageAndVideo.INSTANCE) .build()); 这里先介绍一下registerForActivityResult 在Android中启动另一个 activity（无论是您应用中的 activity 还是其他应用中的 activity）不一定是单向操作。我们需要获取activity的返回结果。这里我们就是启动了相册，并获取用户选取照片的返回结果。其他例如打开相机获取拍照结果，打开通讯录获取联系人结果都是具体的应用场景。 虽然所有 API 级别的 Activity 类均提供底层 startActivityForResult() 和 onActivityResult() API，但Android官方强烈建议使用 AndroidX Activity 和 Fragment 中引入的 Activity Result API。Activity Result API 提供了用于注册结果、启动结果以及在系统分派结果后对其进行处理的组件。在启动 activity 以获取结果时，可能会出现您的进程和 activity 因内存不足而被销毁的情况；如果是使用相机等内存密集型操作，几乎可以确定会出现这种情况。因此，Activity Result API 会将结果回调从您之前启动另一个 activity 的代码位置分离开来。由于在重新创建进程和 activity 时需要使用结果回调，因此每次创建 activity 时都必须无条件注册回调，即使启动另一个 activity 的逻辑仅基于用户输入内容或其他业务逻辑也是如此。 位于 ComponentActivity 或 Fragment 中时，Activity Result API 会提供 registerForActivityResult() API，用于注册结果回调。registerForActivityResult() 接受 ActivityResultContract 和 ActivityResultCallback 作为参数，并返回 ActivityResultLauncher，用来启动另一个 activity。ActivityResultContract 定义生成结果所需的输入类型以及结果的输出类型。这些 API 可为拍照和请求权限等基本 intent 操作提供默认协定。当然也可以创建自己的自定义协定。ActivityResultCallback 是单一方法接口，带有 onActivityResult() 方法，可接受 ActivityResultContract 中定义的输出类型的对象： 12345678910JAVA代码// GetContent creates an ActivityResultLauncher&lt;String&gt; to allow you to pass// in the mime type you'd like to allow the user to selectActivityResultLauncher&lt;String&gt; mGetContent = registerForActivityResult(new GetContent(), new ActivityResultCallback&lt;Uri&gt;() { @Override public void onActivityResult(Uri uri) { // Handle the returned Uri }}); 这里的代码看起来很简单，我们只需要在registerForActivityResult的第二个参数中new一个ActivityResultCallback并重写onActivityResult方法即可实现获取用户操作返回的需求。但是目前在MAUI中实现并非如此简单，因为MAUI中没有定义好的ActivityResultCallback类。下面我们来编写代码。 二、代码编写1、实现代码在上文代码的基础上，我们继续在MainActivity.cs添加代码 1234567891011121314151617181920212223242526272829303132333435public class MainActivity : MauiAppCompatActivity{ internal static MainActivity Instance { get; private set; } internal static ActivityResultLauncher PickMultipleMedia { get; private set; } public TaskCompletionSource&lt;Dictionary&lt;string, string&gt;&gt; PickImageTaskCompletionSource { set; get; } protected override void OnCreate(Bundle savedInstanceState) { Instance = this; PickMultipleMedia = Instance.RegisterForActivityResult(new ActivityResultContracts.PickMultipleVisualMedia(100), new ActivityResultCallback()); base.OnCreate(savedInstanceState); } private class ActivityResultCallback : Java.Lang.Object, IActivityResultCallback { public void OnActivityResult(Java.Lang.Object p0) { if (!p0.Equals(new Android.Runtime.JavaList())) { var list = (Android.Runtime.JavaList)p0; if (!list.IsEmpty) { var uris = list.Cast&lt;Uri&gt;().ToList(); var fileList = Instance.GetImageDicFromUris(uris); Instance.PickImageTaskCompletionSource.SetResult(fileList); } else { Instance.PickImageTaskCompletionSource.SetResult(new Dictionary&lt;string, string&gt;()); } } } }} 我们创建了一个静态的ActivityResultLauncher 类型的PickMultipleMedia，并在OnCreate方法中通过RegisterForActivityResult注册，方法第一个参数类型为ActivityResultContract，我们设置了100个图片的限制，第二个参数是一个IActivityResultCallback类型的Callback。由于默认没有提供，我们需要自己定义。注意：我们的callback方法在继承IActivityResultCallback接口的同时，还必须显示的继承Java.Lang.Object，否则会报错。我们仅需实现OnActivityResult方法即可，这里注意，方法的参数为Java.Lang.Object类型，有些文章会让我们将Java.Lang.Object强制转换为ActivityResult类型，然后再获取其中的文件Uri，但是经过测试目前在MAUI中不可用，转换之后永远为null。经过多次尝试后，确定多选照片返回的类型为Android.Runtime.JavaList。我这里通过 !p0.Equals(new Android.Runtime.JavaList()) 判断用户没有选择任何照片的场景。最后通过遍历，使用之前写好的GetImageDicFromUris方法获取所有文件的内容。 2、测试代码我们在上文的IPhotoPickerService.cs接口中扩展一个GetImageAsync4方便我们对几种实现方式进行对比。 123456789101112public class AndroidPhotoPickerService : IPhotoPickerService{ ... public Task&lt;Dictionary&lt;string, string&gt;&gt; GetImageAsync4() { MainActivity.PickMultipleMedia.Launch(new PickVisualMediaRequest.Builder() .SetMediaType(ActivityResultContracts.PickVisualMedia.ImageAndVideo.Instance).Build()); MainActivity.Instance.PickImageTaskCompletionSource = new TaskCompletionSource&lt;Dictionary&lt;string, string&gt;&gt;(); return MainActivity.Instance.PickImageTaskCompletionSource.Task; }} 这里使用的方法非常简单，参考上面JAVA的写法即可 1234JAVA代码pickMultipleMedia.launch(new PickVisualMediaRequest.Builder() .setMediaType(PickVisualMedia.ImageAndVideo.INSTANCE) .build()); 在Index.razor中添加一个MListItem 12345678&lt;MList&gt; ... &lt;MListItem OnClick=&quot;GetImageAsync4&quot;&gt; &lt;MListItemContent&gt; &lt;MListItemTitle&gt;Jetpack-PickMultipleVisualMedia&lt;/MListItemTitle&gt; &lt;/MListItemContent&gt; &lt;/MListItem&gt;&lt;/MList&gt; 三、演示效果 注意界面的变化，这里是以半屏弹出的方式展示的。 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们 WeChat：MasaStackTechOpsQQ：7424099","link":"/2023/02/28/MASA%20Blazor/MASA%20MAUI%20Plugin%20%EF%BC%88%E4%B9%9D%EF%BC%89Android%E7%9B%B8%E5%86%8C%E5%A4%9A%E9%80%89%E7%85%A7%E7%89%87%EF%BC%88%E4%BD%BF%E7%94%A8Android%20Jetpack%E5%A5%97%E4%BB%B6%E5%BA%93%EF%BC%89/"},{"title":"MASA MAUI Plugin （五）Android 指纹识别","text":"背景MAUI的出现，赋予了广大Net开发者开发多平台应用的能力，MAUI 是Xamarin.Forms演变而来，但是相比Xamarin性能更好，可扩展性更强，结构更简单。但是MAUI对于平台相关的实现并不完整。所以MASA团队开展了一个实验性项目，意在对微软MAUI的补充和扩展 项目地址https://github.com/masalabs/MASA.MAUI 每个功能都有单独的demo演示项目，考虑到app安装文件体积（虽然MAUI已经集成裁剪功能，但是该功能对于代码本身有影响），届时每一个功能都会以单独的nuget包的形式提供，方便测试，现在项目才刚刚开始，但是相信很快就会有可以交付的内容啦。 前言本系列文章面向移动开发小白，从零开始进行平台相关功能开发，演示如何参考平台的官方文档使用MAUI技术来开发相应功能。 介绍在 API 级别 23 (Android 6.0) 设备上引入指纹扫描仪为应用程序提供了传统的用户名/密码用户身份验证的替代方法。 相较于用户名和密码，采用指纹对用户进行身份验证使应用程序安全性的实现更具隐私性，之后 API-28（Android9.0） 中添加了生物识别身份验证Biometric，增加了人脸认证相关功能。我们今天讨论的只涉及指纹认证，考虑到兼容性问题采用API - 23 (Android 6.0) 版本提供的 FingerprintManager API，经过测试可以在Android 6.0 -11.0中正常工作，如果您需要人脸验证相关功能请参考链接: androidx.biometric，实现细节与本文类似。 思路我们先看一下Android 的指纹验证方法核心的指纹管理类FingerprintManagerCompat ，fingerprintManager是通过FingerprintManagerCompat.from(Context context)来创建的。 12JAVA代码FingerprintManagerCompat fingerprintManager= FingerprintManagerCompat.from(Context context); 1、检查资格：1、需要检查设备是否支持指纹。2、需要检查设备是否受保护 - 用户必须使用屏幕锁保护设备。 如果用户未使用屏幕锁保护设备，但是当前应用程序对于安全性要求很高，则应通知用户必须配置屏幕锁。3、需要检查用户是否已经注册指纹 - 用户必须至少有一个指纹已注册到操作系统。 此权限检查应在每次尝试进行身份验证之前进行，因为用户有可能随时取消指纹在MAUI blazor项目的Platforms-&gt;Android文件夹添加MasaMauiFingerprintService.cs 类，添加如下两个方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 public static class MasaMauiFingerprintService{ private static FingerprintManagerCompat fingerprintManager = FingerprintManagerCompat.From(Android.App.Application.Context); /// &lt;summary&gt; /// Check eligibility /// &lt;/summary&gt; /// &lt;returns&gt;error message&lt;/returns&gt; public static async Task&lt;string&gt; CheckingEligibility() { // 1、Check if your hardware supports it if (!fingerprintManager.IsHardwareDetected) { return &quot;IsHardwareDetected&quot;; } // 2、Check if the user is using a screen lock // KeyguardManager: Lock screen management class var keyguardManager = Android.App.Application.Context.GetSystemService(Context.KeyguardService) as KeyguardManager; if (!keyguardManager.IsKeyguardSecure) { return &quot;The device does not have a screen lock set&quot;; } // 3、Check if at least one fingerprint is registered if (!fingerprintManager.HasEnrolledFingerprints) { return &quot;The device does not have a fingerprint set, please set at least one fingerprint&quot;; } var granted = await CheckAndRequestFingerprintPermission(); if (!granted) { return &quot;Permissions not granted&quot;; } return string.Empty; } /// &lt;summary&gt; /// Permission check /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; private static async Task&lt;bool&gt; CheckAndRequestFingerprintPermission() { var status = await Permissions.CheckStatusAsync&lt;AndroidFingerprintPermissions&gt;(); if (status == PermissionStatus.Granted) return true; status = await Permissions.RequestAsync&lt;AndroidFingerprintPermissions&gt;(); if (status == PermissionStatus.Granted) return true; return false; } /// &lt;summary&gt; /// Permissions required for fingerprints /// &lt;/summary&gt; private class AndroidFingerprintPermissions : Permissions.BasePlatformPermission { public override (string androidPermission, bool isRuntime)[] RequiredPermissions =&gt; new List&lt;(string androidPermission, bool isRuntime)&gt; { (global::Android.Manifest.Permission.UseFingerprint, true), }.ToArray(); }} CheckingEligibility依次检查设备是否支持蓝牙（IsHardwareDetected）、设备是否有屏幕锁（IsKeyguardSecure）这里需要一个KeyguardManager的类帮助检查、是否注册了至少一个指纹（HasEnrolledFingerprints）、是否统一了使用指纹相关权限。 2、扫描指纹实现现在，我们使用FingerprintManager的Authenticate方法进行指纹验证， 123456JAVA代码public void authenticate (FingerprintManager.CryptoObject crypto, CancellationSignal cancel, int flags, FingerprintManager.AuthenticationCallback callback, Handler handler) 参数：crypto FingerprintManager.CryptoObject： 这是一个加密类的对象，指纹扫描器会使用这个对象来判断认证结果的合法性。这个对象可以是null，但是这样的话，就意味这app无条件信任认证结果，所以这个过程可能被攻击，数据可以被篡改。因此，建议这个参数不要置为null。cancel CancellationSignal：这个对象用来在指纹识别器扫描用户指纹的是时候取消当前的扫描操作，如果不取消的话，那么指纹扫描器会移植扫描直到超时（一般为30s，取决于具体的厂商实现），这样的话就会比较耗电。建议这个参数不要置为null。识别过程中可以手动取消指纹识别flags int：没用，传 0callback FingerprintManager.AuthenticationCallback：要接收身份验证事件的回调方法， 此值不能为 nullhandler Handler：FingerprintManagerCompat将会使用这个handler中的looper来处理来自指纹识别硬件的消息。一般来说，我们开发的时候可以直接传null，因为FingerprintManagerCompat会默认使用app的main looper来处理 我们继续在当前目录下添加CryptoObjectHelper.cs类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class CryptoObjectHelper { // 键值名称，应用中需要保持唯一 static readonly string KEY_NAME = &quot;com.masa-maui-blazor.android.sample.fingerprint_authentication_key&quot;; // 写死不用改 static readonly string KEYSTORE_NAME = &quot;AndroidKeyStore&quot;; // 加密算法参数 不用改 static readonly string KEY_ALGORITHM = KeyProperties.KeyAlgorithmAes; static readonly string BLOCK_MODE = KeyProperties.BlockModeCbc; static readonly string ENCRYPTION_PADDING = KeyProperties.EncryptionPaddingPkcs7; static readonly string TRANSFORMATION = KEY_ALGORITHM + &quot;/&quot; + BLOCK_MODE + &quot;/&quot; + ENCRYPTION_PADDING; readonly KeyStore _keystore; public CryptoObjectHelper() { _keystore = KeyStore.GetInstance(KEYSTORE_NAME); _keystore.Load(null); } public FingerprintManagerCompat.CryptoObject BuildCryptoObject() { var cipher = CreateCipher(); return new FingerprintManagerCompat.CryptoObject(cipher); } Cipher CreateCipher(bool retry = true) { var key = GetKey(); var cipher = Cipher.GetInstance(TRANSFORMATION); try { cipher.Init(CipherMode.EncryptMode, key); } catch (KeyPermanentlyInvalidatedException e) { _keystore.DeleteEntry(KEY_NAME); if (retry) { CreateCipher(false); } else { throw new Exception(&quot;Could not create the cipher for fingerprint authentication.&quot;, e); } } return cipher; } IKey GetKey() { IKey secretKey; if (!_keystore.IsKeyEntry(KEY_NAME)) { CreateKey(); } secretKey = _keystore.GetKey(KEY_NAME, null); return secretKey; } void CreateKey() { var keyGen = KeyGenerator.GetInstance(KeyProperties.KeyAlgorithmAes, KEYSTORE_NAME); var keyGenSpec = new KeyGenParameterSpec.Builder(KEY_NAME, KeyStorePurpose.Encrypt | KeyStorePurpose.Decrypt) .SetBlockModes(BLOCK_MODE) .SetEncryptionPaddings(ENCRYPTION_PADDING) .SetUserAuthenticationRequired(true) .Build(); keyGen.Init(keyGenSpec); keyGen.GenerateKey(); } } CryptoObjectHelper 类使用 Android KeyGenerator 生成密钥并安全地将其存储在设备上。创建的键类型的元数据由类的 KeyGenParameterSpec 实例提供。使用GetInstance工厂方法实例化 AKeyGenerator。上述代码使用 (AES) 作为加密算法。 KeyGenParameterSpec.Builde包装具体的AES加密配置信息，SetUserAuthenticationRequired(true) 表示在使用密钥之前需要用户身份验证。 我们在MasaMauiFingerprintService添加一个验证的方法，其中自定义的MasaMauiAuthCallback，在下面一节介绍。 1234public static void FingerPrintAuthentication(){ fingerprintManager.Authenticate(new CryptoObjectHelper().BuildCryptoObject(), 0, new CancellationSignal(), new MasaMauiAuthCallback(), null);} 3、响应身份验证回调我们在当前目录继续添加CallBack类MasaMauiAuthCallback.cs ，该类需要继承FingerprintManagerCompat.AuthenticationCallback，至少需要重写OnAuthenticationSucceeded方法 123456789101112131415161718192021222324252627282930public class MasaMauiAuthCallback : FingerprintManagerCompat.AuthenticationCallback { // 随便写，但是app内保持唯一 byte[] SECRET_BYTES = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }; public override void OnAuthenticationSucceeded(FingerprintManagerCompat.AuthenticationResult result) { if (result.CryptoObject.Cipher != null) //使用了Cipher { var doFinalResult = result.CryptoObject.Cipher.DoFinal(SECRET_BYTES); if (doFinalResult.Any()) { MessagingCenter.Send&lt;MasaMauiAuthCallback,string&gt;(this, &quot;Validation&quot;, &quot;验证成功&quot;); } } else { // 没有使用Cipher? // 我们这里的示例使用了Cipher，暂时不考虑不适用的情况 } } public override void OnAuthenticationFailed() { // 通知用户验证失败 MessagingCenter.Send&lt;MasaMauiAuthCallback, string&gt;(this, &quot;Validation&quot;, &quot;验证失败&quot;); } } 除了OnAuthenticationSucceeded和OnAuthenticationFailed之外，还有onAuthenticationHelp和onAuthenticationError我们这里暂不考虑其他两种情景，有兴趣可以参考链接: AuthenticationCallback这里为了方便演示，验证成功或者失败都是通过MessagingCenter消息发送出去，在使用的时候需要订阅对应topic，来获取验证结果。 4、测试新建一个MAUI Blazor项目Masa.Blazor.Maui.Plugin.BiometricsSample在AndroidManifest.xml文件中添加指纹需要的权限 USE_FINGERPRINT 1&lt;uses-permission android:name=&quot;android.permission.USE_FINGERPRINT&quot; /&gt; 简单修改一下Index.razor便于测试Index.razor： 12345@page &quot;/&quot;Welcome to your new app.&lt;MButton Block OnClick=&quot;Fingerprint&quot;&gt;验证指纹&lt;/MButton&gt; Index.razor.cs： 12345678910111213141516171819202122232425262728293031323334using Masa.Blazor.Maui.Plugin.Biometrics;using Microsoft.AspNetCore.Components;namespace Masa.Blazor.Maui.Plugin.BiometricsSample.Pages{ public partial class Index { [Inject] private IPopupService PopupService { get; set; } private async Task Fingerprint() { var checkingEligibilityErrorMessage = await MasaMauiFingerprintService.CheckingEligibility(); if (string.IsNullOrEmpty(checkingEligibilityErrorMessage)) { await HandledValidationAsync(); MasaMauiFingerprintService.FingerPrintAuthentication(); } else { await PopupService.ToastErrorAsync(checkingEligibilityErrorMessage); } } private async Task HandledValidationAsync() { // Cancel your subscription first to prevent duplicate subscriptions MessagingCenter.Unsubscribe&lt;MasaMauiAuthCallback, string&gt;(this, &quot;Validation&quot;); MessagingCenter.Subscribe&lt;MasaMauiAuthCallback, string&gt;(this, &quot;Validation&quot;, (sender, arg) =&gt; { PopupService.ToastInfoAsync(arg); }); } }} 这里我使用到MAUI提供的发布和订阅消息MessagingCenter， 参考连接链接: MessagingCenter 代码比较简单，先检查资格，没有报错信息之后开启指纹验证，并异步接收callback方法发布的消息。启动一下，分别用正确和错误的指纹进行测试：不同的手机指纹验证的UI不同，我这里是vivo的手机 如果你对我们的开源项目感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们 WeChat：MasaStackTechOps QQ：7424099","link":"/2022/11/08/MASA%20Blazor/MASA%20MAUI%20Plugin%20%EF%BC%88%E4%BA%94%EF%BC%89Android%20%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB/"},{"title":"MASA MAUI Plugin （八）Android相册多选照片（Intent 方式）","text":"背景MAUI的出现，赋予了广大Net开发者开发多平台应用的能力，MAUI 是Xamarin.Forms演变而来，但是相比Xamarin性能更好，可扩展性更强，结构更简单。但是MAUI对于平台相关的实现并不完整。所以MASA团队开展了一个实验性项目，意在对微软MAUI的补充和扩展 项目地址https://github.com/BlazorComponent/MASA.Blazor/tree/feature/Maui/src/Masa.Blazor.Maui.Plugin 每个功能都有单独的demo演示项目，考虑到app安装文件体积（虽然MAUI已经集成裁剪功能，但是该功能对于代码本身有影响），届时每一个功能都会以单独的nuget包的形式提供，方便测试，现在项目才刚刚开始，但是相信很快就会有可以交付的内容啦。 前言本系列文章面向移动开发小白，从零开始进行平台相关功能开发，演示如何参考平台的官方文档使用MAUI技术来开发相应功能。 介绍项目中有需要从相册多选图片的需求，MAUI提供的MediaPicker.PickPhotoAsync无多选功能，FilePicker.PickMultipleAsync虽然可以实现多选，但是多选文件需要长按，而且没有预览和返回按钮，用户交互效果不好。作为安卓开发小白，本人目前找到两种UI交互良好而且不需要定制选取界面的方法和大家分享。 一、MAUI实现方式演示效果MediaPicker.Default.PickPhotoAsync 效果 FilePicker.Default.PickMultipleAsync 效果 二、实现方式思路 https://developer.android.google.cn/about/versions/13/features/photopicker?hl=zh-cn 我们参考一下官方文档，下面为选择多张照片或者多个视频的示例 123456789JAVA代码// Launches photo picker in multi-select mode.// This means that user can select multiple photos/videos, up to the limit// specified by the app in the extra (10 in this example).final int maxNumPhotosAndVideos = 10;Intent intent = new Intent(MediaStore.ACTION_PICK_IMAGES);intent.putExtra(MediaStore.EXTRA_PICK_IMAGES_MAX, maxNumPhotosAndVideos);startActivityForResult(intent, PHOTO_PICKER_MULTI_SELECT_REQUEST_CODE); 处理照片选择器结果 1234567891011121314151617181920212223242526272829JAVA代码// onActivityResult() handles callbacks from the photo picker.@Overrideprotected void onActivityResult( int requestCode, int resultCode, final Intent data) { if (resultCode != Activity.RESULT_OK) { // Handle error return; } switch(requestCode) { case REQUEST_PHOTO_PICKER_SINGLE_SELECT: // Get photo picker response for single select. Uri currentUri = data.getData(); // Do stuff with the photo/video URI. return; case REQUEST_PHOTO_PICKER_MULTI_SELECT: // Get photo picker response for multi select for (int i = 0; i &lt; data.getClipData().getItemCount(); i++) { Uri currentUri = data.getClipData().getItemAt(i).getUri(); // Do stuff with each photo/video URI. } return; }} 限定选择内容范围 默认情况下，照片选择器会既显示照片又显示视频。您还可以在 setType() 方法中设置 MIME 类型，以便按“仅显示照片”或“仅显示视频”进行过滤 12345678910JAVA代码// Launches photo picker for videos only in single select mode.Intent intent = new Intent(MediaStore.ACTION_PICK_IMAGES);intent.setType(&quot;video/*&quot;);startActivityForResult(intent, PHOTO_PICKER_VIDEO_SINGLE_SELECT_REQUEST_CODE);// Apps can also change the mimeType to allow users to select// images only - intent.setType(&quot;image/*&quot;);// or a specific mimeType - intent.setType(&quot;image/gif&quot;); 总结流程如下： 1、通过Intent(MediaStore.ACTION_PICK_IMAGES) 初始化一个打开相册的Intent 2、intent.setType 设置过滤条件 3、通过startActivityForResult打开新的Activity（打开相册），并通过重写onActivityResult 获取选取照片的返回数据 4、从返回的Intent 中拿到文件的Uri从而获取文件内容 注意：在一个Activity中，可能会使用startActivityForResult() 方法打开多个不同的Activity处理不同的业务 ,这时可以在onActivityResult中通过requestCode区分不同业务。 编写实现代码新建MAUI Blazor项目MediaPickSample，新建Service文件夹，添加IPhotoPickerService.cs接口，添加GetImageAsync1-3，前两种为使用MAUI的两种方式实现，用做对比，不过多介绍，本文重点关注Intent方式实现的GetImageAsync3。示例方法的返回值为文件名+文件base64的字典形式。 123456789101112131415161718192021namespace MediaPickSample.Service{ public interface IPhotoPickerService { /// &lt;summary&gt; /// Maui-MediaPicker /// &lt;/summary&gt; Task&lt;Dictionary&lt;string, string&gt;&gt; GetImageAsync1(); /// &lt;summary&gt; /// MMaui-FilePicker /// &lt;/summary&gt; Task&lt;Dictionary&lt;string, string&gt;&gt; GetImageAsync2(); /// &lt;summary&gt; /// Intent /// &lt;/summary&gt; Task&lt;Dictionary&lt;string, string&gt;&gt; GetImageAsync3(); }} 由于StartActivityForResult需要在MainActivity中调用，我们先定义一个MainActivity的静态示例Instance，方便在业务中使用。 编辑Platforms-&gt;Android-&gt;MainActivity.cs文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class MainActivity : MauiAppCompatActivity{ internal static MainActivity Instance { get; private set; } public static readonly int PickImageId = 1000; public TaskCompletionSource&lt;Dictionary&lt;string, string&gt;&gt; PickImageTaskCompletionSource { set; get; } protected override void OnCreate(Bundle savedInstanceState) { Instance = this; base.OnCreate(savedInstanceState); } protected override void OnActivityResult(int requestCode, Result resultCode, Android.Content.Intent intent) { base.OnActivityResult(requestCode, resultCode, intent); if (requestCode == PickImageId) { if ((resultCode == Result.Ok) &amp;&amp; (intent != null)) { var imageNames = intent.ClipData; if (imageNames != null) { var uris = new List&lt;Android.Net.Uri&gt;(); for (int i = 0; i &lt; imageNames.ItemCount; i++) { var imageUri = imageNames.GetItemAt(i).Uri; uris.Add(imageUri); } var fileList = Instance.GetImageDicFromUris(uris); PickImageTaskCompletionSource.SetResult(fileList); } } else { PickImageTaskCompletionSource.SetResult(new Dictionary&lt;string, string&gt;()); } } }} 首先我们定义了MainActivity的静态实例Instance，并在OnCreate事件中赋值 然后添加重写方法OnActivityResult，通过requestCode == PickImageId判断是从相册选取多个文件的业务（我们关注的业务），通过intent.ClipData获取数据，然后遍历这些数据依次通过GetItemAt(i).Uri获取所有的文件Uri，然后再通过我们封装的GetImageDicFromUris方法获取所有文件的内容。GetImageDicFromUris方法如下 1234567891011121314151617181920212223protected Dictionary&lt;string, string&gt; GetImageDicFromUris(List&lt;Android.Net.Uri&gt; list){ Dictionary&lt;string, string&gt; fileList = new Dictionary&lt;string, string&gt;(); for (int i = 0; i &lt; list.Count; i++) { var imageUri = list[i]; var documentFile = DocumentFile.FromSingleUri(Instance, imageUri); if (documentFile != null) { using (var stream = Instance.ContentResolver.OpenInputStream(imageUri)) { stream.Seek(0, SeekOrigin.Begin); var bs = new byte[stream.Length]; var log = Convert.ToInt32(stream.Length); stream.Read(bs, 0, log); var base64Str = Convert.ToBase64String(bs); fileList.Add($&quot;{Guid.NewGuid()}.{Path.GetExtension(documentFile.Name)}&quot;, base64Str); } } } return fileList;} DocumentFile位于AndroidX.DocumentFile.Provider命名空间，FromSingleUri方法通过Uri返回DocumentFile，然后通过ContentResolver.OpenInputStream读出文件流 ContentResolver的内容比较多，可以参考官方文档，这里我们简单理解它是一个内容提供程序即可 https://developer.android.google.cn/guide/topics/providers/content-provider-basics?hl=zh-cn 下面开始实现IPhotoPickerService接口 在Platforms-&gt;Android 新建AndroidPhotoPickerService.cs 123456789101112131415161718192021222324252627282930313233343536namespace MediaPickSample.PlatformsAndroid{ public class AndroidPhotoPickerService : IPhotoPickerService { /// &lt;summary&gt; /// Maui-MediaPicker /// &lt;/summary&gt; public async Task&lt;Dictionary&lt;string, string&gt;&gt; GetImageAsync1() { ... } /// &lt;summary&gt; /// MMaui-FilePicker /// &lt;/summary&gt; public async Task&lt;Dictionary&lt;string, string&gt;&gt; GetImageAsync2() { ... } /// &lt;summary&gt; /// Intent /// &lt;/summary&gt; public Task&lt;Dictionary&lt;string, string&gt;&gt; GetImageAsync3() { Intent intent = new Intent(Intent.ActionPick); intent.SetDataAndType(MediaStore.Images.Media.ExternalContentUri, &quot;image/*&quot;); intent.PutExtra(Intent.ExtraAllowMultiple,true); MainActivity.Instance.StartActivityForResult(Intent.CreateChooser(intent, &quot;Select Picture&quot;), MainActivity.PickImageId); MainActivity.Instance.PickImageTaskCompletionSource = new TaskCompletionSource&lt;Dictionary&lt;string, string&gt;&gt;(); return MainActivity.Instance.PickImageTaskCompletionSource.Task; } }} 我们只关注Intent实现的GetImageAsync3方法 首先先初始化一个Intent.ActionPick类型的Intent，选择数据我们需要使用ACTION_PICK 类型。 常见的Intent类型参考官方文档 https://developer.android.google.cn/guide/components/intents-common?hl=zh-cn intent.SetDataAndType方法设置Intent的数据和MIME数据类型 https://developer.android.com/reference/android/content/Intent#setDataAndType(android.net.Uri, java.lang.String) intent.PutExtra 设置可以多选 然后就可以通过MainActivity的静态实例Instance的StartActivityForResult方法启动这个intent了，我们这里通过Intent.CreateChooser给Intent设置了一个标题，并传递requestCode用以区分业务。 编写演示代码修改Index.razor文件，界面使用的是MASA Blazor 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105@page &quot;/&quot;@using Masa.BuildingBlocks.Storage.ObjectStorage;@using MediaPickSample.Service;&lt;MCard Color=&quot;#FFFFFF&quot; Class=&quot;mx-auto rounded-3 mt-3&quot; Elevation=&quot;0&quot;&gt; &lt;MCardText&gt; &lt;div class=&quot;d-flex&quot; style=&quot;flex-wrap: wrap&quot;&gt; @if (_phoneDictionary.Any()) { @foreach (var phone in _phoneDictionary) { &lt;div style=&quot;position: relative; height: 90px; width: 90px;&quot; class=&quot;mr-2 mb-2&quot;&gt; &lt;MImage Src=&quot;@phone.Value&quot; AspectRatio=&quot;1&quot; Class=&quot;grey lighten-2&quot;&gt; &lt;PlaceholderContent&gt; &lt;MRow Class=&quot;fill-height&quot; Align=&quot;@AlignTypes.Center&quot; Justify=&quot;@JustifyTypes.Center&quot;&gt; &lt;MProgressCircular Indeterminate&gt;&lt;/MProgressCircular&gt; &lt;/MRow&gt; &lt;/PlaceholderContent&gt; &lt;/MImage&gt; &lt;MButton Small Icon Tile Style=&quot;position: absolute; top: 0; right: 0; background: #000000; opacity: 0.5;&quot; Dark OnClick=&quot;() =&gt; RemoveItem(phone.Key)&quot;&gt; &lt;MIcon&gt; mdi-close &lt;/MIcon&gt; &lt;/MButton&gt; &lt;/div&gt; } } &lt;MBottomSheet&gt; &lt;ActivatorContent&gt; &lt;MButton XLarge Icon Style=&quot;background: #F7F8FA;border-radius: 2px; height:80px;width:80px; &quot; @attributes=&quot;@context.Attrs&quot;&gt; &lt;MIcon XLarge Color=&quot;#D8D8D8&quot;&gt;mdi-camera&lt;/MIcon&gt; &lt;/MButton&gt; &lt;/ActivatorContent&gt; &lt;ChildContent&gt; &lt;MCard&gt; &lt;MList&gt; &lt;MListItem OnClick=&quot;GetImageAsync1&quot;&gt;&lt;MListItemContent&gt;&lt;MListItemTitle&gt;Maui-MediaPicker&lt;/MListItemTitle&gt;&lt;/MListItemContent&gt;&lt;/MListItem&gt; &lt;MListItem OnClick=&quot;GetImageAsync2&quot;&gt;&lt;MListItemContent&gt;&lt;MListItemTitle&gt;Maui-FilePicker&lt;/MListItemTitle&gt;&lt;/MListItemContent&gt;&lt;/MListItem&gt; &lt;MListItem OnClick=&quot;GetImageAsync3&quot;&gt;&lt;MListItemContent&gt;&lt;MListItemTitle&gt;Intent&lt;/MListItemTitle&gt;&lt;/MListItemContent&gt;&lt;/MListItem&gt; &lt;/MList&gt; &lt;/MCard&gt; &lt;/ChildContent&gt; &lt;/MBottomSheet&gt; &lt;/div&gt; &lt;/MCardText&gt;&lt;/MCard&gt;@code { [Inject] private IPhotoPickerService _photoPickerService { get; set; } [Inject] private IClient _client { get; set; } private Dictionary&lt;string, string&gt; _phoneDictionary { get; set; } = new Dictionary&lt;string, string&gt;(); private async Task GetImageAsync1() { ... } private async Task GetImageAsync2() { ... } private async Task GetImageAsync3() { var photoDic = await _photoPickerService.GetImageAsync3(); foreach (var photo in photoDic) { var fileUrl = await UploadImageAsync(photo.Value, Path.GetExtension(photo.Key)); _phoneDictionary.Add(photo.Key, fileUrl); } } private void RemoveItem(string key) { _phoneDictionary.Remove(key); } private async Task&lt;string&gt; UploadImageAsync(string fileBase64, string fileExtension) { byte[] fileBytes = Convert.FromBase64String(fileBase64); var newFileName = $&quot;{Guid.NewGuid() + fileExtension}&quot;; var newFileFullPath = $&quot;images/xxx/xxx/{newFileName}&quot;; using (var fileStream = new MemoryStream(fileBytes)) { try { await InvokeAsync(StateHasChanged); await _client.PutObjectAsync(&quot;xxx&quot;, newFileFullPath, fileStream); return $&quot;https://img-cdn.xxx.cn/{newFileFullPath}&quot;; } catch (Exception ex) { if (ex.Message.Contains(&quot;x-oss-hash-crc64ecma&quot;)) { return $&quot;https://img-cdn.xxx.cn/{newFileFullPath}&quot;; } else { return string.Empty; } } } }} 代码比较简单，不过多介绍，这里的UploadImageAsync方法使用的是Masa.BuildingBlocks.Storage提供的SDK实现上传到阿里云存储。 不要忘记在MauiProgram.cs添加依赖注入 1234#if ANDROID builder.Services.AddSingleton&lt;IPhotoPickerService, AndroidPhotoPickerService&gt;();#endif 在AndroidManifest.xml添加必要的权限-android.permission.READ_EXTERNAL_STORAG，并添加**android:usesCleartextTraffic=”true”**（上传阿里云使用） 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/appicon&quot; android:usesCleartextTraffic=&quot;true&quot; android:roundIcon=&quot;@mipmap/appicon_round&quot; android:supportsRtl=&quot;true&quot;&gt;&lt;/application&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; /&gt;&lt;/manifest&gt; 三、演示效果 下一篇我们介绍另外一种实现方式。 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们 WeChat：MasaStackTechOps QQ：7424099","link":"/2023/02/21/MASA%20Blazor/MASA%20MAUI%20Plugin%20%EF%BC%88%E5%85%AB%EF%BC%89Android%E7%9B%B8%E5%86%8C%E5%A4%9A%E9%80%89%E7%85%A7%E7%89%87%EF%BC%88Intent%20%E6%96%B9%E5%BC%8F%EF%BC%89/"},{"title":"MASA MAUI Plugin （六）集成个推，实现本地消息推送[Android] 篇","text":"背景MAUI的出现，赋予了广大Net开发者开发多平台应用的能力，MAUI 是Xamarin.Forms演变而来，但是相比Xamarin性能更好，可扩展性更强，结构更简单。但是MAUI对于平台相关的实现并不完整。所以MASA团队开展了一个实验性项目，意在对微软MAUI的补充和扩展 项目地址https://github.com/BlazorComponent/MASA.Blazor/tree/main/src/Masa.Blazor.Maui.Plugin 每个功能都有单独的demo演示项目，考虑到app安装文件体积（虽然MAUI已经集成裁剪功能，但是该功能对于代码本身有影响），届时每一个功能都会以单独的nuget包的形式提供，方便测试，现在项目才刚刚开始，但是相信很快就会有可以交付的内容啦。 前言本系列文章面向移动开发小白，从零开始进行平台相关功能开发，演示如何参考平台的官方文档使用MAUI技术来开发相应功能。 介绍鉴于现在运营需求的增强，消息推送在Android开发中应用的场景是十分常见，如电商的活动宣传、资讯类产品进行新闻推送等等，所以关于这个功能我就不过多介绍了。面向海外推送业务MAUI有一些集成Google firebase或其他运营商的可用的示例和绑定库可用，但是国内用户无法使用这些，对于国内比较常见的例如极光、个推等，也没用对应的MAUI或者Xamarin的SDK可用，本人联系过官方也无法提供任何技术支持。 但是，这样的困难是无法难倒MASA的开发人员的，所以在各方压力的鞭策下，有了本文，本文以“国内服务提供商个推(https://www.getui.com)的Android 原生SDK”为例，提供Android原生代码到MAUI代码的绑定及实现方式。 思路Android 的第三方库生态系统非常庞大。 正因为此，使用现有的 Android 库通常比创建一个新的库更合理。其实早在Xamarin的时代，微软已经提供了Android 绑定库(Xamarin)这个项目，实现原理为：创建一个绑定库，该库使用 C# 包装器自动包装库，以便通过 C# 调用来调用 Java 代码，通过使用托管可调用包装器 (MCW) 实现绑定。 MCW 是一个 JNI 桥，在托管代码需要调用 Java 代码时会使用它。 托管可调用包装器还支持对 Java 类型进行子类化以及覆盖 Java 类型的虚拟方法。 同样，每当 Android 运行时 (ART) 代码需要调用托管代码时，它都会通过另一个称为 Android 可调用包装器 (ACW) 的 JNI 桥来实现。 下图说明了此体系结构 通常情况下，绑定 Android 库（.aar 或 .jar）文件绝非易事；通常它需要花费额外的精力来解决 Java 和 .NET 之间的差异导致的问题。 这些问题会使 MAUI无法绑定 Android 库，并在生成日志中显示为错误消息。 推送功能涉及到的内容非常多，接下来我们只开发最基础的功能，并对此做最精简配置。 开发步骤一、下载个推Android SDK个推账号的申请及应用的创建请参考官方文档（个推面向个人开发者，而且我们通过CID发送测试是免费的，无需充值和实名认证）。这里我们着重介绍集成的方法，个推官网的文档示例是使用Maven 方式集成，但是这种方式在MAUI当然无法实现，所以我们需要手动下载SDK对应的aar文件进行手动集成。 maven仓库地址为http://mvn.getui.com/nexus/content/repositories/releases/com/getui 我们需要 gtsdk和gtc，分别下载最新的gtc-3.1.12.0.aar和gtsdk-3.2.13.0.aar 我是怎么知道需要使用这两个文件呢，因为我下载了官方的Demo然后使用maven集成后在 C:\\Users\\用户名\\.gradle\\caches\\modules-2\\files-2.1\\com.getui 目录下载了这两个文件 :wink: 二、创建Android绑定库新建一个项目:Masa.Blazor.Maui.Plugin.GeTuiPushBinding，项目模板选择 Android Java 库绑定 在根目录创建Jars文件夹，并将下载的两个aar文件添加进去。添加进去的文件属性中，生成操作默认选择的是AndroidLibrary，如果不对请手动更正。 前方高能预警:sunglasses: 右键生成这个项目，我们会看到很多编译警告，其中还包含6处错误。 我们依次点击对应错误，进入生成的cs文件，这些文件位于obj\\Debug\\net7.0-android\\generated\\src 错误1和2对应Com.Getui.Gtc.Base.Crypt.CryptTools文件的Decrypt和Encrypt方法，这里Java.IO.OutputStream和InputStream类型都被转换为System.IO.Stream，导致本来两个签名不一致的方法被弄成了一样(更正的方法本文不做讨论，本Demo没有使用到这两个方法）索性将280行和134行的本来应该映射到OutputStream类型的Decrypt和Encrypt方法注释。 其他错误都是类型转换错误导致的没有实现接口，我们分别修改4个OnArrived方法，将方法的参数 global::Org.Json.JSONObject修改为Java.Lang.Object，并将方法的virtual标记更改为override，只有一个参数的OnArrived方法需要将返回值也修改为Java.Lang.Object。 4处全部更正之后，再次生成就不会有报错了。 注意：不要选重新生成，重新生成会将之前的修改覆盖掉。 三、创建Demo项目新建一个MAUI Blazor项目：Masa.Blazor.Maui.Plugin.GeTuiSample,添加对Masa.Blazor.Maui.Plugin.GeTuiPushBinding项目的引用 1、初始化个推SDK个推SDK的初始化在MainActivity.OnCreate() 或MainApplication.OnCreate()方法中都是可以的，我们这里在MainActivity中初始化。修改Platforms-&gt;Android-&gt;MainActivity.cs文件，在MainActivity的OnCreate事件中添加我们的初始化方法 1234567891011121314151617public class MainActivity : MauiAppCompatActivity{ protected override void OnCreate(Bundle savedInstanceState) { base.OnCreate(savedInstanceState); Com.Igexin.Sdk.PushManager.Instance.Initialize(this); var cid = Com.Igexin.Sdk.PushManager.Instance.GetClientid(this); System.Diagnostics.Debug.WriteLine($&quot;cid:{cid}&quot;); }} 因为我们完成了绑定，所以这里可以使用个推SDK中的Com.Igexin.Sdk命名空间下的PushManager来完成初始化， 初始化方法Initialize非常简单，初始化后我们可以通过GetClientid方法拿到客户端ID，方便我们后续在个推平台下发推送测试任务，因为向特定CID发送推送是免费的。 2、配置推送服务继续在Android目录下新建推送服务类DemoPushService 12345678910111213141516using Android.App;namespace Masa.Blazor.Maui.Plugin.GeTuiSample{ [Service(Process = &quot;:pushservice&quot;, Exported = false)] public class DemoPushService : Com.Igexin.Sdk.PushService { }} 我们只要实现一个继承自Com.Igexin.Sdk.PushService的类即可。 注意：服务必须指定Process = “:pushservice”，设置了这行代码，系统就会为该服务创建新的进程，DemoPushService 将运行在这个新的独立的进程，它所在的apk依旧运行在原来进程。这样就实现了Android使用多进程。 android:exported 是Android中的四大组件 Activity，Service，Provider，Receiver 四大组件中都会有的一个属性。 主要作用是：是否支持其它应用调用。 处于安全考虑我们这里设置为Exported = false，代表不支持其他应用调用。 修改AndroidManifest.xml文件 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/appicon&quot; android:roundIcon=&quot;@mipmap/appicon_round&quot; android:supportsRtl=&quot;true&quot; android:label=&quot;@string/app_name&quot; android:usesCleartextTraffic=&quot;true&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;service android:name=&quot;Masa.Blazor.Maui.Plugin.GeTuiSample.DemoPushService&quot; android:exported=&quot;false&quot; android:label=&quot;PushService&quot; android:process=&quot;:pushservice&quot;/&gt; &lt;meta-data android:name=&quot;GETUI_APPID&quot; tools:replace=&quot;android:value&quot; android:value=&quot;这里填你在个推的APPID&quot; /&gt; &lt;/application&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&lt;/manifest&gt; 我们在application 中添加了xmlns:tools=”http://schemas.android.com/tools“，作用是在下面的meta-data中使用tools:replace，否则会出现Android 组件化集成合并AndroidManifest.xml 的问题，添加android:label=”@string/app_name”也是为了避免合并问题。 service表示我们添加的自定义推送类，android:name的值必须写全命名空间。 GETUI_APPID部分为个推应用对应的APPID 我们启动应用，并在个推平台下发一个测试推送 Android推送功能涉及的内容非常多，不同的Android版本、不同手机厂商还有不同的功能和实现方式，例如vivo有特有的角标通知等。我们这里只演示了最基本的推送功能，其他高级操作，例如自定义接收推送服务事件，设置通知图标及样式，相应对应通知点击事件，离线推送功能等，如有需求后续介绍。 如果你对我们的开源项目感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们 WeChat：MasaStackTechOps QQ：7424099","link":"/2022/11/15/MASA%20Blazor/MASA%20MAUI%20Plugin%20%EF%BC%88%E5%85%AD%EF%BC%89%E9%9B%86%E6%88%90%E4%B8%AA%E6%8E%A8%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%5BAndroid%5D%20%E7%AF%87/"},{"title":"MASA MAUI Plugin （十）iOS消息推送（原生APNS方式）","text":"背景MAUI的出现，赋予了广大Net开发者开发多平台应用的能力，MAUI 是Xamarin.Forms演变而来，但是相比Xamarin性能更好，可扩展性更强，结构更简单。但是MAUI对于平台相关的实现并不完整。所以MASA团队开展了一个实验性项目，意在对微软MAUI的补充和扩展 项目地址**https://github.com/BlazorComponent/MASA.Blazor/tree/feature/Maui/src/Masa.Blazor.Maui.Plugin** 每个功能都有单独的demo演示项目，考虑到app安装文件体积（虽然MAUI已经集成裁剪功能，但是该功能对于代码本身有影响），届时每一个功能都会以单独的nuget包的形式提供，方便测试，现在项目才刚刚开始，但是相信很快就会有可以交付的内容啦。 前言本系列文章面向移动开发小白，从零开始进行平台相关功能开发，演示如何参考平台的官方文档使用MAUI技术来开发相应功能。 介绍Apple 推送通知服务（Apple Push Notification service），简称 APNs。与之前Android使用个推不同，由于APNs国内可用，所以我们可以直接使用APNs来实现远程消息推送，不依赖其他第三方组件和服务。我们这里推送使用的是p8证书，p8证书相对p12证书来讲，更灵活，而且没有p12证书有效期1年的限制。 一、实现方式一、申请p8证书 https://developer.apple.com/ 1、登录开发者中心，点击右上角Account，找到Keys管理。 2、在顶部点击+号。 3、勾选APNs服务，并输入Key名称，下一步Continue。 4、点击Register。 5、记录Key ID,并下载证书，得到AuthKey_xxxxxxxxxx.p8证书文件。 6、获取Team ID，Account界面点击Membership details 二、编写MAUI实现代码 参考官方文档：https://developer.apple.com/documentation/usernotifications/registering_your_app_with_apns 1、首先需要先开启App消息推送的能力 我们新建一个iOSPush 文件夹，并在文件夹下面新建MauiBlazor项目iOSPushSample （由于受打包长度影响，项目名称和文件夹名称，我这里尽量简短。路径长度超过255会导致编译时提示部分文件找不到。） 我们找到Platforms-&gt;iOS-&gt;Info.plist文件，双击用默认的iOS清单编辑器打开，勾选“启用后台模式”和“远程通知”。这项操作会在Info.plist文件中添加如下信息： 12345&lt;key&gt;UIBackgroundModes&lt;/key&gt;&lt;array&gt; &lt;string&gt;remote-notification&lt;/string&gt;&lt;/array&gt; 在开发环境，你需要以下的额外配置。 如果你的项目已经使用了Entitlements.plist文件，双击打开改文件，并勾选“推送通知”。 如果没有这个文件，那么新建这个文本文件，内容如下： 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;aps-environment&lt;/key&gt; &lt;string&gt;development&lt;/string&gt;&lt;/dict&gt;&lt;/plist&gt; 注意：这项配置的目的是在development环境支持推送，如果在项目发布的时候，MAUI不会自动清除，需要手动关闭或注释掉这项配置，否则会报错。 2、编写实现代码 参考文档 https://developer.apple.com/documentation/usernotifications/registering_your_app_with_apns 我们首先需要将App注册到APNs并获取唯一的device token。在iOS中需要调用UIApplication 中通过registerForRemoteNotifications() 方法，实现注册，如果注册成功，就可以在delegate的application(_:didRegisterForRemoteNotificationsWithDeviceToken:) 方法中获取device token。如果注册失败，会触发application(_:didFailToRegisterForRemoteNotificationsWithError:) 方法。 123456789101112131415161718192021Swift代码func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool { // Override point for customization after application launch.you’re UIApplication.shared.registerForRemoteNotifications() return true}func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) { self.sendDeviceTokenToServer(data: deviceToken)}func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) { // Try again later.} 我们开始编写代码 向APNs注册设备首先在iOS-&gt;AppDelegate.cs 类中，重写FinishedLaunching 方法，在应用启动之后进行注册。 123456789101112131415161718192021[Register(&quot;AppDelegate&quot;)]public class AppDelegate : MauiUIApplicationDelegate{ protected override MauiApp CreateMauiApp() =&gt; MauiProgram.CreateMauiApp(); public override bool FinishedLaunching(UIApplication application, NSDictionary launchOptions) { UNUserNotificationCenter center = UNUserNotificationCenter.Current; var options = UNAuthorizationOptions.Alert | UNAuthorizationOptions.Sound | UNAuthorizationOptions.CriticalAlert; // Request notification permissions from the user center.RequestAuthorization(options, (bool success, NSError error) =&gt; { // Handle approval } ); UIApplication.SharedApplication.RegisterForRemoteNotifications(); return base.FinishedLaunching(application, launchOptions); }} 应用启动时应立即请求通知权限，方法是将以下代码添加到FinishedLaunchingAppDelegate 所需通知类型 (UNAuthorizationOptions) 的方法： UNUserNotificationCenter 仅适用于 iOS 10+,但是考虑到基本没人用低于10的版本了，这里我们就不做版本检查了 用户可以批准应用的三个不同级别的通知请求： 横幅显示-Alert 。 声音警报-Sound 。 对应用图标进行错误设置-CriticalAlert。 请求权限结束后我们通过 UIApplication.SharedApplication.RegisterForRemoteNotifications(); 向APNs注册。 注册成功后我们通过application:didRegisterForRemoteNotificationsWithDeviceToken: 方法获取device token，但是由于这个方法是在UIApplication下，但是我们的AppDelegate是继承自 MauiUIApplicationDelegate ，默认没有这个方法，我们可以通过Export特性，导出我们需要的方法，继续在AppDelegate中添加 123456789101112131415161718192021222324[Export(&quot;application:didFailToRegisterForRemoteNotificationsWithError:&quot;)]public void FailedToRegisterForRemoteNotifications(UIKit.UIApplication application, NSError error){ Console.WriteLine(&quot;FailedToRegisterForRemoteNotifications&quot;);}[Export(&quot;application:didRegisterForRemoteNotificationsWithDeviceToken:&quot;)]public void RegisteredForRemoteNotifications(UIKit.UIApplication application, Foundation.NSData deviceToken){ var token = ExtractToken(deviceToken); Preferences.Default.Set(&quot;PushToken&quot;, token); Console.WriteLine(token);}private string ExtractToken(NSData deviceToken){ if (deviceToken.Length == 0) return null; var result = new byte[deviceToken.Length]; System.Runtime.InteropServices.Marshal.Copy(deviceToken.Bytes, result, 0, (int)deviceToken.Length); return BitConverter.ToString(result).Replace(&quot;-&quot;, &quot;&quot;);} ExtractToken是将返回的deviceToken解析为推送可用的字符串。 我们通过Preferences.Default.Set将token存储起来，方便在登录等业务中使用。 接收远程推送接收推送的消息是通过**application:didReceiveRemoteNotification:fetchCompletionHandler:**实现的 1234567891011[Export(&quot;application:didReceiveRemoteNotification:fetchCompletionHandler:&quot;)]public void DidReceiveRemoteNotification(UIKit.UIApplication application, NSDictionary userInfo, Action&lt;UIKit.UIBackgroundFetchResult&gt; completionHandler){ foreach (var item in userInfo) { var alertMsg = ((NSDictionary)item.Value)[&quot;alert&quot;]; Console.WriteLine($&quot;alertMsg:{alertMsg}&quot;); } Console.WriteLine(&quot;DidReceiveRemoteNotification&quot;);} 其实我们在方法内部不需要写任何代码，就可以实现基本的推送功能。但如果想处理推送过来的消息，可以通过NSDictionary类型userInfo中拿到。这里示例从alert中拿到具体的消息内容，并打印。 三、编写演示代码我们修改Index.razor，通过点击按钮获取设备Token 12345678910111213@page &quot;/&quot;&lt;button @onclick=&quot;GetDeviceToken&quot;&gt;Get Device Token&lt;/button&gt;&lt;text&gt;@deviceToken&lt;/text&gt;@code{ private string deviceToken { get; set; } private void GetDeviceToken() { deviceToken= Preferences.Default.Get(&quot;PushToken&quot;,string.Empty); }} 四、服务端测试我们可以通过个推的在线测试工具，配置好p8证书和其他参数。 我这里写了一个命令行的测试程序,这里使用了第三方的PushNotifications.Server包 12345678910111213141516171819using PushNotifications.Server.Apple;Console.WriteLine(&quot;Hello, World!&quot;);IApnsClient apnsClient = new ApnsClient(new ApnsJwtOptions{ CertContent = &quot;-----BEGIN PRIVATE KEY-----\\r\\nxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\\r\\n-----END PRIVATE KEY-----&quot;, KeyId = &quot;LUxxxxxxxx&quot;, TeamId = &quot;V4xxxxxxxx&quot;, BundleId = &quot;com.iOSPush.Sample&quot;, UseSandbox = true});var apnsRequest = new ApnsRequest(ApplePushType.Alert) .AddToken(&quot;47006118F8xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;) .AddSound() .AddAlert(&quot;MASA&quot;, $&quot;Message @ {DateTime.Now}&quot;, $&quot;Message @ {DateTime.Now}&quot;);var apnsResponse = await apnsClient.SendAsync(apnsRequest);Console.ReadKey(); 五、演示效果 可以看出，应用打开的状态不会收到推送，后台运行或者划掉关闭都可以收到通知。 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们 WeChat：MasaStackTechOps QQ：7424099","link":"/2023/03/08/MASA%20Blazor/MASA%20MAUI%20Plugin%20%EF%BC%88%E5%8D%81%EF%BC%89iOS%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%EF%BC%88%E5%8E%9F%E7%94%9FAPNS%E6%96%B9%E5%BC%8F%EF%BC%89/"},{"title":"MASA MAUI Plugin （四）条形码、二维码扫描功能","text":"背景MAUI的出现，赋予了广大.Net开发者开发多平台应用的能力，MAUI 是Xamarin.Forms演变而来，但是相比Xamarin性能更好，可扩展性更强，结构更简单。但是MAUI对于平台相关的实现并不完整。所以MASA团队开展了一个实验性项目，意在对微软MAUI的补充和扩展 项目地址https://github.com/BlazorComponent/MASA.Blazor/tree/main/src/Masa.Blazor.Maui.Plugin 每个功能都有单独的demo演示项目，考虑到app安装文件体积（虽然MAUI已经集成裁剪功能，但是该功能对于代码本身有影响），届时每一个功能都会以单独的nuget包的形式提供，方便测试，现在项目才刚刚开始，但是相信很快就会有可以交付的内容啦。 前言本系列文章面向移动开发小白，从零开始进行平台相关功能开发，演示如何参考平台的官方文档使用MAUI技术来开发相应功能。 介绍移动端的扫描条形码、二维码的功能已经随处可见，已经很难找到一个不支持扫描的App了，但是微软的MAUI竟然没有提供，那么我们应该如何实现呢？ 其实早在 Xamarin开发的时候就已经有前辈实现了扫码功能，例如 ZXing.Net.Mobile ,该包目前依旧可以在MAUI的Android平台正常工作，但是在iOS平台经过测试无法正常工作。 那iOS有办法实现扫描条形码功能吗？ 前辈已经提供了基于MAUI的更新包 ZXing.Net.Maui https://github.com/Redth/ZXing.Net.Maui 提供了一个XAML的控件 zxing:CameraBarcodeReaderView 但是没有提供Blazor的组件，因此我们就在此基础上，在Blazor中使用XAML页面实现条形码扫描功能。 思路这里我们的思路是在Blazor 页面通过一个模态弹窗弹出一个新的XAML页面，然后在新页面扫码结束后关闭当前页面将扫码结果带回到Blazor页面。但是怎么实现呢，我们在 Xamarin.Forms 找到了 INavigation接口，该接口提供了特定与接口抽象的平台导航，具体参考 https://learn.microsoft.com/en-us/dotnet/api/xamarin.forms.inavigation?view=xamarin-forms 我们可以使用该接口的PopModalAsync方法，用来异步弹出一个模态窗口。 开发步骤1、我们新建一个MAUI类库项目 Masa.Blazor.Maui.Plugin.QrCode2、安装 ZXing.Net.MAUI NuGet包3、在项目中新建.Net MAUI ContentPage(XAML) BarcodeReader.xaml文件，并添加如下代码 12345678910111213141516&lt;ContentPage xmlns=&quot;http://schemas.microsoft.com/dotnet/2021/maui&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot; xmlns:zxing=&quot;clr-namespace:ZXing.Net.Maui.Controls;assembly=ZXing.Net.MAUI&quot; x:Class=&quot;MauiAppAgent.MasaBarcodeReader&quot; Title=&quot;MasaBarcodeReader&quot;&gt; &lt;VerticalStackLayout&gt; &lt;zxing:CameraBarcodeReaderView x:Name=&quot;BarcodeReader&quot; WidthRequest=&quot;300&quot; HeightRequest=&quot;300&quot; IsDetecting=&quot;true&quot; IsTorchOn=&quot;false&quot; BarcodesDetected=&quot;CameraBarcodeReaderView_BarcodesDetected&quot; /&gt; &lt;Button Padding=&quot;10&quot; Clicked=&quot;ReturnToBlazor_Clicked&quot; Text=&quot;返回&quot;&gt;&lt;/Button&gt; &lt;/VerticalStackLayout&gt;&lt;/ContentPage&gt; 参数说明如下： WidthRequest和HeightRequest：扫描窗口的长宽IsTorchOn：是否显示手电桶IsDetecting：是否显示正在检测的界面效果BarcodesDetected：识别到结果之后的回调方法 在代码文件BarcodeReader.xaml.cs中添加代码，实现扫描到结果之后关闭当前模态窗口。另外我们添加了一个按钮方便用户随时退出扫描页面。 1234567891011121314151617181920212223242526272829303132333435public partial class BarcodeReader : ContentPage{ public delegate void BarcodeDetected(string barcodeResult); public event BarcodeDetected OnBarcodeDetected; public MasaBarcodeReader() { InitializeComponent(); BarcodeReader.Options = new BarcodeReaderOptions { Formats = BarcodeFormats.All, AutoRotate = true, Multiple = true }; } private void CameraBarcodeReaderView_BarcodesDetected(object sender, BarcodeDetectionEventArgs e) { Dispatcher.Dispatch(() =&gt; { if (OnBarcodeDetected != null) { OnBarcodeDetected(e.Results[0].Value); CloseReader(); } }); } private void CloseReader() { Application.Current.MainPage.Navigation.PopModalAsync(true); } private void ReturnToBlazor_Clicked(object sender, EventArgs e) { CloseReader(); }} 构造函数中我们指定参数： BarcodeFormats.OneDimensiona 条码类型，可以是一维条形码（OneDimensiona，支持：Codabar、Code39、Code93、Code128、Ean8、Ean13、Itf、Rss14、RssExpanded、UpcA、UpcE）二维码（TwoDimensional，支持：Aztec 、DataMatrix 、Itf 、MaxiCode 、Pdf417 、QrCode 、UpcEanExtension 、Msi 、Plessey 、Imb）全部 （All，支持以上全部）AutoRotate = True 自动旋转Multiple = True 可以识别多个条码 CameraBarcodeReaderView_BarcodesDetected回调方法的BarcodeDetectionEventArgs 参数为扫描之后的结果，我们可以通过e.Results，获取扫描到的结果集（因为之前指定了Multiple = True） 这里为了演示我们只取默认的第一个结果作为参数传递给OnBarcodeDetected事件，最终将结果传递给BarcodeDetected。 这部分使用了MAUI提供的IDispatcher.Dispatch，IDispatcher提供核心事件消息调度程序，Dispatch方法的参数是一个Action，该方法将提供的Action从一个工作线程安排到 UI 线程运行，如果允许成功就返回true。 扫描成功后，需要自动关闭当前页面。用户也可以随时通过按钮点击关闭页面。关闭使用Application.Current.MainPage.Navigation.PopModalAsync(true) 该方法异步关闭最近以模态方式呈现的页面，并带有可选动画。唯一的参数就是是否显示动画效果。 4、我们在根目录添加一个MasaMauiBarcodeService.cs静态类 123456789101112131415using static Masa.Blazor.Maui.Plugin.QrCode.MasaBarcodeReader;namespace Masa.Blazor.Maui.Plugin.QrCode{ // All the code in this file is included in all platforms. public static partial class MasaMauiBarcodeService { public static void ReadBarcode(BarcodeDetected actionBarcodeDetected) { MasaBarcodeReader barcodeReaderMauiComponent = new MasaBarcodeReader(); barcodeReaderMauiComponent.OnBarcodeDetected += actionBarcodeDetected; Application.Current.MainPage.Navigation.PushModalAsync(barcodeReaderMauiComponent); } }} INavigation接口提供了Application.Current.MainPage.Navigation.PushModalAsync方法，以模态方式弹出一个窗体/页面，参数就是我们要弹出的窗体的对象也就是我们新建的MasaBarcodeReader.xaml页面，我们new一个MasaBarcodeReader 对象，给他的OnBarcodeDetected注册传递过来的actionBarcodeDetected 方法，条形码的扫描结果作为唯一的参数，通过PushModalAsync弹出我们的窗口。 使用我们新建一个MAUI Blazor的项目QrCodeSample作为演示，我们这里以iOS举例，扫码需要摄像头，所以在Info.plist添加需要的摄像头权限 12&lt;key&gt;NSCameraUsageDescription&lt;/key&gt;&lt;string&gt;This app uses barcode scanning to...&lt;/string&gt; Android 需要在AndroidManifest.xml添加摄像头权限，并在使用是动态获取用户授权（本文以iOS举例，Android不做具体实现） 1&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt; 在MauiProgram.cs添加UseBarcodeReader初始化方法（这个扩展方法是ZXing.Net.Maui提供的） 12345var builder = MauiApp.CreateBuilder(); builder .UseMauiApp&lt;App&gt;() .UseBarcodeReader() //初始化 .... 修改Index.razor页面进行测试 12345678910111213141516171819202122@page &quot;/&quot;@using Masa.Blazor.Maui.Plugin.QrCode&lt;div class=&quot;text-center&quot;&gt; &lt;button class=&quot;btn btn-warning&quot; @onclick=&quot;ReadBarcode&quot;&gt;Scan barcodes&lt;/button&gt;&lt;/div&gt;&lt;div class=&quot;mt-3&quot;&gt;Barcode: @_barcodeJustRead&lt;/div&gt;@code { private string _barcodeJustRead; private void ReadBarcode() { MasaMauiBarcodeService.ReadBarcode(BarcodeReaderMauiComponent_OnBarcodeDetected); } private void BarcodeReaderMauiComponent_OnBarcodeDetected(string barcodeResult) { _barcodeJustRead = barcodeResult; StateHasChanged(); }} 直接调用MasaMauiBarcodeService.ReadBarcode并传递自定义的处理方法BarcodeReaderMauiComponent_OnBarcodeDetected 我们看一下iOS的效果： 扫描效果还是很快很准确的，经过测试Android也可以正常使用。 注意：演示项目使用项目名称为QrCodeSample短名称，是为了避免iOS打包过程中报错，如果文件路径长度超过255，会报错某些文件无法找到的。 如果你对我们MASA感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们 WeChat：MasaStackTechOpsQQ：7424099","link":"/2022/10/20/MASA%20Blazor/MASA%20MAUI%20Plugin%20%EF%BC%88%E5%9B%9B%EF%BC%89%E6%9D%A1%E5%BD%A2%E7%A0%81%E3%80%81%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%89%AB%E6%8F%8F%E5%8A%9F%E8%83%BD/"},{"title":"MAUI + Masa Blazor 开发带自动更新功能的安卓App","text":"自动更新主要下面4个步骤 获取最新版本号 提示用户发现更新，等待用户确认更新 下载最新的apk包 安装apk包 下面从创建MAUI项目开始 1、创建Maui Blazor Server应用 2、安装Masa.Blazor，并添加引用 1dotnet add package Masa.Blazor 在 wwwroot/index.html 中引入资源文件 123456789&lt;!-- masa blazor css style --&gt; &lt;link href=&quot;https://masa-blazor-docs-dev.lonsid.cn/_content/Masa.Blazor/css/masa-blazor.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;link href=&quot;https://cdn.masastack.com/npm/@mdi/font@5.x/css/materialdesignicons.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;link href=&quot;https://cdn.masastack.com/npm/materialicons/materialicons.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;link href=&quot;https://cdn.masastack.com/npm/fontawesome/v5.0.13/css/all.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.masastack.com/stack/fonts/roboto/font-roboto.css&quot;&gt;&lt;!--js(should lay the end of file)--&gt; &lt;script src=&quot;_content/BlazorComponent/js/blazor-component.js&quot;&gt;&lt;/script&gt; 在 _Imports.razor 添加，对Masa Blazor 的全局引用 12@using Masa.Blazor@using BlazorComponent 在MauiProgram.cs中注入服务 1builder.Services.AddMasaBlazor(); 修改Shared / MainLayout.razor文件，设置MApp为根元素 12345678910111213141516@inherits LayoutComponentBase&lt;div class=&quot;page&quot;&gt; &lt;div class=&quot;sidebar&quot;&gt; &lt;NavMenu /&gt; &lt;/div&gt; &lt;main&gt; &lt;div class=&quot;top-row px-4&quot;&gt; &lt;a href=&quot;https://docs.microsoft.com/aspnet/&quot; target=&quot;_blank&quot;&gt;About&lt;/a&gt; &lt;/div&gt; &lt;article class=&quot;content px-4&quot;&gt; &lt;MApp&gt;@Body&lt;/MApp&gt; &lt;/article&gt; &lt;/main&gt;&lt;/div&gt; 项目属性中修改-已共享MAUI-中的应用程序ID及版本 3、开始编写代码 创建Service目录，添加IUpgradeService.cs接口 12345678910111213141516171819202122232425262728293031namespace MauiMasaBlazorDemo.Service{ public interface IUpgradeService { /// &lt;summary&gt; /// 检查更新 /// &lt;/summary&gt; /// &lt;param name=&quot;url&quot;&gt; /// 检查URL /// &lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; Task&lt;Dictionary&lt;string, string&gt;&gt; CheckUpdatesAsync(string url); /// &lt;summary&gt; /// 下载安装文件 /// &lt;/summary&gt; /// &lt;param name=&quot;url&quot;&gt; /// 下载URL /// &lt;/param&gt; /// &lt;param name=&quot;action&quot;&gt; /// 进度条处理方法 /// &lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; Task DownloadFileAsync(string url, Action&lt;long, long&gt; action); /// &lt;summary&gt; /// 安装APK的方法 /// &lt;/summary&gt; void InstallNewVersion(); }} ​这里需要使用到 FileProvider，在Android 7之后出于安全考虑不再支持content://URL 或file:///URL这种文件访问方式，可参考FileProvider | Android Developers ，我们先添加一下对应配置 在Platforms/Android/Resources下面新建xml文件夹，并添加provider_paths.xml文件 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;paths&gt; &lt;root-path name=&quot;root&quot; path=&quot;&quot; /&gt; &lt;files-path name=&quot;files&quot; path=&quot;&quot; /&gt; &lt;cache-path name=&quot;cache&quot; path=&quot;&quot; /&gt; &lt;external-path name=&quot;camera_photos&quot; path=&quot;&quot; /&gt; &lt;external-files-path name=&quot;external_file_path&quot; path=&quot;&quot; /&gt; &lt;external-cache-path name=&quot;external_cache_path&quot; path=&quot;&quot; /&gt; &lt;/paths&gt;&lt;/resources&gt; 修改Platforms / Android下面的AndroidManifest.xml文件，在application下添加provider，再添加一个安卓安装的权限REQUEST_INSTALL_PACKAGES 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/appicon&quot; android:roundIcon=&quot;@mipmap/appicon_round&quot; android:supportsRtl=&quot;true&quot;&gt; &lt;provider android:name=&quot;androidx.core.content.FileProvider&quot; android:authorities=&quot;com.masa.mauidemo.fileprovider&quot; android:exported=&quot;false&quot; android:grantUriPermissions=&quot;true&quot;&gt; &lt;meta-data android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot; android:resource=&quot;@xml/provider_paths&quot; /&gt; &lt;/provider&gt; &lt;/application&gt; &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.REQUEST_INSTALL_PACKAGES&quot; /&gt;&lt;/manifest&gt; ​在Platforms / Android下添加UpgradeService.cs 获取版本号可以通过MAUI提供的 VersionTracking，该类还有很多版本相关的功能，可参考 Version tracking - .NET MAUI | Microsoft Docs Intent 是一种运行时绑定（run-time binding）机制，Android的三个基本组件 Activity，Service和Broadcast Receiver 都是通过Intent机制激活的，有兴趣可参考Intent | Android Developers 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475using Android.Content;using Android.OS;using MauiMasaBlazorDemo.Service;namespace MauiMasaBlazorDemo{ public class UpgradeService : IUpgradeService { readonly HttpClient _client; public UpgradeService() { _client = new HttpClient(); } public async Task&lt;Dictionary&lt;string, string&gt;&gt; CheckUpdatesAsync(string url) { var result = new Dictionary&lt;string, string&gt;(); // 获取当前版本号 var currentVersion = VersionTracking.CurrentVersion; var latestVersion = await _client.GetStringAsync(url); result.Add(&quot;CurrentVersion&quot;, currentVersion); result.Add(&quot;LatestVersion&quot;, latestVersion); return result; } public void InstallNewVersion() { var file = $&quot;{FileSystem.AppDataDirectory}/{&quot;com.masa.mauidemo.apk&quot;}&quot;; var apkFile = new Java.IO.File(file); var intent = new Intent(Intent.ActionView); // 判断Android版本 if (Build.VERSION.SdkInt &gt;= BuildVersionCodes.N) { //给临时读取权限 intent.SetFlags(ActivityFlags.GrantReadUriPermission); var uri = FileProvider.GetUriForFile(Android.App.Application.Context, &quot;com.masa.mauidemo.fileprovider&quot;, apkFile); // 设置显式 MIME 数据类型 intent.SetDataAndType(uri, &quot;application/vnd.android.package-archive&quot;); } else { intent.SetDataAndType(Android.Net.Uri.FromFile(new Java.IO.File(file)), &quot;application/vnd.android.package-archive&quot;); } //指定以新任务的方式启动Activity intent.AddFlags(ActivityFlags.NewTask); //激活一个新的Activity Android.App.Application.Context.StartActivity(intent); } public async Task DownloadFileAsync(string url, Action&lt;long, long&gt; action) { var req = new HttpRequestMessage(new HttpMethod(&quot;GET&quot;), url); var response = _client.SendAsync(req, HttpCompletionOption.ResponseHeadersRead).Result; var allLength = response.Content.Headers.ContentLength; var stream = await response.Content.ReadAsStreamAsync(); var file = $&quot;{FileSystem.AppDataDirectory}/{&quot;com.masa.mauidemo.apk&quot;}&quot;; await using var fileStream = new FileStream(file, FileMode.Create); await using (stream) { var buffer = new byte[10240]; var readLength = 0; int length; while ((length = await stream.ReadAsync(buffer, 0, buffer.Length)) != 0) { readLength += length; action(readLength, allLength!.Value); // 写入到文件 fileStream.Write(buffer, 0, length); } } } }} 其中com.masa.mauidemo.apk 为安装文件apk的文件名称。 在MauiProgram.cs中添加注入，这里使用条件编译，在平台为Android时使用 123#if ANDROID builder.Services.AddSingleton&lt;IUpgradeService, UpgradeService&gt;();#endif 在Pages中新增Index.razor.cs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263using BlazorComponent;using Masa.Blazor;using MauiMasaBlazorDemo.Service;using Microsoft.AspNetCore.Components;namespace MauiMasaBlazorDemo.Pages{ public partial class Index { [Inject] public IPopupService PopupService { get; set; } [Inject] private IUpgradeService UpgradeService { get; set; } private int Ps { get; set; } private long TotalBytesToReceive { get; set; } private long BytesReceived { get; set; } private long _unReadMsgCnt = 0; private bool _updateDialog; /// &lt;summary&gt; /// 获取最新版本 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public async Task GetVersionNew() { var result = await UpgradeService.CheckUpdatesAsync($&quot;https://你的域名/update.txt?t={DateTime.Now.ToUniversalTime().Ticks}&quot;); if (result[&quot;CurrentVersion&quot;] != result[&quot;LatestVersion&quot;]) { var confirm = await PopupService.ConfirmAsync($&quot;检测到新版本，是否升级&quot;, &quot;版本号为：&quot; + result[&quot;LatestVersion&quot;]); if (confirm) { _updateDialog = true; await UpgradeService.DownloadFileAsync(&quot;https://你的域名/com.masa.mauidemo.apk&quot;, DownloadProgressChanged); UpgradeService.InstallNewVersion(); } } else { await PopupService.AlertAsync($&quot;当前版本已经是最新版,版本号为：&quot; + result[&quot;LatestVersion&quot;], AlertTypes.Success); } } private void DownloadProgressChanged(long readLength, long allLength) { InvokeAsync(() =&gt; { var c = (int)(readLength * 100 / allLength); if (c &gt; 0 &amp;&amp; c % 5 == 0) //刷新进度为每5%更新一次，过快的刷新会导致页面显示数值与实际不一致 { Ps = c; //下载完成百分比 BytesReceived = readLength / 1024; //当前已经下载的Kb TotalBytesToReceive = allLength / 1024; //文件总大小Kb StateHasChanged(); } }); } }} 修改Index.razor 添加按钮、确认对话框、进度条组件。Masa blazor是国内不多可以完美支持MAUI的blazor组件 1234567891011121314151617181920212223@page &quot;/&quot;&lt;MButton OnClick=&quot;GetVersionNew&quot;&gt; &lt;MLabel&gt;检查更新&lt;/MLabel&gt; &lt;MIcon&gt;mdi-home&lt;/MIcon&gt;&lt;/MButton&gt;&lt;div class=&quot;text-center&quot;&gt; &lt;MDialog @bind-Value=&quot;_updateDialog&quot; Width=&quot;500&quot;&gt; &lt;ChildContent&gt; &lt;MCard&gt; &lt;MCardTitle Class=&quot;text-h5 grey lighten-2&quot;&gt; 正在更新请稍后... &lt;/MCardTitle&gt; &lt;MCardText&gt; @BytesReceived KB/@TotalBytesToReceive KB &lt;MProgressLinear Value=&quot;@Ps&quot; Striped Height=&quot;15&quot; Color=&quot;light-blue&quot;&gt; &lt;strong&gt;@Ps %&lt;/strong&gt; &lt;/MProgressLinear&gt; &lt;/MCardText&gt; &lt;/MCard&gt; &lt;/ChildContent&gt; &lt;/MDialog&gt;&lt;/div&gt; 4、项目打包、签名、发布 项目属性中修改Android包格式为Apk 命令行生成一个安卓签名证书（部分手机没有证书签名不允许安装），过程中会提示输入证书密码，密码要记住，其他随意填 1keytool -genkey -v -keystore masa-maui-demo.keystore -alias key -keyalg RSA -keysize 2048 -validity 10000 项目属性，切换到-Android-包签名，勾选“APK签名”密钥存储选择刚刚生成的keystore文件，输入密钥“存储密码”和“别名密码”，这两个密码都填刚刚生成证书的密码，别名不设置的情况下，也需要输入别名密码，否则会在发布时提示“打包进程失败”。 解决方案配置中切换到Release,生成一下项目，然后右键项目名称-选择发布，发布0.0.1版本，发布过程会自动对apk进行签名 点右下角的打开文件夹，找到签名之后的apk文件，上传到阿里云OSS，同时再上传一个名为update.txt的文本文件，内容为“0.0.1”，这两个文件的地址就是GetVersionNew方法中的两个地址。 注意： 1、如果使用的下载apk的协议不是https，那么需要在AndroidManifest.xml文件 application 节点中添加 android:usesCleartextTraffic=”true” 2、如果是使用iis的话需要在MIEI中添加 MIME类型： application/vnd.android.package-archive，否则apk文件无法下载 这样我们的自动升级功能就开发完毕了，如果程序新加了功能我们我们需要做： 1、修改项目的版本号，例如修改“应用程序显示版本”为0.0.2，应用程序版本：2 2、重新发布apk 3、上传到阿里云OSS，修改update.txt文件为0.0.2 下面为真机演示效果 扫码进群MASA Blazor 欢迎你的加入","link":"/2022/08/23/MASA%20Blazor/MAUI%20+%20Masa%20Blazor%20%E5%BC%80%E5%8F%91%E5%B8%A6%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%89%E5%8D%93App/"},{"title":"MAUI + Masa Blazor 开发界面跟随系统主题切换的App","text":"1、安装Masa Blazor参考: MASA Blazor 安装 2、编写代码新建Service目录，并添加ThemeService.cs 该RequestedTheme 属性返回 AppTheme 枚举成员。 AppTheme 枚举定义下列成员： Unspecified，指示设备使用的是未指定的主题。Light，指示设备正在使用其浅色主题。Dark，指示设备正在使用其深色主题。设备上的系统主题可能会因各种原因而更改，具体取决于设备的配置方式。 当系统主题更改时，可以通过处理 Application.RequestedThemeChanged 事件来通知 .NET MAUI 应用。 1234567891011121314151617181920212223namespace MauiMasaBlazorDemo.Service{ public class ThemeService { /// &lt;summary&gt; /// 获取当前系统主题 /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; public AppTheme GetAppTheme() { return Application.Current!.RequestedTheme; } /// &lt;summary&gt; /// 系统主题切换 /// &lt;/summary&gt; /// &lt;param name=&quot;handler&quot;&gt;&lt;/param&gt; public void ThemeChanged(EventHandler&lt;AppThemeChangedEventArgs&gt; handler) { Application.Current!.RequestedThemeChanged += handler; } }} 在Platforms / Android /MainActivity.cs文件中 Activity的ConfigurationChanges需要包含ConfigChanges.UiMode，才能响应设备主题更改，使用 Visual Studio 项目模板创建的 .NET MAUI 应用会自动包含此标志。 12345678910111213[Activity(Theme = &quot;@style/Maui.SplashTheme&quot;, MainLauncher = true, //Activity需要处理的配置变化，需要包含在ConfigurationChanges中 ConfigurationChanges = ConfigChanges.ScreenSize | ConfigChanges.Orientation | ConfigChanges.UiMode | // 响应系统主题变化 ConfigChanges.ScreenLayout | ConfigChanges.SmallestScreenSize | ConfigChanges.Density)]public class MainActivity : MauiAppCompatActivity{} 在MauiProgram.cs 注入服务 1builder.Services.AddSingleton&lt;ThemeService&gt;(); 修改Shared 目录下MainLayout.razor文件，添加一个底部导航栏，设置Dark属性IsDark，Masa Blazor的组件都可以通过Dark属性来支持暗色主题。 12345678910111213141516171819202122232425@inherits LayoutComponentBase&lt;ErrorBoundary&gt; &lt;ChildContent&gt; &lt;MApp&gt; &lt;div style=&quot;height: calc(100vh - 56px); overflow-y: auto&quot;&gt; @Body &lt;/div&gt; &lt;MBottomNavigation Color=&quot;indigo&quot; Absolute @bind-Value=&quot;value&quot; Dark=&quot;IsDark&quot;&gt; &lt;MButton&gt; &lt;MLabel&gt;首页&lt;/MLabel&gt; &lt;MIcon&gt;mdi-home&lt;/MIcon&gt; &lt;/MButton&gt; &lt;MButton Class=&quot;mx-8&quot;&gt; &lt;MLabel&gt;工作台&lt;/MLabel&gt; &lt;MIcon&gt;mdi-message-outline&lt;/MIcon&gt; &lt;/MButton&gt; &lt;MButton&gt; &lt;MLabel&gt;我的&lt;/MLabel&gt; &lt;MIcon&gt;mdi-account-outline&lt;/MIcon&gt; &lt;/MButton&gt; &lt;/MBottomNavigation&gt; &lt;/MApp&gt; &lt;/ChildContent&gt;&lt;/ErrorBoundary&gt; 在Shared下新建MainLayout.razor.cs 1234567891011121314151617181920212223242526272829303132333435363738394041using BlazorComponent;using MauiMasaBlazorDemo.Service;using Microsoft.AspNetCore.Components;namespace MauiMasaBlazorDemo.Shared{ public partial class MainLayout { StringNumber value = 0; [Inject] //注入主题服务 private ThemeService ThemeService { get; set; } private bool IsDark { get; set; } /// &lt;summary&gt; /// 处理系统主题切换 /// &lt;/summary&gt; /// &lt;param name=&quot;sender&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;e&quot;&gt;&lt;/param&gt; private void HandlerAppThemeChanged(object sender, AppThemeChangedEventArgs e) { IsDark = e.RequestedTheme == AppTheme.Dark; InvokeAsync(StateHasChanged); } protected override async Task OnAfterRenderAsync(bool firstRender) { if (firstRender) { // 获取系统主题 var appTheme = ThemeService.GetAppTheme(); // 根据系统主题是否为Dark，为IsDark属性赋值 IsDark = appTheme == AppTheme.Dark; ThemeService.ThemeChanged(HandlerAppThemeChanged); StateHasChanged(); } await base.OnAfterRenderAsync(firstRender); } }} 切换效果如下： 我们已经实现了底部导航栏跟随系统主题切换的功能，那如何实现全局替换呢？ 在Masa Blazor中非常简单，只需要修改MainLayout.razor，将 Dark=”IsDark” 添加到MApp即可 123456789101112@inherits LayoutComponentBase&lt;ErrorBoundary&gt; &lt;ChildContent&gt; &lt;MApp Dark=&quot;IsDark&quot;&gt; //全局样式 &lt;div style=&quot;height: calc(100vh - 56px); overflow-y: auto&quot;&gt; @Body &lt;/div&gt;... &lt;/MApp&gt; &lt;/ChildContent&gt;&lt;/ErrorBoundary&gt; 我们再看一下效果 扫码进群，了解更多MASA Blazor 欢迎你的加入","link":"/2022/08/29/MASA%20Blazor/MAUI%20+%20Masa%20Blazor%20%E5%BC%80%E5%8F%91%E7%95%8C%E9%9D%A2%E8%B7%9F%E9%9A%8F%E7%B3%BB%E7%BB%9F%E4%B8%BB%E9%A2%98%E5%88%87%E6%8D%A2%E7%9A%84App/"},{"title":"怎么样的框架对于开发者是友好的？","text":"云原生离.NET开发到底有多远？ 云原生的概念由来不久，故事从“上云”开始，伴随dorker、k8s等技术的推出，以及CNCF与各大云厂商的共同加持，云原生逐渐被大家所熟知。云原生不依赖具体的云，不管公有云还是私有云。.NET6的诞生的时间点与容器技术非常的契合，.NET6现在已经完全支持CGroups v2，比Java对容器的支持更优秀。接下来.NET 7版本中Native AOT等新特性的推出，说明.NET一直大步的向云原生在改进，.NET现阶段在云原生领域已经领先于其他开发平台。 .NET适用于怎么样的场景？我们在谈论云原生、微服务的时候，经常会提到DevOps，CI/CD等概念，对于.NET来说现在已经支持的非常好。.NET也可以做machine learning，我们有tensorflow.net。在跨平台方面现在又有了MAUI这么优秀的项目可以供大家使用。还有在IoT的行业.NET也有非常多的解决方案。.NET可以做大型项目，也很适合中小型的项目。现在.NET是开源的，大家可以贡献自己的力量，像MASA技术团队开源的MASA Framework就是国内非常好的案例。 怎么样的框架对于开发者是友好的？好的框架有三个特点： 1） 无痛入门 好的框架应该是可以让开发者很快入门，上手成本低，而不是设置高门槛。比如在开发常规项目时，能够快速（比如几个小时）上手就能开展。需要深入时，可以非常平滑的深入，比如Spring Boot算是一个比较好的框架，在.NET Core出来后，.NET Core则更胜一筹。 2） 防呆设计 在开发者遇到问题时，好的框架能够让开发者自然而然根据直觉解决问题，可以不依赖文档。报错时有充足的信息告知开发者，给出相应的解决方案。winform与WPF的组件设计就非常符合防呆的设计，同样的Blazor相对之前的js框架在这方面有很多的优化。好的框架应该保持“KISS”（keep it simple and stupid）原则，简单又傻瓜化，并且有原则，不娇惯开发者。很多框架开始时“小而美”，越到后期需求不断增加，变得臃肿，变得“四不像”。 3） 可阶梯式深入 入手之后可以阶梯式的深入，比如3天学习一种用法，5天再深入一种用法。能够让开发者，在应对进阶场景时，快速的深入掌握。 4.NET已经是非常优秀的框架，为什么要二次封装.NET？ 大多时候，随着项目开发会有业务之外的重复性、非功能应用，或多或少都会进行一些封装。不同的场景需要不同的框架，现在.NET跨平台除了MAUI还有Uno Platform，还有其他框架支持，可以补充不同的场景需求，比如Uno就可以代替MAUI来支持Win7/Win8。.NET输出的是工具类库，二次封装.NET的框架就不能只是一个功能合集，必须要有自己的最佳实践和理念，但不限制开发者。 MASA Framework希望将我们的最佳实践输出给.NET开发者，帮助大家开启全新的现代应用开发体验！ 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们","link":"/2022/07/27/MASA%20Framework/%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%E6%A1%86%E6%9E%B6%E5%AF%B9%E4%BA%8E%E5%BC%80%E5%8F%91%E8%80%85%E6%98%AF%E5%8F%8B%E5%A5%BD%E7%9A%84/"},{"title":"使用MASA全家桶从零开始搭建IoT平台（一）环境准备","text":"前言本系列文章以IoT开发小白的角度，从零开始使用.Net为主要技术搭建一个简单的IoT平台，由于是入门系列，所有代码以围绕IoT基础业务场景为主，不会涉及DDD等设计思想。 架构图这里是我们整个IoT平台的架构图。 一、设备接入1、针对可以联网的设备，直接通过MQTT协议连接到我们的MQTT服务上（可以使用国内的阿里云、Onenet也可以使用开源EMQX实现）。绿色线框部分2、针对不能联网的设备，例如只能通过红外、短信、等其他非互联网技术通讯的，采用设备网关统一接管，这里主要涉及硬件相关内容我们不深入讨论。橙色线框部分 二、处理设备遥测数据我们通过MQTT Hub 订阅设备发布到MQTT的消息，并通过Dapr的Pub/Sub 方式发送给我们的IoT Core集群，我们可以通过MQTT 5.0协议中的共享订阅方式实现我们高可用集群。蓝色线框部分 三、设备控制直接在IoT Core中直接向MQTT发布控制指令。红色箭头所示 四、管理后台 管理后台我们采用Blazor搭建结合MASA Auth实现权限控制，红色线框部分，在IoT Core和IoT UI中间有一层Gateway，主要是方便我们在这一层Mock一些依赖的第三方业务接口，例如某个环节我需要从生产的MES系统获取某些信息才能继续下面的操作，我们可以在Gateway层去Mock这些接口和数据，方便我们测试。 五、数据存储业务数据我们存储到关系型数据库中，设备的消息数据（遥测数据），我们存储到时序库中，方便统计查找，和生成报表。 六、规则引擎针对不同类型的消息，我们可以在规则引擎中配置，使消息可以走不同的处理流程，例如接入的第三方系统设备，设备消息可能是加密的，我们就通过规则引擎将这种类型的消息发送到第三方系统解密之后再存储到数据库中，也可以在这里针对遥测数据进行分析和过滤，产生分级告警信息，发送到对应的处理系统或者干系人邮箱等。 环境准备1、安装EMQX1、运行以下命令获取 Docker 镜像： 1docker pull emqx/emqx:5.0.20 2、运行以下命令启动 Docker 容器 1docker run -d --name emqx -p 1883:1883 -p 8083:8083 -p 8084:8084 -p 8883:8883 -p 18083:18083 emqx/emqx:5.0.20 2、创建解决方案创建解决方案MASA.IoT，分别添加1、WebApi项目MASA.IoT.Core，对应架构图中IoT Core2、WebApi项目MASA.IoT.Hub，对应架构图中IoT Hub3、Blazor应用MASA.IoT.UI,对应架构图中的IoT.UI,也就是管理后台4、类库MASA.IoT.Common，存放一些静态的公共方法 3、安装Dapr开发环境 Dapr的全称是 “Distributed Application Runtime”，即 “分布式应用运行时”。是一个开源项目，由微软发起对Dapr不了解的同学可以学习，鬼老师的Dapr系列文章 使用Masa DaprStarter搭建开发环境安装DaprWindows安装Dapr的方式有很多，可以参考官方文档 https://docs.dapr.io/getting-started/install-dapr-cli/ 国内如果访问缓慢，建议直接下载msi文件安装 https://github.com/dapr/cli/releases 安装一路下一步即可。 安装Docker Desktop直接参考官方文档，这里不过多赘述 https://docs.docker.com/desktop/install/windows-install/ 初始化Dapr命令行执行 1dapr init 这里如果有类似网络错误，那就需要考虑魔法上网或者直接到dapr的github 上下载 dashboard_darwin_amd64.zip和daprd_windows_amd64.zip 两压缩包，执行dapr init 有了bin目录后 看准时机 把下载好的两个压缩包复制进去例如：C:\\Users\\Administrator\\.dapr 下的bin目录中，该目录下的压缩包会自动解压如果失败可以通过 dapr uninstall 命令卸载后重试。安装成功后通过 dapr -v 可以看到如下版本信息 在Docker Desktop中会创建三个容器 代码开发我们新建两个WebApi项目，模拟微服务之间通过dapr调用的场景。新建webapi项目PubDemo和SubDemo，并分别安装Dapr.Client和Masa.Contrib.Development.DaprStarter.AspNetCore后者方便我们在开发环境管理dapr的生命周期。我们在SubDemo项目中额外安装Dapr.AspNetCore。在PubDemo的Program.cs添加 1234if (builder.Environment.IsDevelopment()){ builder.Services.AddDaprStarter(builder.Configuration.GetSection(&quot;DaprOptions&quot;), false);} 并在配置文件中添加DaprOptions配置 12345678&quot;DaprOptions&quot;: { &quot;AppId&quot;: &quot;pub-demo-webapi&quot;, &quot;AppPort&quot;: 18009, &quot;AppIdSuffix&quot;: &quot;&quot;, &quot;DaprGrpcPort&quot;: 20333, &quot;DaprHttpPort&quot;: 20334, &quot;LogLevel&quot;: &quot;debug&quot;} 同样在SubDemo添加上述内容,注意端口号不要重复。 12345678&quot;DaprOptions&quot;: { &quot;AppId&quot;: &quot;sub-demo-webapi&quot;, &quot;AppPort&quot;: 19009, &quot;AppIdSuffix&quot;: &quot;&quot;, &quot;DaprGrpcPort&quot;: 20233, &quot;DaprHttpPort&quot;: 20234, &quot;LogLevel&quot;: &quot;debug&quot;} 这里需要注意在SubDemo项目中AppPort需要与launchSettings.json中应用的启动端口保持一致，这里都是19009，这个AppPort不是dapr的端口 而是需要与dapr sidecar通信的应用程序的端口地址。 123456789&quot;SubDemo&quot;: { &quot;commandName&quot;: &quot;Project&quot;, &quot;dotnetRunMessages&quot;: true, &quot;launchBrowser&quot;: true, &quot;launchUrl&quot;: &quot;swagger&quot;, &quot;applicationUrl&quot;: &quot;http://localhost:19009&quot;, &quot;environmentVariables&quot;: { &quot;ASPNETCORE_ENVIRONMENT&quot;: &quot;Development&quot; } 在SubDemo中还需要订阅相关的配置，完整代码如下 12345678910111213141516171819202122232425var builder = WebApplication.CreateBuilder(args);//注册 Dapr//将 AddDapr 扩展方法附加到 AddControllers 扩展方法会注册必要的服务以将 Dapr 集成到 MVC 管道中builder.Services.AddControllers().AddDapr();if (builder.Environment.IsDevelopment()){ builder.Services.AddDaprStarter(builder.Configuration.GetSection(&quot;DaprOptions&quot;), false);}builder.Services.AddEndpointsApiExplorer();builder.Services.AddSwaggerGen();var app = builder.Build();if (app.Environment.IsDevelopment()){ app.UseSwagger(); app.UseSwaggerUI();}app.UseHttpsRedirection();app.UseAuthorization();// 将 CloudEvents 中间件添加到 ASP.NET Core 中间件管道中app.UseCloudEvents();app.MapControllers();// 终结点路由配置中对 MapSubscribeHandler 的调用会将 Dapr 订阅终结点添加到应用程序。app.MapSubscribeHandler();app.Run(); 注意这里，app.MapSubscribeHandler();此终结点将响应 /dapr/subscribe 上的请求。 调用此终结点时，它将自动查找使用 Topic 属性修饰的所有 WebAPI 操作方法，并指示 Dapr 为这些方法创建订阅。我们在SubDemo新建一个WebApi接口来订阅Pub数据 1234567891011121314namespace SubDemo.Controllers{ [Route(&quot;api/[controller]&quot;)] [ApiController] public class SubTestController : ControllerBase { [Topic(&quot;pubsub&quot;, &quot;testdata&quot;)] [HttpPost(&quot;testdata&quot;)] public void TestData([FromBody] string testStrData) { Console.WriteLine(&quot;Subscriber received : &quot; + testStrData); } }} 这里Topic第一个参数为pubsub 组件名称，第二个参数为订阅的主题名称。默认的pubsub组件配置在C:\\Users\\Administrator.dapr\\components目录下。 123456789101112apiVersion: dapr.io/v1alpha1kind: Componentmetadata: name: pubsubspec: type: pubsub.redis version: v1 metadata: - name: redisHost value: localhost:6379 - name: redisPassword value: &quot;&quot; SubDemo编写完毕，接下来再PubDemo中添加一个测试Api 123456789101112131415161718192021using Dapr.Client;using Microsoft.AspNetCore.Mvc;namespace PubDemo.Controllers{ [Route(&quot;api/[controller]&quot;)] [ApiController] public class PubTestController : ControllerBase { private readonly Dapr.Client.DaprClient daprClient; public PubTestController() { daprClient = new DaprClientBuilder().Build(); } [HttpPost] public async Task PostTestDataAsync([FromBody] string testStrData) { await daprClient.PublishEventAsync(&quot;pubsub&quot;, &quot;testdata&quot;, testStrData); } }} 这里直接通过PublishEventAsync方法向testdata写入一条文本信息。 测试效果我们同时启动SubDemo和PubDemo两个项目。应用完全启动后，在命令行通过dapr list可以看到DaprStarter已经帮我们启动好了两个dapr实例。 在SubDemo的日志中，我们可以看到Dapr启动和订阅成功的日志 我们调用PubDemo中的测试Api，可以在SubDemo的日志看到消费成功的日志 也可以在redis中看到对应的记录我们打开zipkin还可以看到链路信息。这里仅作演示，后面我们会接入强大的MASA Stack全家桶，使用其中的TSC服务分析链路信息会更方便和直观。 还可以查看依赖关系，非常方便。 全文结束。以上就是今天要讲的内容，本文仅仅简单介绍了我们IoT后台的基本架构，下一章我们讲设备的生命周期 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们 WeChat：MasaStackTechOpsQQ：7424099","link":"/2023/04/21/MASA%20IoT/%E4%BD%BF%E7%94%A8MASA%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAIoT%E5%B9%B3%E5%8F%B0%EF%BC%88%E4%B8%80%EF%BC%89%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87/"},{"title":"使用MASA全家桶从零开始搭建IoT平台（三）管理设备的连接状态","text":"前言获取一个设备的在线和离线状态，是一个很关键的功能。我们对设备下发的控制指令，设备处于在线状态才能及时给我们反馈。这里的在线和离线，我们可以简单的理解为设备与MQTT的连接状态。 分析我们打电话的时候经常能听到：”您拨打的用户已关机“和”用户不在服务区或暂时无法接通“，这两种的区别是什么？ 1、当用户开机时，会自动向最近的移动基站注册，基站标记该用户为”attach”(在线)状态。2、当用户关机时，手机会发起datach流程，告知基站自己关机了，基站标记该用户为”detach”(离线)状态。这样再次拨打就可以节省寻呼资源，直接提示用户关机。3、当用户忽然进入无网络的环境，或者手机故障，导致来不及发起datach流程，基站还认为用户”在线”,当有人拨打用户号码时，基站测会对用户进行寻呼，但是超时得不到回应后，就会提示”不在服务区”或者”暂时无法接通” 的语音。 其实这个方案在IoT上也是可行的，我们可以让设备在线和离线的过程中向特定Topic发送状态消息，但是存在问题，我们需要一个单独的Broker去订阅这个Topic，但是这个单独的Broker很容易成为单点故障点。而且如果设备数量很大，这种意外离线的设备也很难及时发现，需要下发指令后等待设备响应超时才能发现。 方案1:遗嘱消息MQTT 遗嘱消息可以在客户端意外断线时将“遗嘱”优雅地发送给第三方订阅者，以实现离线通知、设备状态更新等业务。其中意外断线指客户端断开前未向服务器发送 DISCONNECT 消息，比如： 因网络故障或网络波动，设备在保持连接周期内未能通讯，连接被服务端关闭设备意外掉电设备尝试进行不被允许的操作而被服务端关闭连接，例如订阅自身权限以外的主题等遗嘱消息在 MQTT 客户端向服务器端 CONNECT 请求时设置，可选属性包括是否发送遗嘱消息 (Will Message)标志，和遗嘱消息主题 (Topic) 与内容(Payload) 以及 Properties。 值得一提的，遗嘱消息发布的时间可能会有延迟：通常意外断线时，服务器无法立即检测到断线行为，需要通过连接保活心跳机制并经过一定周期后才会触发；MQTT 5.0 提供的遗嘱延迟间隔（Will Delay Interval）属性也会影响发布时间。 演示遗嘱消息的使用我们使用A、B两台电脑使用MQTT X来演示。我们在A电脑的 MQTT X 中新建一个名为 Test 的连接，Host 修改为 修改为我们的MQTT地址（192.120.5.204），并输入账号密码，在 Advanced 部分选择 MQTT Version 为 5.0，并且将 Session Expiry Interval 设置为 10，确保会话不会在遗嘱消息发布前过期。然后在 Lass Will and Testament 部分将 Last-Will Topic 设置为 offline，Last-Will Payload 设置为 I’m offline，Will Delay Interval (s) 设置为 5。 完成以上设置后，我们点击右上角的 Connect 按钮以建立连接。 我们在B电脑的MQTTX中新建一个连接Sub，mqtt地址同样指向我们的mqtt服务器（192.120.5.204） 并订阅offline主题我们用任务管理器直接结束A电脑的MQTTX进程，这是连接会被直接断开，模拟了设备断电的场景，在5s之后，在B电脑的MQTTX订阅中收到了一条内容为 I‘m offline 的遗嘱消息。 实施流程1、设备遗嘱消息内容设置为offline，该遗嘱主题与一个普通发送状态的主题设定成同一个 {设备名称}/status。例如 284202304230001/status2、当设备连接时，向主题 {设备名称}/status 发送内容为 online 的Retained消息，其它客户端订阅主题 {设备名称}/status 的时候，将获取到 Retained 消息为 online。 保留消息(Retain )MQTT 服务端收到 Retain 标志为 1 的 PUBLISH 报文时，会将该报文视为保留消息，除了被正常转发以外， 保留消息会被存储在服务端，每个主题下只能存在一份保留消息，因此如果已经存在相同主题的保留消息，则该保留消息被替换。当客户端建立订阅时，如果服务端存在主题匹配的保留消息，则这些保留消息将被立即发送给该客户端。 借助保留消息，新的订阅者能够立即获取最近的状态，而不需要等待无法预期的时间，这在很多场景下是非常重要的。EMQX 默认开启保留消息的能力和服务，可以在 etc/emqx.conf 中修改 mqtt.retain_available 为 false 来关闭保留消息的能力， 这样客户端将被禁止发送 Retain 标志为 1 的 PUBLISH 报文，否则，客户端将会收到原因码为 0x9A（不支持保留消息）的 DISCONNECT 报文。保留消息的服务会存储和管理客户端发送的保留消息，并发送给相应的订阅者。 3、当客户端异常断开时，系统自动向主题 {设备名称}/status 发送内容为 offline 的消息，其它订阅了此主题的客户端会马上收到 offline 消息；如果遗嘱消息设置了 Will Retain，那么此时如果有新的订阅 A/status 主题的客户端上线，也将获取到内容为 offline 的遗嘱消息。 方案2:使用WebHook方案1需要设备主动设置遗嘱消息才能实现，那么有没有更简单的方式，直接通过设备与Mqtt的连接事件来获取连接状态呢。EMQX 设计了一套WebHook系统，可以通过这个自带的WebHook系统获取内部的事件并进行处理。WebHook的原理很简单，当设备与mqtt建立连接或者断开连接时，EMQX会把事件的信息通过我们的配置调用特定的URL上的接口，实现通知。使用WebHook还可以有限避免单点故障。所以本项目会采用WebHook的方式来实现对设备在线和离线的管理。 开启WebHook在数据集成 -&gt; 数据桥接 中创建一个Webhook名称设置为ConnectedEvent,URL 中填写我们的Webhook地址，也就是触发事件之后的调用接口地址，这里我们填： http://192.120.5.204:5000/api/Device/ConnectedEvent 请求方式为Post，其他内容保持默认不变这里注意URL可以通过${field}的方式拼接，请求体也可以自己指定，如果留空会原样转发消息，我们这里请求体留空设备在线和离线的事件转发的消息格式如下 1234567891011121314151617181920212223242526{ &quot;username&quot;: &quot;284202304230001&quot;, &quot;timestamp&quot;: 1682652598840, &quot;sockname&quot;: &quot;172.17.0.5:1883&quot;, &quot;receive_maximum&quot;: 32, &quot;proto_ver&quot;: 5, &quot;proto_name&quot;: &quot;MQTT&quot;, &quot;peername&quot;: &quot;172.17.0.1:48524&quot;, &quot;node&quot;: &quot;emqx@172.17.0.5&quot;, &quot;mountpoint&quot;: &quot;undefined&quot;, &quot;metadata&quot;: { &quot;rule_id&quot;: &quot;rule_3hsx&quot; }, &quot;keepalive&quot;: 60, &quot;is_bridge&quot;: false, &quot;expiry_interval&quot;: 10, &quot;event&quot;: &quot;client.connected&quot;, &quot;connected_at&quot;: 1682652598840, &quot;conn_props&quot;: { &quot;User-Property&quot;: {}, &quot;Session-Expiry-Interval&quot;: 10 }, &quot;clientid&quot;: &quot;mqttx_c4491df0&quot;, &quot;clean_start&quot;: false} 我们点击 创建 ，并继续点击 创建规则 我们在创建规则中指定新的规则名称 rule_client_connected,并在SQL编辑器复制以下内容 12345SELECT *FROM &quot;$events/client_connected&quot;, &quot;$events/client_disconnected&quot; 在右侧的事件中，我们可以看到所有可用的事件，我们选择了连接和断开两个事件，在这两个事件触发时会通过Webhook调用我们配置的接口，这样我们就能获取到设备的在线、离线状态了。我们点击 创建按钮 完成规则的创建我们可以看见我们创建好的规则点击规则ID，还可以看到统计数据 在FLows中还可以看到整个工作流程 演示Webhook我们使用MQTTX模拟一次设备连接和断开动作，可以在规则统计界面看到我们的操作已经被记录。 编写代码我们这里采用方案2。我们需要实现之前配置的ConnectedEvent接口 12345678910111213141516171819202122232425262728/// &lt;summary&gt;/// 连接事件请求/// &lt;/summary&gt;public class ConnectedEventRequest{ /// &lt;summary&gt; /// 设备名称 /// &lt;/summary&gt; public string Username { get; set; } /// &lt;summary&gt; /// 时间戳 /// &lt;/summary&gt; public long Timestamp { get; set; } /// &lt;summary&gt; /// 事件（连接/断开） /// &lt;/summary&gt; public string Event { get; set; } /// &lt;summary&gt; /// 连接时间（断开事件中为0） /// &lt;/summary&gt; public long Connected_at { get; set; } /// &lt;summary&gt; /// Client ID /// &lt;/summary&gt; public string Clientid { get; set; }} 1234567891011121314151617181920212223242526272829303132333435363738394041/// &lt;summary&gt;/// 更新设备在线状态/// &lt;/summary&gt;/// &lt;param name=&quot;deviceName&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;onlineStatus&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task UpdateDeviceOnlineStatusAsync(string deviceName, OnLineStates onlineStatus){ var device = await _ioTDbContext.IoTDeviceInfo.Include(o =&gt; o.IoTDeviceExtend).AsNoTracking() .FirstOrDefaultAsync(o =&gt; o.DeviceName == deviceName); if (device == null) { return; } else { if (device.IoTDeviceExtend == null) //扩展表为空 { device.IoTDeviceExtend = new IoTDeviceExtend { DeviceInfoId = device.Id, OnLineStates = (int)onlineStatus, }; _ioTDbContext.Attach(device.IoTDeviceExtend); _ioTDbContext.Entry(device.IoTDeviceExtend).State = EntityState.Added; _ioTDbContext.Entry(device.IoTDeviceExtend).Property(o =&gt; o.OnLineStates).IsModified = true; await _ioTDbContext.SaveChangesAsync(); } if (device.IoTDeviceExtend.OnLineStates != (int)onlineStatus) //在线状态不一致 { device.IoTDeviceExtend.OnLineStates = (int)onlineStatus; _ioTDbContext.Attach(device.IoTDeviceExtend); //防止更新其他字段 _ioTDbContext.Entry(device.IoTDeviceExtend).State = EntityState.Unchanged; _ioTDbContext.Entry(device.IoTDeviceExtend).Property(o =&gt; o.OnLineStates).IsModified = true; await _ioTDbContext.SaveChangesAsync(); } }} 我们根据Event中的内容来判断是 连接（client.connected）/断开(client.disconnected) 的事件 12345678910111213141516/// &lt;summary&gt;/// 连接、断开事件/// &lt;/summary&gt;/// &lt;param name=&quot;request&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;[HttpPost]public async Task ConnectedEventAsync([FromBody] ConnectedEventRequest request){ var onlineStatus = request.Event switch { &quot;client.connected&quot; =&gt; OnLineStates.OnLine, _ =&gt; OnLineStates.OffLine }; await _deviceHandler.UpdateDeviceOnlineStatusAsync(request.Username, onlineStatus);} 总结以上就是本文要讲的内容，我们可以通过MQTTX来测试我们的代码有效性。该方案还存在部分缺点，例如： 1、每次设备上下线会导致频繁的请求接口，在大量设备接入的场景中需要考虑接口性能。 2、由于网络等问题，Web调用顺序可能不能完全保证，也许离线会比在线事件更早处理，从而导致状态不一致。我们后面会尝试用其他方案来替代WebHook，尝试解决上述问题，在此之前我们都会继续使用WebHook进行功能演示。 完整代码在这里：https://github.com/sunday866/MASA.IoT-Training-Demos 如果你对我们的 MASA 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们 WeChat：MasaStackTechOpsQQ：7424099","link":"/2023/05/10/MASA%20IoT/%E4%BD%BF%E7%94%A8MASA%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAIoT%E5%B9%B3%E5%8F%B0%EF%BC%88%E4%B8%89%EF%BC%89%E7%AE%A1%E7%90%86%E8%AE%BE%E5%A4%87%E7%9A%84%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81/"},{"title":"使用MASA全家桶从零开始搭建IoT平台（二）设备注册","text":"前言我们不希望任何设备都可以接入我们的IoT平台，所以一个设备正常的接入流程是这样的， 1、上位机软件通过串口或其他方式读取设备的唯一标识码UUID。 2、上位机调用IoT后台接口，发送UUID和ProductID。 3、后台接口判断设备是否注册过，如果没有注册过，就根据ProductID并按照一定规律生成DeviceName和Password通过接口返回给上位机软件。 4、上位机软件通过串口将接口返回的数据写入设备。 一、设备注册流程这里主要涉及四个概念 1、UUID（设备唯一ID，一般为设备主控板编号） 2、ProductID（设备所属产品ID，在IoT后台定义） 3、DeviceName（设备在IoT平台或MQTT的名称，该名称大多与产品相关） 4、Password（设备连接MQTT的密码） 二、MQTT注册1.在EMQX中添加认证方式 选择Built-in Database方式，内置数据库进行密码认证 账号类型选择username，加密方式和加盐方式可以保持默认。 点击创建后可以在认证菜单中看到新建的认证方式，状态为：已连接。 我们点击用户管理-&gt;添加 可以手动创建用户 这里的场景我们是通过上位机调用IoT后端，IoT接口内部调用EMQX接口来实现自动创建用户的 2.创建Api Key调用接口需要认证，这里我们使用Api key的方式，我们在系统设置-&gt;API密钥中创建一个API密钥 Secret Key 只有创建的时候才会显示明文，我们需要记录下API Key 和 Secret Key 3.调用接口创建用户我们在浏览器打开EMQX 的RestAPI swagger http://localhost:18083/api-docs/index.html 我们可以通过这个接口来创建用户，这里的Authenticator ID 就是我们上面创建的内置数据库 Password Based的ID， 这个ID的获取通过下面的authentication方法获取 我们在认证中直接使用API Key 和 Secret Key,接口返回Id：password_based:built_in_database 调用authentication的Post接口，在 id字段输入：password_based:built_in_database，Request body中输入设备的user_id和password即可成功创建用户。 我们在Deshboard的界面中也可以看到刚刚创建的用户 三、测试设备连接我们使用MQTTX来模拟客户端设备通过mqtt协议连接到EMQX，新建连接，填写地址、端口、和刚刚通过Api创建用户名密码。 点击连接、发现设备已经可以正常连接mqtt了。 在Dashboard中也可以看到当前连接的客户端ID等信息。 四、编写代码在MASA.IoT.WebApi项目种添加DeviceController控制器并添加DeviceRegAsync方法用于设备注册，设备如果没有注册过（UUID 数据库不存在），那么会根据ProductCode按照规律生成设备名称，名称以该产品供应商编号开头，后跟时间和序号。然后向EMQX添加设备，并同时存储到数据库中。如果设备已经注册过，那么直接从数据库取出设备注册信息返回。代码编写相对简单，不过多赘述。 12345678910111213141516171819202122//DeviceControllernamespace MASA.IoT.WebApi.Controllers{ [Route(&quot;api/[controller]&quot;)] [ApiController] public class DeviceController : ControllerBase { private readonly IDeviceHandler _deviceHandler; public DeviceController(IDeviceHandler deviceHandler) { _deviceHandler = deviceHandler; } [HttpPost] public async Task&lt;DeviceRegResponse&gt; DeviceRegAsync(DeviceRegRequest request) { return await _deviceHandler.DeviceRegAsync(request); } }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141//DeviceHandlerusing MASA.IoT.WebApi.Contract;using MASA.IoT.WebApi.IHandler;using MASA.IoT.WebApi.Models.Models;using Microsoft.EntityFrameworkCore;namespace MASA.IoT.WebApi.Handler{ public class DeviceHandler : IDeviceHandler { private readonly MASAIoTContext _ioTDbContext; private readonly IMqttHandler _mqttHandler; public DeviceHandler(MASAIoTContext ioTDbContext, IMqttHandler mqttHandler) { _ioTDbContext = ioTDbContext; _mqttHandler = mqttHandler; } /// &lt;summary&gt; /// 注册设备 /// &lt;/summary&gt; /// &lt;param name=&quot;request&quot;&gt;&lt;/param&gt; /// &lt;returns&gt; /// 设备注册信息 /// &lt;/returns&gt; public async Task&lt;DeviceRegResponse&gt; DeviceRegAsync(DeviceRegRequest request) { var productInfo = await _ioTDbContext.IoTProductInfo.FirstOrDefaultAsync(o =&gt; o.ProductCode == request.ProductCode); if (productInfo == null) { return new DeviceRegResponse { Succeed = false, ErrMsg = &quot;ProductCode not found&quot; }; } var deviceRegInfo = await GetDeviceRegInfoAsync(request); if (deviceRegInfo != null) //已经注册过 { return deviceRegInfo; } else //没有注册过 { var deviceName = await GenerateDeviceNameAsync(productInfo.SupplyNo, request.ProductCode, request.UUID); var password = Guid.NewGuid().ToString(&quot;N&quot;); var addDeviceResponse = await _mqttHandler.DeviceRegAsync(deviceName, password); if (addDeviceResponse.user_id == deviceName) //注册成功 { deviceRegInfo = new DeviceRegResponse { DeviceName = deviceName, Password = password, Succeed = true, ErrMsg = string.Empty }; await _ioTDbContext.IoTDeviceInfo.AddAsync(new IoTDeviceInfo { Id = Guid.NewGuid(), DeviceName = deviceName, Password = password, ProductInfoId = productInfo.Id, }); await _ioTDbContext.SaveChangesAsync(); return deviceRegInfo; } return new DeviceRegResponse { Succeed = false, ErrMsg = addDeviceResponse.message }; } } /// &lt;summary&gt; /// 获取设备注册信息 /// &lt;/summary&gt; /// &lt;param name=&quot;request&quot;&gt;&lt;/param&gt; /// &lt;returns&gt; /// 设备已经注册返回设备注册信息，没有注册过返回null /// &lt;/returns&gt; private async Task&lt;DeviceRegResponse?&gt; GetDeviceRegInfoAsync(DeviceRegRequest request) { var deviceware = await _ioTDbContext.IoTDevicewares.FirstOrDefaultAsync(o =&gt; o.ProductCode == request.ProductCode &amp;&amp; o.UUID == request.UUID); if (deviceware == null) { return null; } else { var deviceInfo = await _ioTDbContext.IoTDeviceInfo.FirstAsync(o =&gt; o.DeviceName == deviceware.DeviceName); return new DeviceRegResponse { DeviceName = deviceInfo.DeviceName, Password = deviceInfo.Password, Succeed = true, ErrMsg = string.Empty }; } } /// &lt;summary&gt; /// 生成设备名称 /// &lt;/summary&gt; /// &lt;param name=&quot;supplyNo&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;productCode&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;uuid&quot;&gt;&lt;/param&gt; /// &lt;returns&gt; /// 设备Mqtt名称 /// &lt;/returns&gt; private async Task&lt;string&gt; GenerateDeviceNameAsync(string supplyNo, string productCode, string uuid) { var lastDeviceware = await _ioTDbContext.IoTDevicewares.Where(o =&gt; o.ProductCode == productCode).OrderByDescending(o =&gt; o.CreationTime).FirstOrDefaultAsync(); var newDeviceware = new IoTDevicewares { Id = Guid.NewGuid(), UUID = uuid, ProductCode = productCode, CreationTime = DateTime.Now }; if (lastDeviceware != null &amp;&amp; lastDeviceware.DeviceName.StartsWith(supplyNo + DateTime.Today.ToString(&quot;yyyyMMdd&quot;))) { newDeviceware.DeviceName = (long.Parse(lastDeviceware.DeviceName) + 1).ToString(); } else { newDeviceware.DeviceName = supplyNo + DateTime.Today.ToString(&quot;yyyyMMdd&quot;) + &quot;0001&quot;; } await _ioTDbContext.IoTDevicewares.AddAsync(newDeviceware); await _ioTDbContext.SaveChangesAsync(); return newDeviceware.DeviceName; } }} 这里生成设备名称用了一个简单的算法 12345678910111213141516171819202122232425262728293031323334353637// MqttHandlerusing Flurl.Http;using MASA.IoT.WebApi.Contract.Mqtt;using MASA.IoT.WebApi.IHandler;using Microsoft.Extensions.Options;using System.Net;namespace MASA.IoT.WebApi.Handler{ public class MqttHandler : IMqttHandler { private readonly AppSettings _appSettings; public MqttHandler(IOptions&lt;AppSettings&gt; settings) { _appSettings = settings.Value; } public async Task&lt;AddDeviceResponse&gt; DeviceRegAsync(string deviceName,string password) { var url = $&quot;{_appSettings.MqttSetting.Url}/api/v5/authentication/password_based:built_in_database/users&quot;; var response = await url.WithBasicAuth(_appSettings.MqttSetting.ApiKey, _appSettings.MqttSetting.SecretKey).AllowAnyHttpStatus().PostJsonAsync(new AddDeviceRequest { user_id = deviceName, password = password, } ); if (response.StatusCode is (int)HttpStatusCode.Created or (int)HttpStatusCode.BadRequest or (int)HttpStatusCode.NotFound) { return await response.GetJsonAsync&lt;AddDeviceResponse&gt;(); } else { throw new UserFriendlyException(await response.GetStringAsync()); } } }} 总结以上就是本文要讲的内容，本文介绍了通过账号密码的方式通过接口在EMQX中创建用户，并连接EMQX的过程，EMQX支持的认账方式还有很多，例如JWT认证方式可以授权一次性密码认证，可以控制认证的有效期，我们在后面的章节具体应用中会进行说明。 完整代码在这里：https://github.com/sunday866/MASA.IoT-Training-Demos 如果你对我们的 MASA 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们 WeChat：MasaStackTechOps QQ：7424099","link":"/2023/05/05/MASA%20IoT/%E4%BD%BF%E7%94%A8MASA%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BAIoT%E5%B9%B3%E5%8F%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E8%AE%BE%E5%A4%87%E6%B3%A8%E5%86%8C/"},{"title":"MASA Stack 1.0 圆桌讨论","text":"Q1： 全职开源的团队，你们的收入是什么？ 1.首先感谢我们的金主朗诗德公司，朗诗德是一家大型的净水器研发、生产、销售的公司，我们的产品也在朗诗德公司进行了大量的落地验证，再次感谢！ 2. 单一的收入来源并不足以支撑如此庞大的团队运作，我们也很荣幸找到了愿意为未来2.0 3.0买单的客户，这里我们希望更多的客户能够找我们做技术兜底，也希望开源生态越来越好，能够给我们带来更多的商业机会。 3. 我们1.0的产品是企业级可用，可以跟商用产品对标，所以大家也可以放心使用，刚刚实践篇中的项目都是实打实的大型落地项目 4. 我相信到最后开源项目都是社区驱动，而不是由数闪科技一家决策，这样才能让项目走得更远，更好！ Q2：现在商用产品这么多，为什么我要用你的开源产品呢？1.市面上的云端PaaS产品也好，云原生产品也好，并没有把.NET技术栈作为优先支持的对象，以某云为例，社区有位小伙伴经过了1个月的投诉，才让他们勉强支持.NET，非常的被动。而我们是优先考虑.NET技术体系，也兼容其他语言。 2. .NET现在对于云原生的支持已经走在世界前列，我们是一站式解决方案，对于刚刚是接触云原生的.NET技术体系的团队和公司来讲，云原生第一步如果选择MASA Stack，一定会比转型JAVA和GO的门槛要低很多。 3. 我们是企业级产品，已达到商用产品的水平，你不花钱或花少量的服务费，就能享受到商用软件的体验，何乐而不为呢？。 4. 如果选择我们，学习我们的开源项目源码，以及我们的产品设计理念，也能够帮助你快速提升到架构师和CTO技术级别。 Q3：你们跟ABP有什么区别单看MASA Framework，我们的能力是相似的，但整体设计上会有很大不同，我们参考的是Dapr的优秀设计。我们提供了完整的构建块标准接口，你能使用的功能都可以任意替换。 从我们的理解，ABP考虑了从单体架构进化到微服务架构的很多方法，但MASA是一个系列的产品，我们的定位是平台工程，致力于应用现代化解决方案，不只是开发框架，所以MASA Framework也不仅仅只是框架，更多的是解决方案中的关键一环而已。 Q4：对于希望转型云原生技术开发的.NET从业者有什么建议？第一步，就是敢于改变，跳出舒适圈，当然关注MASA技术团队，你已经比别人领先的一步，站在了巨人的肩膀上。 第二步，把一些基础知识点需要掌握，比如Dapr、K8s、DevOps等。 第三步，学会使用MASA的产品，并理解各板块的设计思路和能力，就算不使用我们的产品，学习我们的开源项目源码，以及我们的产品设计理念，也能够帮助你快速提升。 对于.NET的团队决策者，希望多学习现代的开发管理方法论，用云原生、微服务的能力升级传统架构。人、工具、方法都应该升级！如果大家希望有一套成体系的学习路径，欢迎关注我们MASA学院的课程！ Q5：2023年你们有什么线下活动吗？我们在22年做了一波问卷，收集上来非常多用户对于线下聚会的请求，我们在疫情放开的第一时间在杭州举办了一场线下沙龙，大家都非常捧场，很有意思，氛围特别好！ 2023年如果疫情好转，时间允许MASA Stack社区会根据用户要求，不定期开展线下聚会。届时我们会跟当地的.NET圈子的伙伴一同欢聚。开年第一场会在深圳跟大家见面！ Q6：提了很多Issue，但实现的较慢是什么原因？本身MASA技术团队的目标和精力都集中在MASA Stack的研发中，对于我们自身用不到的组件和功能，我们的优先级会较低。 当然，社区呼声很高的需求，我们也会优先处理，但由于时间精力的问题，会相对较慢。 值得高兴的是我们现阶段已经有很多位贡献者在帮助大家一起解决需求和问题，但仍需要更多的社区伙伴一起加入进来。我们也会尽力加速这些issue的解决！ Q7：你们怎么把团队搬去深圳了，怎么打算的？杭州的互联网氛围真的不错，.NET圈子也很活跃，我们的团队有部分还留在杭州。部分搬去深圳，我们是出于几个方面考虑： 1. 我们有30%用户集中在广东，服务对象集中在哪，我们就应该在哪。 2. 我们的首批商业客户中就有广东的，这样可以更好的服务我们的客户 3. 深圳的.NET技术人才也比较活跃，通过我们这次的招聘就能很明显的感受到，我们在深圳的团队一周内就集结完毕。 4. 深圳的创业氛围，商业机会相对来说会更多，能够帮助我们更好的发展。 这次是扩编，感谢投资人和客户们的认可，大家要对2.0更有信心和期待！ Q8：PPT介绍的功能什么时候能出，是否有文档或者视频文档已经有了，不过还在早期大纲阶段，比较简单，后期我们会慢慢完善它，也希望大家看到有什么问题都可以给我们提出来，或者在了解MASA Stack之后也可以帮助我们去完善文档内容。 视频的话，会在MASA学院里规划一些公开课，后续慢慢呈现给大家。 Q9：MASA的核心部分会一直开源免费吗？核心部分会一直开源。 扫码观看回放 如果你对我们的开源项目感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们","link":"/2023/02/15/MASA%20Stack/MASA%20Stack%201.0%20%E5%8F%91%E5%B8%83%E4%BC%9A%20%E2%80%94%E2%80%94%20%E7%A4%BE%E5%8C%BA%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94/"},{"title":"MASA Stack 1.0 发布会讲稿 —— 产品篇","text":"架构基于MASA的云原生技术架构 我们基于MASA去做了一个云原生技术架构，左下角的MASA Blazor主要是为我们去集成一个多端的UI能力，具体的使用场景将在实践篇为大家介绍——MASA Blazor如何去做多端的 接着就是集成非业务能力的MASA Framework，它主要是解决整个云原生架构中非业务性的问题 在这两个基础上，我们就可以去编写业务代码，业务代码完成后上传GitHub并发布到微服务的集群里面，而MASA Stack则是提供的平台管理能力 最右边的第三方系统管理是最关键的一部分，我们第三方系统调用是通过Dapr来管理，不难看到MASA Framework和Dapr有部分重叠，MASA Framework对Dapr进行二次封装，既可以让大家体验类似.Net原生操作，又可以作为适配层对Dapr进行替换 MASA Stack 平台架构 研发协作平台：更多的是去帮助大家解决在研发过程当中的一些协作类的问题 现代化应用治理平台：主要是帮助大家解决在应用层面的一些治理问题 可观测性平台：解决的是一些可观测问题，在平台工程里面，帮助大家去采集一些公共的日志、跟踪、指标、数据等等 数据开发平台：在MASA Stack 平台里是非常重要的一个环节，在1.0和2.0中的工作主要是作为3.0的基建，为3.0做铺垫 低代码开发平台：解决API侧的编排问题，更多的还是偏开发，针对IT开发者，并不傻瓜化 集成平台：解决系统集成间的一些问题 MASA Stack 功能架构 MASA Stack的功能架构底部的内容已经在前面介绍过，那我们来看下上面的内容 第一部分是研发管理部分，紧接着是现代化应用开发治理，这里面可以看到比如API网关、应用治理这些功能。第三部分数据开发与治理，是数据开发相关的内容。最后一个是可观测性，从功能结构上来说，MASA Stack1.0是其中的基础部分，但未来的3.0我们还会继续往里面补充内容，追加新的功能，并不局限于这四个版块 设计理念 能力：单体/分布式皆可 配置：可配置但约定优于配置 开放：可二开，可对接，也可以任意替换 标准：面向API和SDK编程 组合：通过对能力的组合，形成专属平台 应用现代化平台工程 01 价值 为了帮助开发人员、数据科学家和终端用户，并减少他们从事有价值工作的阻力，平台工程优化了开发者体验并加速数字交付 02 如何优化开发者体验 提供一套精心策划的工具、功能和流程。减少开发者的认知负担，并包含开发团队需要的一切，以最适合他们的工作流程呈现 支持的业务策略：创建安全的底座、加速数字化、吸引和留住人才 03 关键 先构建内部开发者门户，这是最成熟、最容易理解的平台类型。积累的经验可以扩展到其他平台，平台必须将安全性嵌入到工作流程。全面、自动化的安全性和合规性检查作为测试套件的一部分，不要指望商业的一站式解决方案，无论如何你都需要定制它 MASA Stack 全景 MASA Stack全景主要分为两大部分，MASA Stack每个版本是如何融合在一起的，它们之间的关系是什么？在这张图里都有清楚的展示 图中左边这一部分更贴近现代化应用部分，右边则是可观测性部分，在MASA Stack 1.0我们做的更多是一些基建类的东西，为后续版本打基础 2.0是图上白色部分，例如左下角的Workflow；3.0是图上不明显的灰色部分，比如左下角的Function，这些都是正在搭建的功能，会随着版本更新逐步实现 MASA Blazor MASA Blazor适用于PC端和移动端，包含两个库，第一个就是Blazor Component，主要提供了一个不包含样式的纯交互的组件库，第二个MASA Blazor 是基于Vuetify一个Material Design的组件库 MASA Framework Building Blocks &gt;&gt;接口&amp;能力&gt;&gt;提供非业务能力的接口，并提供组合多个能力形成新的能力的最佳实践 Contrib&gt;&gt;实现&gt;&gt;基于构建块的接口标准提供最佳实践，可被替换实现 Utils&gt;&gt;通用类库&gt;&gt;底层通用能力，可被用于业务和Contrib Templates&gt;&gt;模板&gt;&gt;用于创建项目 项目管理 MASA PM是一款底层基建项目管理产品，提供0-1初始化的部分内容。从最初的底层环境创建，部署和创建对应的集群。编辑环境与集群的组合关系，在所需求的环境集群上创建项目。 权限中心 MASA Auth是MASA Stack中最核心的功能之一，它统一负责了所有产品的权限、菜单、用户等。它包含了单点登录、用户管理、RBAC3、第三方平台接入、Ldap等企业级功能。除了可以用在企业内部管理系统，它还可以帮助管理C端用户。 配置中心 MASA DCC是MASA Stack1.0推出的分布式配置中心，在整个MASA Stack产品中担任所有系统以及部分全局综合配置的功能。 消息中心 MASA Stack 1.0 系统合集中底层支持消息发送的一款综合性产品，担任了全局消息系统支持多渠道的配置与消息发送规则的配置，并且可以配置多种消息模板以及特定用户组群。可以与关联产品Alert、TSC等对接，一站式解决故障问题触发与处理。 调度中心 Scheduler是MASA Stack 1.0推出的一款辅助性软件产品，主要负责处理应用程序任务执行的调度，以及自动重试等相关操作。在MASA Stack产品中，与MASA MC、MASA TSC、MASA Alert 3款产品结合，发挥最大的调度价值。当然Scheduler并不只是给MASA Stack产品使用，它同样可以为业务创造价值。 故障排查控制台 MASA TSC主要负责对MASA整个系统中的项目/应用进行监测来排查故障情况，其中包含从项目维度视角来查看监测的故障情况。以及溯源到具体的链路日志中去。除了可以监控整个MASA Stack的产品外，与PM进行组合使用，也可以将业务系统接入进来统一管理。 告警中心 MASA Alert是一款配合性产品，主要提供告警规则以及制定相关指标。它需要借助几个产品的基础功能组合来发挥它的价值，比如故障排查控制台作为监测数据源，调度中心作为调度周期控制，消息中心作为发送消息的渠道。MASA Stack会尽可能的复用基础功能，而不是重复性工作，所以单一部署它将失去意义，产品结合可以发挥告警中心的最大价值。 文档中心 MASA Stack 1.0 的文档将统一放在文档中心里，目前是比较早期的文档内容，我们会在1.0前继续完善它 优势 成本低：统一技术栈、统一交互、免费 不卡脖子：技术自主可控、云原生、开源 一站式：网页端、桌面端、微服务、云、移动端、IoT、ML、游戏 集成强：平台无边界、不限制开发语言、提供API和SDK 体系完善：应用交付、数据治理、安全智能、领域最佳实践 如何开始安装MASA Stack - Helm 介绍了那么多，那我们如何开始使用MASA Stack呢？ 这里我们分为两部分进行讲解，第一部分是MASA Stack的安装和接入 安装MASA Stack我们提供了Helm，首先需要准备K8s集群，有了集群后就可以创建namespace（这一步是可选项，也可以选择不创建），然后创建一个strong class（部署环境要求），部署Dapr搭建环境，使用MASA Stack Helm安装 代码也是比较简单的 1234helm repo add masastack https://github.com/masastack/helmhelm repo updatehelm search repo masastack --devel --versionshelm upgrade --install masastack masastack/masastack --version=xxx --namespace masastack --create-namespace --wait 虽然安装步骤简单，但实际上对K8s是要一些技术要求的，如果对K8s不是很熟悉的话，门槛相对来说还是比较的高的，之后我们也会录制MASA Stack相关的安装教程视频给大家 接入MASA Stack 如果你是.NET用户，我们提供了SDK，直接接入即可 如果你是其他语言用户，我们现阶段是没有SDK的，可以通过标准的API去对接 异构 如果你的项目是一个异构的，里面有不同的语言那怎么办呢？ 其实可以通过Dapr的方式去做，如果它提供了SDK，可以根据的原有的SDK去调整。如果没有，可以按照图上这个标准接口去实现对接 Windows 本地开发环境 接下来是基于MASA Framework的开发，首先在我们的Windows本地开发环境里面，绝大数步骤都是可选的，但如果你用的是Dapr，还是希望可以选择完整的流程去开发项目 安装WSL→安装Docker→安装Dapr，这里都是为了安装Dapr做准备 准备工作完成后就是创建项目，这一步可以使用我们的模板或者从零开始都没有问题，然后需要添加Masa.Contrib.Development.DaprStarter.AspNetCore 包， 最后一步就是在Program.cs 添加代码 123#if DEBUGbuilder.Services.AddDaprStarter();#endif 它可以帮你去管理Dapr的一个生命周期 基于模板创建新项目 基于模板创建新项目这一部分需要先安装MASA模板 dotnet new install Masa.Template 然后使用 MASA Framework Project 模板去创建项目，这过程中会有一些引导，去引导你去选择哪些选项（右图所示），按需勾选即可，这个阶段就是我们在自定义我们整个项目的结构，最后点击创建即完成 老项目对接 如果是老项目对接怎么办？这里有四种方式可选 用的比较多的是HTTP，可以用MASA Framework Caller或者HttpClient去对接 第二个是gRPC，这里需要注意的是，MASA Framework Caller （2.0）才能实现对gRPC的支持，现阶段使用的比较多的Grpc.Net.Client 最后一个就是Dapr，我们的Caller提供了Dapr的全集合 这三种方式里Caller都出现了，如果说你的项目比较复杂，可能用了不同的协议，还是更推荐Caller，因为Caller是我们的一个构建块，它是面对接口的方式去编程的，不管你对接哪一种方式，只需要调换Contrib包，书写方式没有特别大的区别 以上三种方式是大家比较常见的，最后一种方式是还在开发中的MASA Stack 2.0 集成平台，在2.0里，我们会做一个集成平台，它会帮大家去接管内外的应用，HTTP、gRPC、Dapr在我们的集成平台里面都可以快速接进来 扫码观看回放 如果你对我们的开源项目感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们 WeChat：MasaStackTechOps QQ：7424099","link":"/2023/02/07/MASA%20Stack/MASA%20Stack%201.0%20%E5%8F%91%E5%B8%83%E4%BC%9A%E8%AE%B2%E7%A8%BF%20%E2%80%94%E2%80%94%20%E4%BA%A7%E5%93%81%E7%AF%87/"},{"title":"MASA Stack 1.0 发布会讲稿——实践篇","text":"产品智能化 产品智能化的改造怎么做？ 我们以采用运营商网络场景的物联网架构举例，如图从左到右，在设备端我们研发了一款净水行业通用的物联网盒子，它带有各种传感器，如TDS、温度、流量、漏水检测、水压等传感器，通过移动的蜂窝网络实现数据通讯，并有一定的边缘计算能力，能实时收集数据并监测滤芯寿命，保障用户用水安全。之后数据通过OneNET网关对接公用云上的MASA IoT，也就是我们的 IoT中台，它负责打通前台小程序、设备，以及MES、CRM等后台业务系统，数据最终汇聚到数仓进行分析使用。 通过对家庭末端水质实时检测、用户用水习惯采集，不断增强公司产品研发及售后服务能力；通过对大数据分析，建立滤芯寿命算法模型，为每个用户量身优化滤芯寿命，大大提升了用户体验；通过用户画像，为后续精准营销，助力公司持续利润增长。 功能架构图 我们通过设备接入&gt;设备安装&gt;设备监控&gt;耗材购买&gt;订单履约，5个环节完成了整个业务闭环 物联网平台 设备接入主要通过我们的物联网平台，物联网平台有9大功能模块 首先设备主控板在PCBA工厂家生产时需要先注册到我们的IoT平台上，然后通过检测工装完成各种线路板的可靠性的检测，平台通过设备中心来管理所有注册到IoT平台的设备，告警中心配置针对不同设备和场景的分级告警，OTA模块可以管理设备软硬件版本，下发对设备进行强制OTA或者用户手动OTA等操作 产品中心可以管理各种产品类型和耗材，配置产品的使用者名单，产品各种固件的绑定关系等 通讯协议定义了设备与平台的通讯数据结构，可以解析不同产品的协议字段，平台可针对特定字段设置自定义的告警规则 SIM卡中心用来管理所有设备的物联网卡，监控流量消耗，监控账单余额等 模拟器就是用来协助软硬件开发，在设备没有开发出来之前进行测试和验证的工具。 业务端APP 设备安装是通过业务端App完成，技工使用设备安装模块提供的功能，通过蓝牙或者4G等方式给设备激活，更换滤芯等操作 代理商可以在设备管理模块下查看他名下销售的设备 租赁业务管理租赁的合同，管理账单和租赁的设备等。通过客户管理模块来管理终端用户，维护用户档案 商机报备可以登记潜在客户，并锁定客户 员工管理模块可以管理代理商的人力资源，包括技工，助理、业务员等角色 订单管理就是查看订单的状态，发货收货的跟踪，退换货等 产品中心就是查看我们所有在售产品的宣传资料，安装视频，产品手册等 客户端小程序 面向终端用户的应用，采用无需安装，开发成本更低的微信小程序实现 首先需要把设备和微信用户绑定，绑定之后就可以通过小程序的各种功能监控和控制自己的设备，如果是商用机的租赁用户，还可以通过租赁模块查看租赁合同，查看付款计划 当然还有通用的一键报修和设备维保的功能。针对云商城的微信小程序，还有目前比较流行的直播电商和社交电商运营模式支撑 运营后台 除了常规的完成耗材和商品的购买，完成出库发货，退货，售后等订单履约的行为之外，还有跟前端小程序配合的营销运营管理和直播管理，后台可以管理所有的会员，及财务管理功能。 MASA Stack 支撑场景 MC 消息推送 从业务场景来讲可以大体分两类： 1、 配合告警的推送 因为告警支持分级处理，一般级别的告警，比如滤芯寿命即将到期，会以短信或者消息推送的形式通知用户，流量卡流量即将耗尽，会通知具体后台业务人员，对于级别较高的告警，比如漏水告警，会触发人工处理，水质异常也会通知后台业务人员，可能还会通知客服人员联系客户，收到水质异常的告警，后台业务人员会通知负责该区域的技工上门维修检测等等 2、业务消息 例如工单任务分配，安装派工，维修派工等就具体通知到负责对应区域的技工。例如商用机代理商买断业务中，代理商在App进行安装派工，技工将会收到App的通知和站内信。对外租赁业务中，当租赁缴费日期距离预设规定时间范围内，自动给客户发送一条租赁缴费提醒短信等等 从开发角度来讲 MC推送支持邮件，短信，站内信，App的消息推送，在MC中配置好对应渠道的消息模板和标题，然后就可以在业务代码填充模板并直接触发推送，或者结合调度任务进行推送，和我们很熟悉的使用各大平台短信模板的流程是一样的 Scheduler任务调度 我们IoT平台的净水设备包含很多类型，对于净水器设备调度各种寿命的计算和处理任务非常复杂，因为不同种类的滤芯，不同种类的设备计算方式不同，对滤芯寿命到期或者剩余寿命过低的处理策略也不一样，租赁设备需要锁机，C端设备需要上午10点定时提醒用户。还有设备的强制OTA升级任务，以及各个业务系统数据的同步。在云商城项目中，还需要定时的去关闭超时的订单等业务。 定期风控检查场景，在云商城项目中，我们经常会搞一些促销的活动，有些用户会利用我们各种优惠福利的漏洞，或者利用系统Bug，来薅平台的羊毛，所以需要制定一系列的风控检查规则，定期去检查用户的数据，发现异常及时通知业务人员。在IoT项目中，我们也会制定针对于设备状态的风控检查，防止有人破解我们的设备，或者设备本身异常导致的频繁上下线，大量消耗流量等情况。 我们对于任务调度的需求是非常多的，所以我们需要一种很直观的方式观测各种任务的执行情况，防止遗漏一些关键任务的执行，或者重复执行了一些任务。传统的定时任务系统是缺乏调试和验证的手段，可能过了很长时间才发现某个任务并没有按照当时设计的周期或者顺序正确执行。 MASA Stack的 Scheduler可以灵活的配置各种运行策略比如任务的串行、并行，以及失败后的处理方式等，任务的成功失败我们不需要再看日志，各种任务的进度和状态都可以一目了然，可以很清楚的看到任务上一次执行的时间和结果以及下一次计划执行的时间。并且Scheduler支持集群的弹性扩展，如果资源压力过大，只需要添加节点就可以了。所以无论你采用哪种开发语言和架构，现在无需在代码中编写任务程序，在对应的业务场景中只需要通过HTTP或者Dapr的方式触发即可，而且也不用担心业务复杂问题，因为Scheduler支持上传代码或者压缩包的方式运行。 Auth权限 我们的业务后台页面采用MASA Blazor实现，可以很容易的通过添加标签的方式控制菜单或者按钮的权限，将需要权限保护的元素外层套上标签即可。对于WebApi场景只需在接口添加特性并配置对应的用户组或者角色即可。IoT后台各种角色权限的分配，只需要业务人员在Auth后台进行简单配置就可以，而且立即生效。Auth后台配置菜单权限来控制用户在业务平台中可见的菜单结构，也可以通过配置元素权限来控制菜单中的元素（按钮、组件、布局等），配置Api权限来保护业务服务的Api。Auth可以很灵活的配置页面的所有元素的权限控制。 Auth对用户的权限配置分为扩展权限、角色权限、团队权限，比如可以在生产环境可以配置我们开发团队只能看到系统的配置，但是无法看到具体的业务信息，如果业务人员有需要，可以临时赋予测试人员一些权限，协助排查问题。解决问题之后可以立即关掉相关权限。 Auth第三方平台目前内置支持Github、LDAP，可方便对接任何实现OAuth协议的第三方平台，支持热更新功能，配置第三方登录后无须重启服务。Auth还支持自定义登录注册页面配置功能，可以根据业务平台的需求来配置登录/注册窗口的元素，比如支持哪些第三方平台登录、增加身份证号、邮箱、昵称文本框等等，作为开发人员，只需要通过简单的配置就可以实现功能丰富的登录和注册页面。 DCC业务配置 1、****业务开关：比如滤芯到期强提醒的方案的开关 2、****系统配置：比如SIM卡流量判断阈值、指令下发重试次数，租赁到期需要提前几天短信通知用户等等。 DCC甚至可以灵活地切换环境配置，将开发环境一键切换到测试环境，切换到预发布环境，节省了重新部署的时间。之前写到配置文件的内容现在都可以配置到DCC中，并且这些配置是立即生效的。DCC还集成了审计功能，所有配置的修改都可以进行跟踪，我们可以查询某个关键配置是哪个人在什么时间修改的。 TSC应用故障排查 TSC我们现在社区还是预览版，但是我们内部已经开始尝试对接一下的业务场景，正在实施落地。之前用的是APM，现在正在尝试对接并迁移TSC的预览版。之前使用的场景经过验证都是可以迁移到TSC的。 大家可能都有类似排查问题的经历，有很多大公司尤其是外企，非常重视流程管理，这时候如果你的数据经过了多个业务系统，但又没有使用类似TSC的平台支撑，那么你要调查具体的问题就很麻烦，你需要向多个系统的项目经理提出申请，让他们安排具体的运维或者DBA甚至开发来协助你调查，如果涉及的数据存在涉密或者用户的个人信息，那么还需要涉及到产品和业务人员签字，那么如果这个问题的优先级不够高，一个问题调查一两周都是很常见的情况。下面举两个TSC的应用场景： ** 业务流程的跟踪：**我们的项目采用微服务架构，有服务节点多，业务流程长的特点，TSC可以高质量的记录每个请求和其上下文相关的内容，可以实时监控业务流程的进度和各个服务节点的性能，便于我们排查已知问题和发现未知问题。 举个例子，比如我们发现某个设备状态和后台记录的不一致，我们可以通过TSC查看这台设备的上报记录，并筛选出这条记录对应的整个链路的数据上下文，分析设备是否正确上报了状态，然后排查各个服务节点，通过查看各个节点的输入输出分析出各个节点是否正确的处理了设备的上报信息，从而排查出具体的问题所在。 再举个例子，我们发现后台设备状态同步很慢，我们可以在TSC中筛选出这条记录对应的整个链路的数据上下文，我们可以很直观的看到，在哪个业务节点或者服务节点停留的时间过长，从而分析出整个系统的性能问题。 日常巡检：我们可以通过定时在TSC中进行巡检，发现各个服务的一些异常信息并统计出发生次数和频率，从而发现一些未知问题和风险，及时进行修复和预防，比如我们登录的图形验证码或者短信发送接口是否被频繁调用，登录接口是否有存在被暴力破解的行为等等。另外我们还集成了Alert，一些致命错误和关键接口的错误会触发告警规则。 还有，对于面向终端用户页面，监控对应业务接口的响应时间是很关键的，响应过慢会导致用户使用体验降低，TSC中的应用性能指标Apdex（用户满意度指标）。我们可以通过设置相应的阈值，然后结合实际响应时间来定义应用的性能表现，然后我们就可以分析出用户对于不同页面的满意程度，如果Apdex值很高，代表就很满意，相反就是不满意或者完全不能接受，这样我们可以有针对性的调整和优化我们的业务。 Alert故障告警 Alert主要是结合TSC使用，我们在IoT项目中针对设备的告警类型比较多，大约有几十项，比如各级滤芯的寿命告警，进水纯水TDS值的告警，各种传感器故障告警，主控板、模组版、显示板通讯故障告警等等。这些告警我们会在Alert中做分级处理，而且Alert支持告警恢复，这样我们就可以直观的看到哪些设备发生了告警，并且哪些已经恢复了，哪些还没有恢复需要人工干预处理。Alert还有一个沉默周期的配置，比如设备缺水，设备会周期性上报缺水的状态，但是我们不需要关注每一条缺水的状态，只需关心缺水告警开始和恢复的时间，这时我们可以通过设置这个沉默周期，让设备在触发缺水告警之后的这个周期内不会再重复触发告警。而且可以通过沉默周期，我们可以对设备同一个告警设置多个告警级别。 .NET全场景开发 我想大家应该都用过IoT的产品，手机控制家里的空气净化器，控制空调。IoT的开发和我们前后端开发应用是差不多的，传统的网站开发是前端调用后端的接口，和设备通讯是通过MQTT，也就是消息队列，一个发布订阅的设计模式。 产品开发流程 我们产品的整个开发流程分7个阶段，首先会做产品定义，设备长什么样子，有什么功能，有什么按键，屏幕显示什么内容。然后是软件设计，设计我们的App、小程序、业务后台的UI，设计我们的业务流程，最终对设计进行评审定版。下一个阶段就是开发测试，按照原型和业务流程设计，开发我们的软件和业务后台，再测试。于此同时硬件也开发完成，就可以开始联调，联调不仅要和硬件进行联调，还要联调生产的整个流程，例如组装过程中会有很多测试的环节，这些环节我们都需要记录测试数据，以及对接一些返工或者维修的流程。比如某个传感器经过测试有问题，我们需要记录并更换这个传感器。联调测试完成后，就会进入小批试产环节，我们先试产少量设备，这些设备会分发给内部试用的用户收集各种意见，收集意见之后会进行改进，然后将改进后的设备再进行试产，分发到市场进行试用，市场试用阶段完成最终进入量产。 .NET应用场景 这里重点介绍一下.NET技术在其中4个阶段起到的作用。首先我们在产品定义的最后一步会确定通讯协议。通讯协议是我们日后开发的基础，通讯协议是与硬件设备约定的通讯数据接口，就相当于我们前后端分离开发中的WebApi接口定义，设备发送指令后通过字符串或者json的形式上报到MQTT，业务后台再异步的消费数据。有了通讯协议我们就可以在软件设计的最后一步进行快速POC验证，这个步骤主要验证一些新的流程和实现方案，我们可以不依赖嵌入式工程师，完全通过.NET技术，使用nanoFramework或者.NET IoT库通过esp32或者树莓派来快速验证我们的新流程或方案是否可行。关于传感器部分，国内外很多大神已经针对常用的传感器写好了很多现成的包可以调用。但是如果你的传感器没有现成的包，通过厂家的说明书、C、Python的示例，是很容易迁移到.NET平台的，大部分都是GPIO的操作，通过配置引脚和高低电平，获取传感器数据或者向传感器发送指令。 在开发测试阶段，我们使用.NET命令行开发一个通讯模拟器，模拟设备接入MQTT并上报各种数据的场景，为我们后面针对IoT设备功能的开发提供帮助，后面的硬件联调过程也可以参照模拟器和通讯协议对设备进行验证，就像前后端分离的开发中的mock模式，使嵌入式开发和平台层开发可以并行。 我们使用winform 技术开发工装注册工具，提供给PCBA厂家，通过串口将设备信息注册到我们的IoT平台和MQTT上。 开发阶段会有App和业务后台的开发，App我们使用的是MASA Blazor+Maui的方案，MASA技术团队开展了一个实验性项目，意在对微软MAUI的补充和扩展，比如蓝牙低功耗、条形码二维码识别、消息推送、以及Android的自动更新等。基本覆盖到了我们App开发常见的场景，而且验证安卓的PDA也可用，最低支持到Android 9，iOS最低支持到15.3。业务后台的开发使用的是MASA Blazor+MASA Framework+MASA Stack一站式解决方案，使用这套方案我们可以非常快速的搭建功能丰富的业务平台。 检测工装，也是一个Winform上位机程序，主要是对设备电控线路板进行可靠性和功能性进行半自动化检测，同时记录相关检测信息，为研发及品质人员追溯线路板故障问题提供数据支撑。比如验证显示屏和主控板通讯是否正常，蓝牙和4G模组是否可以正常工作等。 硬件联调阶段有个步骤叫生产现场改造，由于产品的工艺有所不同，需要对产线进行不同程度的改造，比如使用PDA对设备主控板和序列号进行绑定，通过蓝牙或者4G发送水检，气检指令，蓝牙改名，联网测试等等。所有的涉及到的系统对接和PDA程序都是.NET开发的。 试产环节的数据验证过程，主要是人工采集设备的数据，比如水温流速等，同PDA蓝牙读取的设备数据或者设备通过网络主动上报到IoT平台的数据进行比对，验证传感器和涉及到的算法的准确性。 扩展APP MAUI 这里列举了一些我们App实现的功能，我发现群里有不少从事IoT相关工作的朋友，之前是.NET 开发或者嵌入式开发，很少接触移动端开发。如果你懂一些.NET技术，使用MAUI可以帮助你快速上手App的开发，物联网常用的功能MASA技术团队帮我们实现了，并有对应的示例。有兴趣可以扫描下面的二维码关注MASA公众号，有相关的介绍文章。 案例展示 如图是我们部分系统界面展示，包含我们的IoT后台，用户端小程序，云商城小程序，和业务端App。这里其实还有一个PDA的程序因为涉及到工艺流程，所以不方便展示。我们已经通过MASA Stack为底座全场景使用.NET技术完成了IoT平台对数字化营销和智能制造的业务闭环。 如果您的企业是传统制造型企业那么可以参考我们的整套MASA Stack+.NET的解决方案，快速实现企业的数字化转型。如果您是开发人员，并且现在也有类似的业务需求，那么借助于MASA Stack+ .NET的能力，可以快速的搭建一套IoT或者电商平台。如果您是一位想上手App开发的爱好者或者从业人员，并且掌握一些.NET技术，与市面上其他的眼花缭乱混合开发技术相比，MASA Blazor + MAUI的方案技术门槛是最低，最容易实现。而且不要忘了您身后还有MASA技术团队的全力支持！ 扫码观看回放 如果你对我们的开源项目感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们","link":"/2023/02/09/MASA%20Stack/MASA%20Stack%201.0%20%E5%8F%91%E5%B8%83%E4%BC%9A%E8%AE%B2%E7%A8%BF%E2%80%94%E2%80%94%E5%AE%9E%E8%B7%B5%E7%AF%87/"},{"title":"MASA Stack 1.0 发布会讲稿——生态篇","text":"2022年运营回顾贡献者 首先感谢贡献者们为MASA Stack社区所作的积极贡献，这些贡献者给我们提出了很多宝贵的建议，更是积极的提交PR帮助我们一起让产品更健壮，更完善，还在各种场合推广我们的解决方案，非常给力，大家都是为爱发电，给你们点赞！ 社区章程发布 在MASA Stack 1.0发布之际，我们正式推出MASA Stack社区章程，这里我把章程的框架跟大家介绍一下。 首先，介绍一下社区会议，每月社区都会进行社区例会，邀请所有人参加，前期由MASA技术团队主导汇报本月每条产品线的进度以及回答社区内的问题，后期例会的议题由社区讨论决定。每月社区例会将在腾讯会议进行，例会时间会在群里提前发布会议接入链接，欢迎大家入群，我们现阶段有3个微信群分别对应各个产品，以及1个QQ大群。会议回放在B站MASA技术团队的“MASA Stack合集”中观看，我们的所有视频会发布到B站和Youtube平台上，我们所有的直播会在B站和微信视频号同时在线直播，欢迎大家关注。 接下来介绍一下社区角色的分工，MASA Stack社区设有项目管理委员会，开发者团队，用户以及终身荣誉制，社区角色采用晋升机制，可以从基础贡献者最终晋升为项目管理委员会成员。至于晋升路径，以及各个角色的获取要求，可以查看我们文档站点的社区板块，章程并不复杂，希望吸引更多的人加入成为社区的维护者、管理者，而不仅仅是由核心开发者维护社区。 值得关注的是，我们设立了终身荣誉制，这是一种荣誉和激励，希望让大家觉得是在为自己的个人影响力做开源。成为贡献者其实非常简单，可以向我们提出PR，或者积极布道，运营支持等等，只要是能帮上忙产生积极效果的都可以。后续我们会有详细的PR教程，帮助大家更好的为社区做贡献，让MASA Stack社区越来越活跃。 2022年社区运营 在过去的2022年，我们的社区运营从0到1，迈出了精彩的第一步。 我们参加或组织了5场技术峰会和沙龙，在会上做了关于.NET应用现代化相关的分享，得到了一致好评，其中包括分布式运行时开发者日（Dapr Day）、2022年开源年会温州分会场、2022年杭州.NET线下技术沙龙、开源云原生开发者日、Blazor Day in China。 从2022年5月开始我们坚持每月召开社区例会，为大家汇报项目的当月进度，累计8场。 我们分别针对MASA Blazor和MASA Framework开展了公开课，Blazor 8场，Framework 6场，其中Framework的开课B站单视频播放量已经破了5500，公开课累计播放量已经超22000次，在B站.NET相关视频中算是不错的成绩。 在文章内容方面，我们累计推出了20篇高质量的技术文章，我们还率先在国内推出了MAUI Blazor的系列文章，获得了非常多的好评和认可。 这么多的社区贡献，最终得到了开源中国、infoQ、掘金社区等媒体的认可，收获了3块奖牌。 获奖 我们获得了稀土掘金的年度人气技术团队，开源中国的优秀开源技术团队以及infoQ的开发者最向往的十大技术团队的荣誉，只有不断的得到社区和各界的认可，我们才有信心不断的前进，再次感谢大家！ GitHub 我们的项目全权托管在GitHub上，我们最先推出的是MASA Blazor项目，然后是MASA Framework。截至现在（2023.1.16），MASA Framework的Star数已经超300，MASA Blazor更是挺进500大关，希望在发布会之后大家帮忙给到更多的Star鼓励，谢谢大家一如既往的支持！ .NET生态面临的选择汇报完社区运营的成果后，我们来聊聊.NET生态。据不完全统计，50%的.NET开发者不在科技行业，90%的.NET应用程序在5年内仍然会继续服役。.NET技术在传统企业的占比很高，随着数字化转型的步伐逐步加快，传统企业的系统架构及人员技术能力都急迫需要升级，但现在市面上的解决方案大多为JAVA技术架构，对于企业来说，更换人员及接受JAVA技术架构的成本非常高。MASA Stack帮助企业.NET技术团队拥抱云原生，平滑的升级技术架构和知识体系，直接帮助企业降低数字化转型门槛，帮助企业快速试错，快速创新，应对不确定性。 天时 在趋势篇中我们聊到云原生技术演进，发现越来越多的新兴技术出现，开源软件崛起，数字化转型势在必行。而分布式应用运行时——Dapr的出现让很多中间件的能力落地到了K8s测，比如服务调用、状态管理、发布订阅、资源绑定、Actors、可观测性、密钥管理、配置管理、分布式锁等，让开发者的诉求跟基础设施之间的鸿沟越来越小，B端软件的变革即将到来，大家只有积极拥抱，才能享受到新技术带来的红利。 地利 第二，地利，我们正站在巨人的肩膀上，现阶段世界上只有.NET官方做到全面统一技术栈，而且信创可用，而这正是企业降本的核心诉求之一。.NET可以支撑全平台开发，比如云、网页应用、桌面应用、移动应用、游戏、IoT、AI和大数据开发，再加上微软在企业级应用上的积累，及拥有的生态及工具等，让.NET技术成为企业数字化转型的不二之选。 人和 数字化转型除了工具，人才也是成功的关键，所谓数字化人才，就是既懂业务又通技术的综合性人才。对于现有.NET开发者来讲，强行转JAVA技术栈，学习成本很高，还面临淘汰的风险，企业也同样面临失去这些人才的风险，很明显引进新人培养其积累业务经验，需要承担的时间成本也非常高。而选择MASA Stack可以让企业顺利升级到新一代的技术架构，企业IT团队管理方法论升级，团队技能升级，我们提供了微软系数字化人才成长的最优解。我们希望能引领560万.NET开发者拥抱互联网技术，让数字化转型的主力军具有新的战斗力。 Why MASA Stack？ 不管是.NET开发者，还是企业IT管理者，异或ISV软件供应商，MASA Stack都是现阶段的非常好的选择。首先，MASA Stack是统一.NET技术栈，并且开源免费的，企业可以用非常低的成本去快速验证新技术，快速验证新的商业创新。正因为MASA Stack是开源的，云原生架构的，技术是自主可控，所以不会被公有云厂商或者像某些商用软件“卡脖子”。新版本的.NET已经实现的技术栈大统一，可以完美支持跨平台、微服务、网页端、移动端、云、IoT、AI、游戏全场景的开发。 MASA Stack内嵌了Dapr分布式运行时，以及云原生的特性，不限制开发语言的接入，可以确保任何语言任何环境的运行。MASA Stack之所以称之为“平台工程”，他提供了IT价值交付全过程的支撑，包含如现代化应用交付、数据开发与治理、安全智能的领域最佳实践。 关于我们 正式介绍一下我们公司，我们数闪科技成立于2021年，是一家开源软件公司，MASA技术团队是全职的开源团队，我们的团队分布在深圳、杭州、温州。我们致力于打造开源产品MASA Stack，帮助企业降低数字化转型门槛，让变化更简单！ MASA 学院 2023年我们会成立MASA学院，志在帮助.NET开发者建立一套系统的学习成长路径，成为.NET开发者云原生第一步，只有迈出第一步，才有未来的每一步！我们有两个规划： 我们会推出两套公开课课程，《MASA Framework 公开课》较为基础，适合初级、中级开发者学习。在MASA Framework公开课结业的学员，可以参加我们《.NET应用现代化 公开课》进行进阶学习，这门课适合高级开发者与架构师。课程完全免费，不定时更新。 我们会推出官方的认证服务，只有通过认证考核才能拿到证书，证书有分级，分别从初级到架构师。认证考试，会根据报名人数，不定期举行，也是不收取任何费用的。我们希望MASA学院的认证证书是非常有含金量的。 公开课的课程体系是由MASA技术团队开发，任何人或组织不能以商业目的使用我们的内容对外授课，除非是得到“外聘讲师认证”，具体细节可联系我们详谈。 线下Meetup 2023年开始我们会不定期的在全国各地与大家见面，这里呼吁一下.NET生态的伙伴和各地区.NET社群，非常希望跟你们一起举办线下的聚会，请联系我们一起筹划，大家都参与进来，希望.NET生态因为我们更活跃！ 开源商业最后我们聊聊开源商业，大家都明白，无止境付出的开源项目长久不了，只有开源商业化才能让开源走得更远。欢迎咨询 借MASA Stack 1.0发布会之际，我们正式推出开源商业服务的板块： 第一块是开源项目服务年包，我们会根据产品范围和服务等级分别给予不同的档位价格，提供包括了部署安装服务、线上故障修复、服务巡检、专属服务沟通群、版本升级等等服务。 第二个板块，属于企业定制服务，如企业上云、架构升级、DevOps集成等基础架构类，及应用现代化重构、物联网、电商等项目外包服务类，两类都是以项目交付的形式，按人天报价。 第三个板块就是培训服务，MASA学院的公开课如果无法满足您的要求，希望能为团队定制课程，可以联系我们定制专属课程，组织线上/线下培训，根据按单次培训服务报价。 以上商业服务只是增值服务，不影响开源社区的正常运营。欢迎大家联系我们咨询报价，可以将需求发邮件到下方的报价邮箱，或直接拨打这个电话联系我，或加我微信，期待大家的咨询。 MASA Stack 2.0 MASA Stack 2.0将会是又一个让人期待的版本，他主要包含以下几个方面的工作，我们会在2.0版本对应用现代化进一步增强，组件方面我们会支持非常强大的表格操作，Auth和TSC将迎来比较大的更新。2.0的核心是服务编排和系统集成，会有很多让人兴奋的创新点。在数据开发的板块我们会开始做一些基建的服务，为3.0版本做准备。细节就不过多透露，大家敬请期待！ 扫码观看回放 如果你对我们的开源项目感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们 WeChat：MasaStackTechOps QQ：7424099","link":"/2023/02/13/MASA%20Stack/MASA%20Stack%201.0%20%E5%8F%91%E5%B8%83%E4%BC%9A%E8%AE%B2%E7%A8%BF%E2%80%94%E2%80%94%E7%94%9F%E6%80%81%E7%AF%87/"},{"title":"MASA Stack 1.0 发布会讲稿 —— 趋势篇","text":"世界技术圈在发生什么？云原生的演进 这里跟大家一起回顾一下张磊老师在云原生开发者日上关于“云原生技术演进”的分享。 有很多人会问，是不是云原生就等于K8s这些开源项目？其实今天出现的这些开源项目如K8s、docker、istio、dapr，是一些概念与方法论的一种技术实现，他们的背后就是云原生的理论体系，比如不可变的基础设施，高自动化、自愈自运维，语言和架构无关，高可扩展等等，而我们现在在实践的微服务、容器化、sidecar等就是为了支撑这些概念和方法论的技术和架构实现。这里有一条逻辑链路，就是当有一套概念和方法论之后，就会出现对应的技术和架构，我们在开源社区里就会出现相应的开源实现。 举个例子，容器化的技术架构对应的开源实现就有Docker、K8s这样的开源项目。用户端体现的这些开源项目，他其实实践的就是一套技术架构，而在这套技术架构背后的理论思想就是我们说的概念和方法论。整个云原生生态的体现就是这么一套方法论加架构加开源技术的这么一个集合，他的目的就是希望让云计算技术很好的去服务我们的开发者，目标就是帮助开发者降本增效，而云的一些特质就可以帮助我们去实现这一目标，比如云是无限弹性的，快速的资源交付，还可以按量付费等。 为了让云的这些特征能够最终帮助开发者降本增效，我们就需要这套逻辑链路来达成这个目标，这也是现阶段云原生技术角度来看一个非常自然的演进路线。 除了技术角度之外，我们还可以从时间维度来看云原生的演进过程。其实开发者希望得到的能力和基础设施平台能够提供的能力之间是有一道很大的鸿沟，开发者要的多，平台给得少，云计算实际上一直在解决这个问题。 时间线越往前，基础设施越弱，但开发者的诉求其实一直在增长，软件越写越复杂，彼此之间的鸿沟会越来越大，这时就会需要有人去填补这个鸿沟。在2010年以前，我相信大家都有听说过ESB这样的传统中间件的解决方案，中间件顾名思义就是填补在基础设施和开发者之间鸿沟的一套系统，它的能力非常强，可以满足开发者开发大型软件的需求。 随着时间推移，云计算技术越来越成熟，能力越来越丰富，有很多的需求可以用云的能力直接提供，所有陆续会出现一些比如PaaS这样的平台，其实就是云计算提供的中间件能力。到了2014之后，随着容器和K8s这样的技术出现，我们能在云计算平台拿到更多的能力，这是一种非常强大的平台层的抽象，我们前面讲过的不可变基础设施等都是通过容器、K8s技术实现的，之前需要花很多资源和精力搭建的中间件的能力，现在开发者可以非常容易的获取和实践，从此开发者的诉求和基础设施之间的鸿沟不断的在变小。 随着时间推移，2020年之后，云平台甚至已经开始提供中间件的核心能力，比如流量治理，他其实是service mesh的一个核心功能，而Dapr的出现，他进一步的把更多中间件能力，包括我们的微服务开发，服务发现、工作流、服务调用等，将这些能力下沉到了K8s，进一步的填补了鸿沟。从时间维度我们可以预测，未来云平台的能力会越来越强，甚至会超出开发者的诉求，云计算的关注点慢慢会从基础设施的这些运维时，越来越多的向开发时上移。 所以，不管是从技术角度还是时间角度来看，云原生的核心关注点正在发生变化，他已经渗透到了我们应用开发的各个环节，这就意味着会在某一个时刻，当云能力足够多的时候，必然要去关注我们开发者真正的开发过程。 开源软件的崛起软件正在吞噬世界，而开源正在吞噬软件，拥抱开源是这个时代的开发者应该具备的思维和能力，而拥抱开源能够让每一位开发者站在巨人的肩膀上，快速实现业务价值。而开源社区活跃着最优秀、最有活力的开发者，开源项目替代商用软件是必然趋势。而云原生技术催生的开源软件同时解决了企业卡脖子的问题，不被某一家云厂商所绑定。 我们发现，开源软件已经无孔不入，在原有的商用软件的各个领域都有开源软件的替代，开源软件正在崛起。所以我们毅然决然的选择开源我们的MASA Stack及MASA的系列产品。 为什么选择开源？ 1. 丰富.NET的开源生态，为.NET技术生态做出我们应有的贡献 2. 希望全世界的.NET开发者能够评审我们的代码，要求我们更开放、更规范、更严谨 3. 也希望.NET开发者能够参与进来，社区驱动，让产品更健壮，更有未来 战略技术趋势 下面我们来看一下权威机构Gartner发布的2023年战略技术趋势，以上10个技术趋势我们来关注一下数字免疫系统、应用可观测性、自适应AI和平台工程。 平台工程 不管是DevOps还是AIOps，各种Ops解决的就是将开发和运维达成有机运转的协作状态，是非常不错的方法论，但每个组织的落地却参差不齐，并不理想，导致开发人员需要直面苦涩的K8s等基础架构的知识体系。 平台工程是将复杂的基础设施能力通过平台的方式整合并形成自助式的开发者门户，目标是优化开发者体验并加快产品团队为客户创造价值的速度，让变化更简单。让运维人员更加关注开发人员的交付体验、应用服务的安全性和稳定性，开发人员不再感知基础设施，更加关注业务实现。平台工程是云原生技术运维时到开发时的产品形态。 Gartner预测，到2026年，80%的软件工程组织将建立平台团队，其中75%将包含开发者自助服务门户。自MASA Stack诞生以来，我们的产品定位就是企业级云原生技术底座，方便大家理解我们加上了一个PaaS的补充说明，Gartner在合适的时间给了我们一个合适的叫法，那就是平台工程，我们今天正式把MASA Stack定位为平台工程！ 可观测性 数字化时代的核心标志是数据驱动智能运营与商业创新，而拥有应用可观测性使企业够利用他们数据驱动决策来获得竞争优势。它能够在正确的时间提供正确数据，从而使企业在不确定的时代快速响应，让变化更简单。可观测性是MASA Stack的核心能力之一，我们在每个版本会持续迭代增强。 自适应AI 现阶段AI技术已经融入到企业生产作业的方方面面，如自然语言处理、机器视觉、流程自动化、智能推荐、分析预测等技术被应用到了像RPA数字员工、舆情监控、预测性维护、客户画像、商品推荐、机器人客服等场景。自适应AI是通过不断反复训练模型，在运行和开发环境中不断的使用新的数据进行学习，从而实现敏捷运营，快速自适应。更多的企业正在尝试用AI代替人去做重复性、低难度的工作，让员工去做更有创造力的工作，实现企业愿景，获得员工个人价值实现。 数字免疫系统 76%负责数字产品的团队需要对营收负责，企业需要一个能在实现高商业价值的同时，降低风险和提高客户满意度的方法，数字免疫系统能满足这一要求。 数字免疫系统通过结合数据驱动的可观测性、AI增强测试、混沌工程、自动修复，SRE，软件供应链安全等技术手段来提高系统的弹性和稳定性。 Gartner预测，到2025年，投资建设数字免疫系统的企业机构将能够减少多达80%的系统宕机时间，所减少的损失将直接转化为更高的收入。从某种层面上来说，平台工程、应用可观测性和自适应AI直接促成了数字免疫系统的实现。 应用现代化如何应对不确定性 国内外市场多重不确定性对企业持续增长提出考验，不确定性时代最大的特点是变化，客户需求在变、技术潮流在变，要想跟上变化，就需要拥有实时洞察和快速响应个性化、场景化、定制化需求的平台能力，打造可组装模块化应用的能力，用组装式的应用架构来呼应组装式的业务架构。 企业首先需要拥有一套无边界的平台底座，也就是数字底座，再将已有的信息化系统进行中台化、服务化重构，构建领域服务群，结合第三方生态及行业解决方案，最终打造统一的企业自有的数字化平台，这是数字化转型的必要路径。第一步需要攻克的难题，就是要将老旧的系统进行现代化升级，那么什么是应用现代化呢？ 应用现代化 IDC的2022中国云计算市场预测中，应用现代化位列第一，到2024年，大多数遗留应用将实现一定程度的现代化投资。55%的应用将使用云服务来扩展功能或替换低效代码。应用现代化也已成为一种共识，华为云认为应用现代化是以软件的敏捷交付为导向，实现贯穿基础设施到应用的认知重塑、架构升级和技术跃迁。 AWS认为应用现代化是采用最新技术构建，是开发组织加快创新、提高性能、安全性和可靠性，同时降低总拥有成本的解决方案。微软云认为应用现代化是通过使用具有松散耦合微服务、托管数据库、Al、DevOps 支持和内置监控的云原生架构来快速创新。 IBM认为应用现代化是对现有旧应用（单体、本地、瀑布式开发) 的平台基础架构、内部架构和功能进行现代化（云原生、微服务、DevOps） 改造的过程。应用现代化是数字化转型的必备能力，是应用开发的新范式。 关于我们 但很少有人关心.NET应用现代化的解决方案，我们MASA就此诞生了，MASA就是现代化应用和服务架构的意思，我们致力于用.NET技术赋能开发者，使用MASA Stack及MASA的系列开源解决方案帮助企业对老旧的应用进行现代化改造，帮助企业.NET技术团队拥抱云原生，平滑的升级技术架构和知识体系，直接帮助企业降低数字化转型门槛，帮助企业快速试错，快速创新，应对不确定性，让变化更简单！ 一站式解决方案 相比JAVA成熟的开源技术生态，.NET开源生态的现状确实有点不如人意，于是我们决定提供前端、后端、平台工程一站式的应用现代化解决方案。 MASA Blazor 在前端我们基于Material Design打造了企业级多端组件库MASA Blazor，使用.NET实现全栈解决方案，具有模块化、响应式和优秀的性能，搭配MAUI使用在移动端、桌面端都有极佳的效果。 MASA Framework 在后端我们提供了微服务开发框架MASA Framework，我们把他定义为.NET下一代微服务开发框架，内嵌分布式运行时——Dapr云原生最佳实践，能够快速实现分布式、微服务、DDD、SaaS等现代化应用开发。我们参考Dapr的优秀设计，提供了20项Building Blocks，还有MASA Stack各项能力的SDK支持。MASA Framework在2022年开办了公开课，已经出了6期的课程，有兴趣的朋友可以关注进来。 MASA Stack 最后就是我们的核心开源产品MASA Stack，MASA Stack是开源企业级开发者门户——平台工程，包含企业IT现代化应用开发交付的全部板块，如应用治理、服务编排与集成、数据开发与治理、可观测性、DevOps研发协作、AI智能等一站式解决方案。MASA Stack 1.0发版的同时，我们会一并发布MASA Blazor和MASA Framework的1.0版本。 愿景 我们再来聊聊我们的愿景，我们MASA希望在影响力上成为.NET技术生态中Spring的存在，成为.NET现代应用开发的标配。MASA Framework可以比肩Spring boot，MASA Stack 可以比肩Spring Cloud，但我们不仅仅只是比肩，我们还能超越！ MASA Stack 1.0 发布会——趋势篇.pdf扫码观看回放 如果你对我们的开源项目感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们","link":"/2023/02/06/MASA%20Stack/MASA%20Stack%201.0%20%E5%8F%91%E5%B8%83%E4%BC%9A%E8%AE%B2%E7%A8%BF%E2%80%94%E2%80%94%E8%B6%8B%E5%8A%BF%E7%AF%87/"},{"title":"MASA Stack 1.0 发布会圆满收官","text":"MASA Stack 1.0 发布会圆满收官，此次发布会得到了大家的热烈反响，视频号和B站两个平台观看人数突破千人，点赞超过两万 本次发布会分为五大部分——MASA Stack 1.0 趋势篇、产品篇、实践篇、生态篇、圆桌座谈 MASA Stack 1.0 趋势篇世界技术圈在发生什么？云原生的演进 跟大家一起回顾张磊老师在云原生开发者日上关于“云原生技术演进”的分享。介绍整个云原生生态的体现就是一套逻辑链路，就是当有一套概念和方法论之后，就会出现对应的技术和架构，我们在开源社区里就会出现相应的开源实现，他的目的就是希望让云计算技术很好的去服务我们的开发者，目标就是帮助开发者降本增效。 从时间维度来看，开发者希望得到的能力和基础设施平台能够提供的能力之间是有一道很大的鸿沟，随着云原生技术出现，开发者可以非常容易的获取和实践中间件能力，从此鸿沟不断的在变小。随着时间推移可以预测，未来云平台的能力会越来越强，甚至会超出开发者的诉求，云计算的关注点慢慢会从基础设施的这些运维时，越来越多的向开发时上移。 所以，不管是从技术角度还是时间角度来看，云原生的核心关注点正在发生变化，他已经渗透到了我们应用开发的各个环节，这就意味着会在某一个时刻，当云能力足够多的时候，必然要去关注我们开发者真正的开发过程。 开源软件的崛起 软件正在吞噬世界，而开源正在吞噬软件，拥抱开源是这个时代的开发者应该具备的思维和能力，而拥抱开源能够让每一位开发者站在巨人的肩膀上，快速实现业务价值。而开源社区活跃着最优秀、最有活力的开发者，开源项目替代商用软件是必然趋势。 我们发现，开源软件已经无孔不入，在原有的商用软件的各个领域都有开源软件的替代，开源软件正在崛起。所以我们毅然决然的选择开源我们的MASA Stack及MASA的系列产品。 战略技术趋势 下面我们来看一下权威机构Gartner发布的2023年战略技术趋势，以上10个技术趋势我们来关注一下数字免疫系统、应用可观测性、自适应AI和平台工程。 平台工程 平台工程是将复杂的基础设施能力通过平台的方式整合并形成自助式的开发者门户，目标是优化开发者体验并加快产品团队为客户创造价值的速度，让变化更简单。运维人员更加关注开发人员的交付体验、应用服务的安全性和稳定性，开发人员不再感知基础设施，更加关注业务实现。平台工程是云原生技术运维时到开发时的产品形态。Gartner在合适的时间给了我们一个合适的叫法，那就是平台工程，我们今天正式把MASA Stack定位为平台工程！ 可观测性 数字化时代的核心标志是数据驱动智能运营与商业创新，而拥有应用可观测性使企业够利用他们数据驱动决策来获得竞争优势。可观测性是MASA Stack的核心能力之一，我们在每个版本会持续迭代增强。 自适应AI 现阶段AI技术已经融入到企业生产作业的方方面面，通过自适应AI可以实现敏捷运营，快速自适应。更多的企业正在尝试用AI代替人去做重复性、低难度的工作，让员工去做更有创造力的工作，实现企业愿景，获得员工个人价值实现 数字免疫系统 Gartner预测，到2025年，投资建设数字免疫系统的企业机构将能够减少多达80%的系统宕机时间，所减少的损失将直接转化为更高的收入。从某种层面上来说，平台工程、应用可观测性和自适应AI直接促成了数字免疫系统的实现。 应用现代化如何应对不确定性 在不确定时代，数字化转型实在不行。企业首先需要拥有一套无边界的平台底座，也就是数字底座，再将已有的信息化系统进行中台化、服务化重构，构建领域服务群，结合第三方生态及行业解决方案，最终打造统一的企业自有的数字化平台，这是数字化转型的必要路径。 应用现代化 应用现代化已也成为一种共识，是数字化转型的必备能力，是应用开发的新范式。 关于我们 MASA就是现代化应用和服务架构的意思，我们致力于用.NET技术赋能开发者，使用MASA Stack及MASA的系列开源解决方案帮助企业对老旧的应用进行现代化改造，帮助企业.NET技术团队拥抱云原生，平滑的升级技术架构和知识体系，直接帮助企业降低数字化转型门槛，帮助企业快速试错，快速创新，应对不确定性，让变化更简单！ 一站式解决方案 相比JAVA成熟的开源技术生态，.NET开源生态的现状确实有点不如人意，于是我们决定提供前端、后端、平台工程一站式的应用现代化解决方案。 MASA Blazor 在前端我们基于Material Design打造了企业级多端组件库MASA Blazor，使用.NET实现全栈解决方案，具有模块化、响应式和优秀的性能，搭配MAUI使用在移动端、桌面端都有极佳的效果。 MASA Framework 在后端我们提供了微服务开发框架MASA Framework，我们把他定义为.NET下一代微服务开发框架，内嵌分布式运行时——Dapr云原生最佳实践，能够快速实现分布式、微服务、DDD、SaaS等现代化应用开发。我们参考Dapr的优秀设计，提供了20项Building Blocks，还有MASA Stack各项能力的SDK支持。MASA Framework在2022年开办了公开课，已经出了6期的课程，有兴趣的朋友可以关注进来。 MASA Stack 我们的核心开源产品MASA Stack，MASA Stack是开源企业级开发者门户——平台工程，包含企业IT现代化应用开发交付的全部板块，如应用治理、服务编排与集成、数据开发与治理、可观测性、DevOps研发协作、AI智能等一站式解决方案。 愿景 我们再来聊聊我们的愿景，我们MASA希望在影响力上成为.NET技术生态中Spring的存在，成为.NET现代应用开发的标配。MASA Framework可以比肩Spring boot，MASA Stack 可以比肩Spring Cloud，但我们不仅仅只是比肩，我们还能超越！ MASA Stack 1.0 产品篇架构MASA Stack 平台架构 研发协作平台：更多的是去帮助大家解决在研发过程当中的一些协作类的问题 现代化应用治理平台：主要是帮助大家解决在应用层面的一些治理问题 可观测性平台：解决的是一些可观测问题，在平台工程里面，帮助大家去采集一些公共的日志、跟踪、指标、数据等等 数据开发平台：在MASA Stack 平台里是非常重要的一个环节，在1.0和2.0中的工作主要是作为3.0的基建，为3.0做铺垫 低代码开发平台：解决API侧的编排问题，更多的还是偏开发，针对IT开发者，并不傻瓜化 集成平台：解决系统集成间的一些问题 ​ 设计理念 能力 单体/分布式皆可 配置 可配置但约定优于配置 开放 可二开，可对接，也可以任意替换 标准 面向API和SDK编程 组合 通过对能力的组合，形成专属平台 应用现代化平台工程 01 价值 为了帮助开发人员、数据科学家和终端用户，并减少他们从事有价值工作的阻力，平台工程优化了开发者体验并加速数字交付 02 如何优化开发者体验 提供一套精心策划的工具、功能和流程。减少开发者的认知负担，并包含开发团队需要的一切，以最适合他们的工作流程呈现 支持的业务策略：创建安全的底座、加速数字化、吸引和留住人才 03 关键 先构建内部开发者门户，这是最成熟、最容易理解的平台类型。积累的经验可以扩展到其他平台，平台必须将安全性嵌入到工作流程。全面、自动化的安全性和合规性检查作为测试套件的一部分，不要指望商业的一站式解决方案，无论如何你都需要定制它 MASA Stack 全景 这部分是MASA Stack 全景，主要分为两大部分，左边这一部分更贴近现代化应用部分，右边是可观测性部分，在MASA Stack 1.0我们做的更多是一些基建类的东西 MASA Blazor MASA Blazor适用于PC端和移动端，包含两个库，第一个就是Blazor Componet，主要提供了一个不包含样式的纯交互的组件库，第二个MASA Blazor 是基于Vertify一个Material Design的组件库 MASA Framework Building Blocks &gt;&gt;接口&amp;能力&gt;&gt;提供非业务能力的接口，并提供组合多个能力形成新的能力的最佳实践 Contrib&gt;&gt;实现&gt;&gt;基于构建块的接口标准提供最佳实践，可被替换实现 Utils&gt;&gt;通用类库&gt;&gt;底层通用能力，可被用于业务和Contrib Templates&gt;&gt;模板&gt;&gt;用于创建项目 项目管理 MASA PM是一款底层基建项目管理产品，提供0-1初始化的部分内容。从最初的底层环境创建，部署和创建对应的集群。编辑环境与集群的组合关系，在所需求的环境集群上创建项目。 权限中心 MASA Auth是MASA Stack中最核心的功能之一，它统一负责了所有产品的权限、菜单、用户等。它包含了单点登录、用户管理、RBAC3、第三方平台接入、Ldap等企业级功能。除了可以用在企业内部管理系统，它还可以帮助管理C端用户。 配置中心 MASA DCC是MASA Stack1.0推出的分布式配置中心，在整个MASA Stack产品中担任所有系统以及部分全局综合配置的功能。 消息中心 MASA Stack 1.0 系统合集中底层支持消息发送的一款综合性产品，担任了全局消息系统支持多渠道的配置与消息发送规则的配置，并且可以配置多种消息模板以及特定用户组群。可以与关联产品Alert、TSC等对接，一站式解决故障问题触发与处理。 调度中心 Scheduler是MASA Stack 1.0推出的一款辅助性软件产品，主要负责处理应用程序任务执行的调度，以及自动重试等相关操作。在MASA Stack产品中，与MASA MC、MASA TSC、MASA Alert 3款产品结合，发挥最大的调度价值。当然Scheduler并不只是给MASA Stack产品使用，它同样可以为业务创造价值。 ​ 故障排查控制台 MASA TSC主要负责对MASA整个系统中的项目/应用进行监测来排查故障情况，其中包含从项目维度视角来查看监测的故障情况。以及溯源到具体的链路日志中去。除了可以监控整个MASAS Stack的产品外，与PM进行组合使用，也可以将业务系统接入进来统一管理。 告警中心 MASA Alert是一款配合性产品，主要提供告警规则以及制定相关指标。它需要借助几个产品的基础功能组合来发挥它的价值，比如故障排查控制台作为监测数据源，调度中心作为调度周期控制，消息中心作为发送消息的渠道。MASA Stack会尽可能的复用基础功能，而不是重复性工作，所以单一部署它将失去意义，产品结合可以发挥告警中心的最大价值。 文档中心 MASA Stack 1.0 的文档将统一放在文档中心里，目前是比较早期的文档内容，我们会在1.0前继续完善它 权限中心 MASA Auth是MASA Stack中最核心的功能之一，它统一负责了所有产品的权限、菜单、用户等。它包含了单点登录、用户管理、RBAC3、第三方平台接入、Ldap等企业级功能。除了可以用在企业内部管理系统，它还可以帮助管理C端用户。 配置中心 MASA DCC是MASA Stack1.0推出的分布式配置中心，在整个MASA Stack产品中担任所有系统以及部分全局综合配置的功能。 消息中心 MASA Stack 1.0 系统合集中底层支持消息发送的一款综合性产品，担任了全局消息系统支持多渠道的配置与消息发送规则的配置，并且可以配置多种消息模板以及特定用户组群。可以与关联产品Alert、TSC等对接，一站式解决故障问题触发与处理。 优势 成本低：统一技术栈、统一交互、免费 不卡脖子：技术自主可控、云原生、开源 一站式：网页端、桌面端、微服务、云、移动端、IoT、ML、游戏 集成强：平台无边界、不限制开发语言、提供API和SDK 体系完善：应用交付、数据治理、安全智能、领域最佳实践 MASA Stack 1.0 实践篇产品智能化 介绍采用运营网络场景的物联网架构，以及物联网为企业数字化转型带来的价值。 功能架构图 我们通过设备接入&gt;设备安装&gt;设备监控&gt;耗材购买&gt;订单履约，5个环节完成了整个业务闭环 MASA Stack 支撑场景 从业务场景来讲可以大题分两类 配合告警的推送和业务消息推送 从开发角度来讲MC推送支持邮件，短信，站内信，App的消息推送，在MC中配置好对应渠道的消息模板和标题，然后就可以在业务代码填充模板并直接触发推送。 MASA Stack的Scheduler可以灵活的配置各种运行策略比如任务的串行、并行，以及失败后的处理方式等，解决很多定时任务场景。 Auth后台配置菜单权限来控制用户在业务平台中可见的菜单结构，也可以通过配置元素权限来控制菜单中的元素（按钮、组件、布局等），配置Api权限来保护业务服务的Api。 DCC主要分两个场景，业务开关和系统配置，之前写到配置文件的内容现在都可以配置到DCC中，并且这些配置是立即生效的。 TSC我们现在社区还是预览版，但是我们内部已经开始尝试对接一下的业务场景，正在实施落地。主要分两个场景：业务流程的跟踪和日常巡检，TSC中提供了一套的应用性能指标Apdex（用户满意度指标），来监控并改善用户满意度。 Alert主要是结合TSC使用，告警我们会在Alert中做分级处理，而且Alert支持告警恢复，而且可以通过沉默周期，我们可以对设备同一个告警设置多个告警级别。 .NET全场景开发 这里重点介绍一下.NET技术在其中4个阶段的不同场景的作用，我们分别使用了nanoframework、命令行、winform、MAUI + MASA Blazor、MASA全家桶进行不同场景下不同工具的开发。 扩展-APP MAUI 这里列举了一些我们App实现的功能，使用MAUI可以帮助你快速上手App的开发，物联网常用的功能MASA技术团队帮我们实现了。 案例展示 我们已经通过MASA Stack为底座全场景使用.NET技术完成了IoT平台对数字化营销和智能制造的业务闭环。 MASA Stack 1.0 生态篇2022年运营回顾贡献者 首先感谢贡献者们为MASA Stack社区所作的积极贡献，这些贡献者给我们提出了很多宝贵的建议，更是积极的提交PR帮助我们一起让产品更健壮，更完善，还在各种场合推广我们的解决方案，非常给力，大家都是为爱发电，给你们点赞！ 社区章程发布 在MASA Stack 1.0发布之际，我们正式推出MASA Stack社区章程，章程的框架分别关于社区会议、社区平台、社区角色等。成为贡献者其实非常简单，可以向我们提出PR，或者积极布道，运营支持等等，只要是能帮上忙产生积极效果的都可以。后续我们会有详细的PR教程，帮助大家更好的为社区做贡献，让MASA Stack社区越来越活跃。 2022年社区运营 在过去的2022年，我们的社区运营从0到1，迈出了精彩的第一步。 获奖 只有不断的得到社区和各界的认可，我们才有信心不断的前进，再次感谢大家！ GitHub 我们的项目全权托管在GitHub上，我们最先推出的是MASA Blazor项目，然后是MASA Framework。截至现在（2023.1.16），MASA Framework的Star数已经超300，MASA Blazor更是挺进500大关，希望在发布会之后大家帮忙给到更多的Star鼓励，谢谢大家一如既往的支持！ .NET生态面临的选择.NET技术在传统企业的占比很高，随着数字化转型的步伐逐步加快，传统企业的系统架构及人员技术能力都急迫需要升级，但现在市面上的解决方案大多为JAVA技术架构，对于企业来说，更换人员及接受JAVA技术架构的成本非常高。MASA Stack帮助企业.NET技术团队拥抱云原生，平滑的升级技术架构和知识体系，直接帮助企业降低数字化转型门槛，帮助企业快速试错，快速创新，应对不确定性。 天时 在趋势篇中我们聊到云原生技术演进，发现越来越多的新兴技术出现，开源软件崛起，数字化转型势在必行。Dapr的出现让很多中间件的能力落地到了K8s测，让开发者的诉求跟基础设施之间的鸿沟越来越小，B端软件的变革即将到来，大家只有积极拥抱，才能享受到新技术带来的红利。 地利 第二，地利，我们正站在巨人的肩膀上，现阶段世界上只有.NET官方做到全面统一技术栈，而且信创可用，而这正是企业降本的核心诉求之一。.NET可以支撑全平台开发，再加上微软在企业级应用上的积累，及拥有的生态及工具等，让.NET技术成为企业数字化转型的不二之选。 人和 数字化转型除了工具，人才也是成功的关键，选择MASA Stack可以让企业顺利升级到新一代的技术架构，企业IT团队管理方法论升级，团队技能升级，我们提供了微软系数字化人才成长的最优解。我们希望能引领560万.NET开发者拥抱互联网技术，让数字化转型的主力军具有新的战斗力。 Why MASA Stack？ 不管是.NET开发者，还是企业IT管理者，异或ISV软件供应商，MASA Stack都是现阶段的非常好的选择。MASA Stack之所以称之为“平台工程”，他提供了IT价值交付全过程的支撑，包含如现代化应用交付、数据开发与治理、安全智能的领域最佳实践。 关于我们 正式介绍一下我们公司，我们数闪科技成立于2021年，是一家开源软件公司，MASA技术团队是全职的开源团队，我们的团队分布在深圳、杭州、温州。我们致力于打造开源产品MASA Stack，帮助企业降低数字化转型门槛，让变化更简单！ MASA 学院 2023年我们会成立MASA学院，志在帮助.NET开发者建立一套系统的学习成长路径，成为.NET开发者云原生第一步，只有迈出第一步，才有未来的每一步！我们有两个规划： 我们会推出两套公开课课程，《MASA Framework 公开课》和《.NET应用现代化 公开课》，课程完全免费，不定时更新。 2. 我们会推出官方的认证服务，不定期举行，也是不收取任何费用的。 公开课的课程体系是由MASA技术团队开发，任何人或组织不能以商业目的使用我们的内容对外授课，除非是得到“外聘讲师认证”，具体细节可联系我们详谈。 线下Meetup 2023年开始我们会不定期的在全国各地与大家见面，这里呼吁一下.NET生态的伙伴和各地区.NET社群，非常希望跟你们一起举办线下的聚会，请联系我们一起筹划，大家都参与进来，希望.NET生态因为我们更活跃！ 开源商业 最后我们聊聊开源商业，大家都明白，无止境付出的开源项目长久不了，只有开源商业化才能让开源走得更远。欢迎咨询 借MASA Stack 1.0发布会之际，我们正式推出开源商业服务的板块： 第一块是开源项目服务年包，我们会根据产品范围和服务等级分别给予不同的档位价格，提供包括了部署安装服务、线上故障修复、服务巡检、专属服务沟通群、版本升级等等服务。 第二个板块，属于企业定制服务，如企业上云、架构升级、DevOps集成等基础架构类，及应用现代化重构、物联网、电商等项目外包服务类，两类都是以项目交付的形式，按人天报价。 第三个板块就是培训服务，MASA学院的公开课如果无法满足您的要求，希望能为团队定制课程，可以联系我们定制专属课程，组织线上/线下培训，根据按单次培训服务报价。 以上商业服务只是增值服务，不影响开源社区的正常运营。欢迎大家联系我们咨询报价！ MASA 2.0 MASA Stack 2.0将会是又一个让人兴奋的版本。细节就不过多透露，大家敬请期待！ MASA Stack 1.0 圆桌座谈Question 1.全职开源的团队，你们的收入是什么？ 2.现在商用产品这么多，为什么我要用你的开源产品呢？ 3.你们跟ABP有什么区别？ 4.对于希望转型云原生技术开发的.NET从业者有什么建议？ 5.2023年你们有什么线下活动吗？ 6.提了很多Issue，但实现的较慢是什么原因？ 7.你们怎么把团队搬去深圳了，怎么打算的？ 8.MASA Stack核心的部分会一直开源免费吗？ 9.物联网的部分有案例可以展示吗？ 扫码观看直播回放 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们 WeChat：MasaStackTechOpsQQ：7424099","link":"/2023/01/17/MASA%20Stack/MASA%20Stack%201.0%E5%8F%91%E5%B8%83%E4%BC%9A%20%E5%9C%86%E6%BB%A1%E6%94%B6%E5%AE%98/"},{"title":"MASA Stack 第三期社区例会","text":"MASA Blazor 0.5.0发版内容功能 Autocomplete：支持通过设置AutoSelectFirst参数开启自动选择第一项的功能，支持CacheItems参数，增强使用上下键的用户体验。 BottomNavigation：：一个替代侧边栏的新组件。它主要用于移动应用程序。 DragZone：一个基于Sorttable.js实现拖放功能的新组件。 **Form **: FluentValidation 支持依赖注入，验证消息支持i18n。 i18n&amp;nbsp: 组件库支持本地化，增强了文档的本地化。 Markdown：支持通过设置 Readonly 开启只读。 Modal：支持通过插槽设置自定义标题内容和关闭内容。 Select/Autocomplete：添加按下 Escape、Space、Home、End 键的逻辑。 破坏性更新 i18n：将使用 i18n 的 api 更改为services.AddMasaBlazor().AddI18nForServer(). CSS：合并masa-blazor.css和masa-extend-blazor.css到masa-blazor.min.css. 问题修复Breakpoint：修复 MasaBlazor.Breakpoint.Mobile首次不工作的问题。 DataTable：将FooterProps参数设置为强类型，如果FilterProps.ItemsPerPageOptions为空时不渲染页数选择元素。 DataTable：FixedRight 和 FixedHeader 同时使用时出现UI错误。 Dialog：复滚动如果对话框已显示并将要释放时。 Divider&amp;nbsp;:修复在某些场景分割线无法显示的问题，比如在Stepper中使用时。 ErrorHandler：修复生命周期中的异常仍然循环抛出的问题。 ListGroup：如果append-icon为空是不渲染该元素，prepend-icon同理。 Markdown：修复 Readonly 拼写错误，将token移动到请求头。 NavigationDrawer：修复当触发点击事件时 MiniVariant 设置为false的逻辑错误问题。 Select：增强用户使用体验，修复#391和#332。 Stepper：修复在处理时引用可能为空的问题。 Switch/Checkbox：修复 OnChange 事件无法触发的问题 #489。 TimelineItem：修复 Left 和 Value、AutoGrow、RowHeight参数值改变后，重新计算输入高度。 参数不起作用的问题。 Textarea：在Value、AutoGrow或 RowHeight 参数更改后重新计算输入高度。 TextField：修复对话框中 AutoFocus 不起作用。 Transition：修复LeaveAbolute 在 ToogleableTransftionElement 中不起作用。 Treeview：修复了Items更改时树节点没有更新的问题。重构i18n：重命名language为culture.文档 ExpansionPanels：使用新的过渡组件更新高级示例。 CSS：masa-extend-blazor.css不应包含文档的样式。 WebAssembly：最小化应用程序下载大小，更新首屏加载动画。 信息来源：https://github.com/BlazorComponent/MASA.Blazor/releases/tag/ 0.5.0MASA Framework 0.5.0内容发版修复 BugConfiguration.Dcc: 修复获取节点错误 #85 Storage.Aliyun: 修复基于配置文件的上传出错#87 EntityFramework: 修复使用MySql错误#108, 修复使用软删除过滤由于嵌套引用导致删除失败#144 EventBus: 修改错误提示信息地址#105 DomainEventBus: 修复聚合根添加领域事件执行顺序错误#120 #135 AutoComplete: 修复搜索匹配不到的问题#136 #139 #140 #149 Dispatcher: 修复部分事件(未继承ITranscation的事件)发布时，当Handler存在嵌套发布事件时，事务中间件会被多次执行的问题#146, 修复EventBus多次发布事件，第二次发布事件不会自动持久化#153 重命名 Masa.Contrib.BasicAbility.Dcc重命名为Masa.Contrib.Configuration.ConfigurationApi.Dcc#96 功能 IdGenerator: 添加 IdGenerator.SimpleGuid 和IdGenerator.SequentialGuid和 IdGenerator.Snowflake #76 #83 #87 #97 #115 #121 #124 Auth: 为团队和权限添加 sdk 方法 #77 #80, 更新 auth sdk 身份 #84 #98 #117 #141 添加 Auth.Contracts#104 #113 新增修改用户数据 #157 #160 #162 OIDC:添加Oidc.EntityFramework、Oidc.Cache.Storage#78 #93 #109 IdentityModel: 添加IdentityModel, 支持更新创建者、创建时间、修改人、修改时间等 #81 #103 #118 Data: 支持分布式锁#88 #131 Storage: 支持多Bucket#89, 添加 AddAliyunStorage 支持异步#123 Scheduler:添加调度器 Sdk #102 #107 #110 #142 #151 Dcc: 添加DCC Sdk#96 #161 Configuration.ConfigurationApi.Dcc: 扩展方法GetDefault,GetPublic #127 #138 Dispatcher: EventBus 支持自定义日志级别#134 #137 Mc: 添加Mc Sdk#112 #143 #163 EntityFramework: Support migration of local message table via IDesignTimeDbContextFactory#152 Tsc: 添加 tsc-sdk #125 重构 EntityFramework: 支持乐观并发#79, 重构MasaDbContextOptionsBuilde#122 IntegrationEvents.Dapr：重构DaprIntegrationEventBus #116 #150 #158 Autocomplete: 重构和优化用户体验#159 文档 Home: 修改首页文档 #87 Storage.Aliyun: 修复中文文档错误#87 Dispatcher: 添加Benchmark 数据#91#92 DistributedLock: 添加文档#95更新 IntegrationEvent 文档使用#132 Identity: 修改引用包文档错误#164 测试 Auth: 完善Auth单元测试#94 PM：修复单元测试#145 杂务 1.修改命名空间#82 2.更新Masa.Utils库版本 #90 #114 #133 #147 #154 #165 信息来源：Release 0.5.0 · masastack/MASA.Framework (github.com) MASA Stack 产品谍照1.登录页面 2.个人信息页面 3.全局导航 4.消息中心 5.渠道管理 6.配置中心 7.项目管理 社区近期问题解答MASA Framework Q1：MASA Framework在vs里安装项目的那几个模板是怎么安装上的? A:dotnet new –install Masa.Template Q2:目前Framework如何与前端I18n配合做多语言？ 目前0.5.0版本的框架暂不支持多语言，我们计划在0.6.0增加多语言支持 Q3:DomainEvent、DomainCommand、DomainQuery有什么区别？ 领域事件是DomainEvent，为了简化CQRS，就内置了DomainCommand、DomainQuery，它们是DomainEvent与Command、Query的组合 MASA Blazor Q1:Blazor如何实现登录，类似MVC后台程序的效果？ 参考：https://github.com/masalabs/MASA.Framework.Admin Q2:MASA Blazor App、MASABlzaor Pro Web、MASA Blazor Website、MASA Framework Project区别是什么？ MASA Blazor App：使用了MASA Blazor的模板 MASABlzaor Pro Web： 使用了MASA Blazor Pro的样式 MASA Blazor Website：使用了文档站点的样式 MASA Framework Project：创建Framework项目 Q3:目前Tooltip组件写法太复杂，会影响代码的结构和阅读体验，能否可以优化一下，例如在 MButton上原生支持 Tooltip 属性。 开发组件库应该保持单一组件最小的功能，或者说单一职责，Tooltip现在的设计是可以包裹任何元素，无论该元素是行内元素还是块元素，从技术上来说Tooltip要知道目标元素，就需要给目标元素添加一个唯一的自定义属性，你可以通过查看html看到有个_activator_ 开头的属性。然后给该元素添加click和mouseenter事件来实现点击触发和Hover触发的效果。具体请移步https://github.com/BlazorComponent/MASA.Blazor/issues/595。 其他 Q1:Masa以后支持工作流吗？是免费的吗？ 2.0会增加工作流支持，是免费的 开源地址https://github.com/BlazorComponent/MASA.Blazor https://github.com/masastack/MASA.Framework 如果你对我们的开源项目感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们","link":"/2022/08/05/MASA%20Stack/%E7%AC%AC%E4%B8%89%E6%9C%9F%E7%A4%BE%E5%8C%BA%E4%BE%8B%E4%BC%9A/"},{"title":"MASA Stack 第四期社区例会","text":"MASA Stack 产品讲解​ MASA PM（基建与项管）MASA Auth（权限认证中心）MASA DCC (配置中心)MASA MC（消息中心）MASA Scheduler （调度中心）MASA Alert （告警中心，开发中）MASA TSC（故障排查控制台，开发中） PM​ 1搭建环境/集群 IT项目标准化建设、保障信息安全、数据隔离、风险容灾 适用两地三中心的企业级场景 2项目与应用程序 可创建和管理多个项目，项目包含多个应用程序。 可复用，降低成本提高效率 3项目团队 可用项目团队来管理多个项目 灵活组织结构，扁平化项目管理 MASA AUTH​ MASA Auth是一款企业底层多功能且实用性极高的软件系统，用于ToB、ToC以及企业级的多用户综合管理配置平台。 权限管理 1全局系统权限分配 集中处理企业级多系统权限配置与修改 2授权认证 SSO单点登录，可使用一次登录多系统互通。随时切换企业内多系统。 3角色权限 以国际通用设计规范RBAC设计模型进行设计，提供多对多的角色权限控制。 用户管理 4企业员工、企业用户、第三方用户 统一用户管理中心，提供域账号登录同步等。 5组织架构 无限级部门组织结构，应对企业级多部门权限管理以及跨层级的部门管理 6全局控制 企业级全局导航，个人中心，多系统登录相关配置 MASA DCC​ 提供企业级别综合配置中心，配置系统底层相关参数以及半业务所需参数。 1配置对象 可以创建项目、应用程序等维度的对象并配置其对应的参数和备份其参数 2发布配置 可以切换不同对象进行不同版本的配置发布提高IT运维整体效率，大幅度缩减人工时长的成本 3克隆配置 提供包括复制在内的克隆功能，再切换不同版本系统需求时可以模拟近似配置进行克隆 4综合配置 包含系统标签，综合分析指标，业务指标等系统相关联的综合配置项 MASA MC​ 消息中心是企业级软件应用不可缺少的一个部分，涉及内容多且广泛。属于企业底层必备软件 1消息渠道 目前已经支持短信渠道、邮箱渠道、系统站内信息渠道；可衍射其他外部消息发布渠道。 2消息模板 支持多消息渠道创建不同的消息版本 3消息发送规则 系统级定时、触发、自动生成等消息规则配置。适用普通企业级常规消息发送范围 4消息发送对象管理 包含发送消息对象的记录，分组，以及群发消息等 SCHEDULER​ 主要处理各系统间分布式任务处理，多任务情况下进行合理分配对应资源。可以设置定时任务，自动任务，任务失败时的响应策略，在目前系统中来看属于底层功能型产品，可以搭他系统发挥效果。 定时任务 自动触发任务 MASA Framewrok 更新内容重命名 Ef - &gt; EFCore EntityFrameworkCore -&gt; EFCore Oidc -&gt; OpenIdConnect BasicAbility -&gt; StackSdks Identity.IdentityModel-&gt; Authentication.Identity 文档 修复Exception文档 调整首页文档 修复 修复IMasaConfiguration大小写敏感问题 修复AutoComplete设置内容出错 Configuration 修复获取对应的CallerProvider 修复Caller不支持响应值为null 功能（已完成） Caller CallerBase支持与获取当前Caller相同的生命周期的服务 DaprClient支持自定义RequestMessage Data 序列化、反序列化&gt;&gt;Json、Yaml IdGenerator&gt;&gt;支持Id生成器工厂 Cqrs Query 移除Result不能为空限制 Configuration 简化Dcc配置 支持全局配置 功能（进行中） Cache 分布式缓存、多级缓存 Identity 支持Blazor Server 支持Blazor Assembly 支持自定义用户模型 Localization I18n Date MinimalAPI 支持一组服务设置一次权限策略 MASA Blazor 更新内容新功能 MobilePickerView：专为移动设备设计的选择视图。提供多个选项集合供用户选择，支持单列选择、多列选择和级联选择。 MobilePicker：专为移动设备设计的选择器。提供多个选项集合供用户选择，支持单列选择、多列选择和级联选择。 MobileDateTimePicker：专为移动设备设计的日期选择器。 MobileDatePicker：专为移动设备设计的时间选择器。 MobileTimePicker：专为移动设备设计的时间选择器。 MobileCascader：更改异步加载子对象的UI和行为。 文档 平铺和标记预置组件。 在LOGO后面附加版本标签。 支持在移动设备上algolia搜索。 修复移动端AppBar的高度会影响桌面端Top的计算。 信息来源：https://github.com/BlazorComponent/MASA.Blazor/releases 社区近期问题解答Q1: MASA Framework有多租户的内建实现吗？ A: 我们提供了多租户与多环境的默认实现 Q2: MASA有工作流吗 A: 有规划工作流，不过目前还没有开始 Q3: 有完整的链路跟踪处理吗 A: 后面课程会有讲解如何做链路跟踪(https://space.bilibili.com/1000468483) Q4: MASA Framework的项目地址是多少? A: https://github.com/masastack/MASA.Framework Q5:Framework下载后构建失败 A: 新的Framework文件夹层级较深，可通过以下方案处理。1. 移到本地磁盘根目录或相对较短路径 2. 更改注册表解除长度限制 如果你对我们的开源项目感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们","link":"/2022/08/31/MASA%20Stack/%E7%AC%AC%E5%9B%9B%E6%9C%9F%E7%A4%BE%E5%8C%BA%E4%BE%8B%E4%BC%9A/"},{"title":"C#8.0 可空引用类型","text":"介绍我们的项目代码运行时最频繁的错误之一就是 System.NullReferenceException 异常，c#8.0 增加的可为空引用类型就是用来帮助开发者降低甚至消除NULL异常。我们需要注意的是可空引用类型是语法级别的功能，也就是代码编写的时候就会受到编程约束，这个与可为空值类型是不一样的。项目支持 c#8.0 请参见C# 语言版本控制。 目录 介绍 目录 在项目中启用可空引用类型支持 将警告提升为异常 将变量标注为可空引用类型 泛型 使用示例 进阶 [AllowNull] [DisallowNull] [NotNull] [NotNullIfNotNull] 缺陷 Struct 数组 总结 在项目中启用可空引用类型支持12345678&lt;Project Sdk=&quot;Microsoft.NET.Sdk.Web&quot;&gt; &lt;PropertyGroup&gt; &lt;TargetFramework&gt;net6.0&lt;/TargetFramework&gt; &lt;Nullable&gt;enable&lt;/Nullable&gt; &lt;/PropertyGroup&gt;&lt;/Project&gt; 在项目文件中增加&lt;Nullable&gt;enable&lt;/Nullable&gt;后，项目代码中的引用类型将被解析拆分为不可空引用类型和可空引用类型。 将警告提升为异常可空引用类型功能是以警告的形式出现，并不会干扰项目生成编译，约束力较弱。如果想严格要求自身，那我们可将特定的警告变为异常来提升约束力。 1234567891011&lt;Project Sdk=&quot;Microsoft.NET.Sdk.Web&quot;&gt; &lt;PropertyGroup&gt; &lt;TargetFramework&gt;net6.0&lt;/TargetFramework&gt; &lt;Nullable&gt;enable&lt;/Nullable&gt; &lt;WarningsAsErrors&gt; $(WarningsAsErrors);CS8600;CS8601;CS8602;CS8603;CS8604;CS8609;CS8610;CS8614;CS8616;CS8618;CS8619;CS8622;CS8625 &lt;/WarningsAsErrors&gt; &lt;/PropertyGroup&gt;&lt;/Project&gt; 相关技术文档C# 编译器选项 - 错误和警告 | Microsoft Docs，Non-nullable references with C# 8 and .NET Core 3.0 · Cezary Piątek Blog (cezarypiatek.github.io)，大家在编写代码时遇到 Microsoft.CodeAnalysis.CSharp 分析器所给的警告代码，都可按照自己的要求将其变为异常来约束自己。 将变量标注为可空引用类型我们平时使用的引用类型属于不可空引用类型，在其后附加**?便为可空引用类型**。 12string name; //不可空字符串string? adress; //可空字符串 泛型123456789public TKey GetKey&lt;TKey&gt;(){ //必须返回不可空类型}public TValue? GetValue&lt;TValue&gt;(){ //可返回可空类型} 使用示例 如上示例，由于 Student 拥有默认的空构造函数new Student(),此构造函数会使Name和Adress属性为 null，所以分析器发出了 CS8618 的警告。 我们将空构造函数写上，此时警告智能的转移到构造函数上了。 我们在构造函数中将可能为 null 的 string 类型属性附上值，警告消除。而 string?类型无需处理，因为它是允许为 null 的。 以上两种方式也可以消除警告。 在GetStudentNames方法中，我们使用Student的EnglishName属性时，分析器发出了 CS8604 警告，因为EnglishName属性是可空引用类型，无法放入List&lt;string&gt;中，只能放入在List&lt;string?&gt;中。 我们使用??判断当EnglishName为 null 时，使用不可空引用类型属性Name，此时 CS8604 警告消除。 进阶可空引用类型模式中，属性是可以被拆分为两种模式的，其一是属性是否可被赋值 null，其二是属性的值是否可能为 null。大家可能对这句话理解起来有点懵，请接着看下面的讲解。 [AllowNull]不可为 null 的引用类型属性允许被赋值 null 上面代码中，Adress属性即使被赋值 null，也不会使其值为 null，不会在代码中引发潜在的 Null 异常。所以此场景是合理且被允许的。 [DisallowNull]可为 null 的引用类型属性不允许赋值为 null Adress属性虽然默认值是 null，但对其赋值 null 是不合理的。虽然不能赋值 null，但获取Adress属性的值时仍可能为 null，大家可在合适的场景使用[DisallowNull]。 [NotNull]可为 null 的引用类型属性的值永远不会是 null，可放心使用 我们使用GetStudentAdress方法返回Student的Adress属性，分析器并没有发出警告，因为分析器通过[NotNull]特性也知道了Adress属性的值永远不会为 null。 我们尝试将Adress属性改为可能返回 null 值，分析器立马发出了 CS8603 警告，很给力。 [NotNullIfNotNull]这个特性作用于方法中，用于告诉其他程序员只要你不给我的方法传 null 参，我就不会返回 null 给你，你看着办。 12345[return: NotNullIfNotNull(&quot;student&quot;)]public string? GetStudentAdress(Student? student){ return student?.Adress;} adress和adress2有着不同的待遇。 缺陷有些场景分析器无法分析出潜在的 null 异常 Struct12345678910111213141516171819public struct Student{ public string FirstName; public string? MiddleName; public string LastName;}public static class Program{ public static void PrintStudent(Student student) { Console.WriteLine($&quot;First name: {student.FirstName.ToUpper()}&quot;); Console.WriteLine($&quot;Middle name: {student.MiddleName?.ToUpper()}&quot;); Console.WriteLine($&quot;Last name: {student.LastName.ToUpper()}&quot;); } public static void Main() =&gt; PrintStudent(default(FirstName)); public static void Main2() =&gt; PrintStudent(new Student());} default(FirstName) 和new Student()中的FirstName 和 LastName 运行时为 null，编辑器此时未出现任何警告。 12345678910111213public struct Foo&lt;T&gt;{ public T Bar { get; set; }}public static class Program{ public static void Main() { string s = default(Foo&lt;string&gt;).Bar; string s2 = new Foo&lt;string&gt;().Bar; }} 属性 Bar 在运行时为 null,而s和s2是不可为 null 字符串类型，编辑器此时未出现任何警告。 数组数组也是可为 null 的引用类型中的已知缺陷 1234567891011using System;public static class Program{ public static void Main() { string[] values = new string[10]; string s = values[0]; Console.WriteLine(s.ToUpper()); }} 代码中的数组声明其元素为不可为 null 的 string，而其元素在初始化时都为 null，编辑器此时未出现任何警告。 总结将引用类型拆分为可空引用类型和不可空引用类型可以为我们的项目代码带来质的提升，团队之间协作或者使用第三方的类库都可以通过?标识来知道方法的某个参数传 null 不会引发异常、属性赋值 null 不会引发异常，反之我们使用某些属性或者方法的返参也可以知道其是否可能为 null，对于不可能为 null 的变量我们就无需再麻烦的检测 null 值了，而在以前，我们可能需要对每个变量都需要做 null 判断。感兴趣的同学赶紧给自己的项目加入这个功能吧。","link":"/2021/11/30/nullable-reference-types/nullable-reference-types/"},{"title":"手把手教你学Dapr - 0. 目录","text":"手把手教你学Dapr - 目录 .Net开发者的大时代 Dapr设计思想 微服务为什么很难 25:17：https://www.bilibili.com/video/BV1j44y1478h?spm_id_from=333.999.0.0 Dapr的目标 3:58：https://www.bilibili.com/video/BV1Gq4y1Z7dS?spm_id_from=333.999.0.0 分布式应用运行时 9:32：https://www.bilibili.com/video/BV1Gq4y1Z7dS?spm_id_from=333.999.0.0 Dapr and Service Meshes 44:29：https://www.bilibili.com/video/BV1Gq4y1Z7dS?spm_id_from=333.999.0.0 Sidecars and components 7:20：https://www.bilibili.com/video/BV1Gq4y1Z7dS?spm_id_from=333.999.0.0 对于.Net架构的指导意义 开源协作的浪潮 大话Dapr概念 Building blocks Components Configuration Observability Security Service meshes Dapr services Terminology VS下的无缝开发体验 托管方式 环境准备 常用的daprd 运行参数 https://docs.dapr.io/reference/arguments-annotations-overview/ 常用的环境变量解析 https://docs.dapr.io/reference/environment/ Http Max Request Size https://docs.dapr.io/operations/configuration/increase-request-size/ Docker Compose Without Docker Dapr dashboard https://github.com/dapr/dashboard 服务调用 编写一个Hello World API .Net SDK HTTP gRPC 并发和限流 https://docs.dapr.io/operations/configuration/control-concurrency/https://docs.dapr.io/reference/components-reference/supported-middleware/middleware-rate-limit/ 状态管理 并发控制 一致性 事务 业务数据的增删改查？youtube有微软官方示例 redis spec https://docs.dapr.io/reference/components-reference/supported-state-stores/setup-redis/ 发布订阅 redis spec https://docs.dapr.io/reference/components-reference/supported-state-stores/setup-redis/ 路由事件与编排 可访问性 TTL Raw Payload 故障排查 https://docs.dapr.io/zh-hans/developing-applications/sdks/dotnet/dotnet-troubleshooting/dotnet-troubleshooting-pubsub/ API 绑定 kafka spec https://docs.dapr.io/reference/components-reference/supported-bindings/kafka/ 跨Dapr互调用 API Actors Actor相同的ActorId会被缓存成类似单例，构造函数注入要小心 分布式和故障转移 并发控制 调用 状态管理 定时器 提醒 Actor重入 https://github.com/dapr/dotnet-sdk/blob/master/daprdocs/content/en/dotnet-sdk-docs/dotnet-actors/dotnet-actors-usage.md#registering-actors API 可观测性 Tracing Metrics Logging 生产环境的推荐托管方式K8s 使用KEDA做自动扩缩容 Health 集成Open Service Mesh 安全&amp;可靠性 mTLS OAuth and spec https://docs.dapr.io/reference/components-reference/supported-middleware/middleware-oauth2/ Token Dapr App 哨兵 https://docs.dapr.io/reference/components-reference/supported-middleware/middleware-sentinel/","link":"/2021/10/25/tech-dapr-by-the-hand/0/"},{"title":"手把手教你学Dapr - 1. .Net开发者的大时代","text":"Dapr全称Distributed Application Runtime，分布式应用运行时 Dapr的口号简化云原生应用开发，聚焦在应用的核心逻辑，让代码简单、可移植 Dapr的目标 最佳实践的构建块 任何语言或框架 一致性，可移植，开放的API 采纳标准 可扩展和可插拔的组件 与平台无关(本地，云计算，边缘计算等) 社区驱动，供应商(厂商)中立 Dapr的设计思路这里首先要先理解几个问题，然后再看Dapr如何解决这些问题的 以下资料都有英文原图，中文翻译为个人理解，英文好的小伙伴可以直接看原图。 微服务为什么很难 开发者要构建自己的运行时处理分布式应用问题 运行时支持的开发语言有限,且有严格控制的特性（功能）集合 运行时的可移植性有限，一般只支持特定的基础架构平台 分布式应用的需求 内容引自 Multi-Runtime Microservices Architecture https://www.infoq.com/articles/multi-runtime-microservice-architecture/ 注意：二级内容不与图片对应，把功能组合成场景 生命周期 更快的发布周期 自动化部署 从错误中恢复 自动化伸缩 网络 服务发现 跟踪与遥测（可观测性） 信息交换：点对点、发布/订阅，智能路由 状态 服务编排、工作流 分布式单例（Actor） 临时调度（Cron） 幂等性 有状态错误恢复 缓存 绑定 转换协议 支持不同的消息交换模式：轮询、事件驱动、请求/应答等 转换消息格式 执行自定义错误恢复过程 安全机制 传统中间件和云原生对比传统中间件以各种SDK的方式提供能力，而云原生平台则通过各种外围的Runtime，目前来看比较有趣的是，大家不约而同的选择了Sidecar。 多运行时微服务边界 K8s和容器在多语言应用程序的生命周期管理方面取得了巨大的飞跃，并为未来的创新奠定了基础 Service Mesh在K8s上得到了改进，具有先进的网络功能，并开始深入应用程序 Knative通过快速伸缩来关注无服务器的工作负载，解决了服务编排和事件驱动的绑定需求 Dapr以K8s、Knative和Service Mesh的思想为基础，深入研究应用程序运行时，处理有状态的工作负载、绑定和集成需求，充当现代分布式中间件 主要分为3个部分，K8s、机甲运行时（网关、Dapr + Knative）、业务逻辑。 Dapr的出现可以让开发者更专注于业务逻辑，而业务逻辑则作为服务运行时。 多运行时的好处业务逻辑和不断增加的分布式系统关注点之间的松耦合。 业务逻辑经常变化，取决于业务优先级。 而分布式原语则由软件供应商提供，作为库、容器、服务来使用。这些代码会根据供应商优先级、发布周期、安全补丁、开源治理规则等而变化。 他们互相看不到对方，也无法控制对方。 Dapr的优势：Any language, anywhere与语言无关，与平台无关 分布式应用运行时官方解释 帮助开发人员构建事件驱动的、弹性的分布式应用程序。 无论是在本地、云中还是在边缘设备上，都可以帮助你解决构建微服务所带来的挑战，并保持代码与平台无关。 可以看到Dapr更具象化了 与应用程序通过HTTP和gRPC通信 内部有一些构建块 运行在云上 Dapr与服务网格 开发者更聚焦在代码层面，通过SDK(图中没有标注)与dapr的构建块通信，面向localhost编程 运维更关注安全性、可观测性、健壮性等问题上。而流量管控的部分，dapr(可能是暂时的)没有。 Sidecar的世界 应用于Sidecar通信是通过Dapr API(已经被封装成不同开发语言的SDK)，这个过程中通过OpenTelemetry支持了可观测性（即跟踪、日志、指标） 应用之间通过Sidecar通信，支持mTLS，这个指服务调用（即Service Invocation） Sidecar 之间通过gRPC(图片中没有显示)，Bindings，Pub/Sub都可以通信 可观测性无处不在，通过Prometheus、Zipkin、Fluentd等，可视化OpenTelemetry中的部分数据 但目前据我所知没有一个可以统一接管完整OpenTelemetry的，如果有的话欢迎纠错。 状态管理也是由Sidecar代理的 对于.Net的意义 .Net SDK是微软亲儿子，让.Net和Java一起在新起点站在了同一起跑线 分布式应用运行时给.Net的新架构带来了新的思路和机遇 加速.Net技术栈的更新迭代 共享开源生态 我们正在行动，新的框架、新的生态我们的目标是自由的、易用的、可塑性强的、功能丰富的、健壮的。 所以我们借鉴Building blocks的设计理念，正在做一个新的框架MASA Framework，它有哪些特点呢？ 原生支持Dapr，且允许将Dapr替换成传统通信方式 架构不限，单体应用、SOA、微服务都支持 支持.Net原生框架，降低学习负担，除特定领域必须引入的概念，坚持不造新轮子 丰富的生态支持，除了框架以外还有组件库、权限中心、配置中心、故障排查中心、报警中心等一系列产品 核心代码库的单元测试覆盖率90%+ 开源、免费、社区驱动 还有什么？我们在等你，一起来讨论 经过几个月的生产项目实践，已完成POC，目前正在把之前的积累重构到新的开源项目中 目前源码已开始同步到Github（文档站点在规划中，会慢慢完善起来）： MASA.BuildingBlocks MASA.Contrib MASA.Utils MASA.EShop BlazorComponent MASA.Blazor QQ群：7424099 微信群：加技术运营微信（MasaStackTechOps），备注来意，邀请进群","link":"/2021/10/25/tech-dapr-by-the-hand/1/"},{"title":"手把手教你学Dapr - 2. 必须知道的概念","text":"Sidecar 边车Dapr API提供Http和gRPC两种通讯方式。 运行方式则可以是容器也可以是进程（Windows开发推荐使用Self Hosted，后续会解释）。 这样的好处是与运行环境无关，且独立运行不需要应用包含Dapr运行时的代码。只需要通过SDK集成即可，这使得Dapr与应用的逻辑分离。 Building blocks 构建块官方解释：可通过标准HTTP或gRPC api访问的模块化最佳实践 通俗一点来说，就是API 目前支持的构建块如下，但1.5很快会出一个新的Configuration API（从这个新的API又印证了构建块的本质），由阿里-敖小剑牵头整理的 Github Issue: https://github.com/dapr/dapr/issues/2988 这个提案很长，很曲折。仔细看会发现中外开发大环境下的一些思想碰撞。微软相对保守，阿里相对激进但也更务实。最终长达几个月的激烈讨论下定版。 期间本人也有幸与阿里-敖小剑和阿里-仪式（Layotto的研发同学，Layotto兼容Dapr协议，是蚂蚁在做）开过语音会议一起聊过对于Configuration API的一些设计问题。 服务调用 状态管理 发布订阅 绑定 Actor（这个不建议翻译回中文） 可观测性 安全 Components 组件官方解释：被用于构建块和应用程序的模块化功能 Dapr 使用模块化设计，将功能作为组件来提供。 每个组件都有接口定义。 所有组件都是可插拔的，因此您可以将组件换为另一个具有相同接口的组件。 结合构建块来看，组件有接口定义。而构建块则通过接口将组件的功能串联起来 基于对Dapr设计的理解，我们的MASA Framework也定义出了 BuildingBlocks 和 Contrib，与dapr会有些许不同 原因如下： 由BuildingBlocks定义标准、串业务流程 让Contrib变成我们的最佳实践，并允许开发重新定义BuildingBlocks的具体实现，在保证功能完整的前提下提供更符合业务场景的功能又有参考代码 聚焦核心代码稳定性，提供单元测试覆盖率保障，共享大众智慧 组件与构建块并不是一一对应的，组件可以被不同的构建块复用，比如Actor构建块内的状态管理也是用的状态存储组件 状态存储 服务发现 中间件 发布订阅代理 绑定 密钥存储 Configuration 配置官方解释：变更Dapr Sidecar或全局Dapr系统服务的行为 配置定义和部署形式为YAML文件 在官方文档的Component sepcs可以看到每个组件提供了多少种实现，每个实现特性支持情况 除此之外不同组件的配置文件格式也是应有尽有 官方文档对于组件配置的讲解非常详细，这里举个例子，Redis状态管理的配置文件格式 你需要变更的部分已经用&lt;*&gt;和 # * 做了标记 参考自：https://docs.dapr.io/reference/components-reference/supported-state-stores/setup-redis/ 12345678910111213141516171819202122232425apiVersion: dapr.io/v1alpha1kind: Componentmetadata: name: &lt;NAME&gt; namespace: &lt;NAMESPACE&gt;spec: type: state.redis version: v1 metadata: - name: redisHost value: &lt;HOST&gt; - name: redisPassword value: &lt;PASSWORD&gt; - name: enableTLS value: &lt;bool&gt; # Optional. Allowed: true, false. - name: failover value: &lt;bool&gt; # Optional. Allowed: true, false. - name: sentinelMasterName value: &lt;string&gt; # Optional - name: maxRetries value: # Optional - name: maxRetryBackoff value: # Optional - name: ttlInSeconds value: &lt;int&gt; # Optional Observability 可观测性官方解释：通过跟踪、指标、日志和健康状况监视应用 在构建应用程序时，了解系统如何运行是运维的一个重要部分——这包括有能力观测应用程序的内部调用，评估其性能并在发生问题时立即意识到问题 这对任何系统都是一种挑战，而对于由多个微服务组成的分布式系统来说更是如此 分布式跟踪配置发送跟踪数据，轻松集成多个监控后端 OpenTelemetry collector配置OpenTelemetry收集器，使用支持OpenTelemetry的监控后端 Dapr Sidecar和系统服务的可观测性配置收集Dapr Sidecar和相关服务的指标和日志 Security 安全性Dapr 用于加密传输中数据的安全机制之一是 相互认证（mutual authentication）TLS 或简写为 mTLS 双向身份验证 通过加密通道通信 Sidecar与应用通信Dapr Sidecar通过localhost与应用通信，并提供Token API级别身份验证 Sidecar之间的通信Dapr默认开启mTLS（可以手动关闭，有一定的性能损耗，大多数情况下可以忽略不计）。Dapr利用Sentry的系统服务充当证书颁发机构，包括证书轮换。 证书默认有效期为24小时，时钟偏差为15分钟。 Self Hosted mTLS K8s mTLS Sidecar与系统服务之间的通信Dapr Sidecar和Dapr系统服务之间是强制性mTLS的，包括Sentry（证书颁发机构）、Placement（Actor安置服务）和K8s Operator K8s中系统服务的mTLS Dapr Sidecar与Dapr系统服务（Actor Placement, Sidecar Injector, Sentry, Operator）之间是通过mTLS Kubelet与Dapr Sidecar之间也是通过mTLS Dapr Sidecar或者Dapr系统服务与Components之间也是通过mTLS Dapr Sidecar与应用之间不是 其实Dapr在安全方面做的工作很多，这里就不继续一一列举了 我们正在行动，新的框架、新的生态我们的目标是自由的、易用的、可塑性强的、功能丰富的、健壮的。 所以我们借鉴Building blocks的设计理念，正在做一个新的框架MASA Framework，它有哪些特点呢？ 原生支持Dapr，且允许将Dapr替换成传统通信方式 架构不限，单体应用、SOA、微服务都支持 支持.Net原生框架，降低学习负担，除特定领域必须引入的概念，坚持不造新轮子 丰富的生态支持，除了框架以外还有组件库、权限中心、配置中心、故障排查中心、报警中心等一系列产品 核心代码库的单元测试覆盖率90%+ 开源、免费、社区驱动 还有什么？我们在等你，一起来讨论 经过几个月的生产项目实践，已完成POC，目前正在把之前的积累重构到新的开源项目中 目前源码已开始同步到Github（文档站点在规划中，会慢慢完善起来）： MASA.BuildingBlocks MASA.Contrib MASA.Utils MASA.EShop BlazorComponent MASA.Blazor QQ群：7424099 微信群：加技术运营微信（MasaStackTechOps），备注来意，邀请进群","link":"/2021/10/26/tech-dapr-by-the-hand/2/"},{"title":"手把手教你学Dapr - 3. 使用Dapr运行第一个.Net程序","text":"注意： 文章中提到的命令行工具即是Windows Terminal/PowerShell/cmd其中的一个，推荐使用Windows Terminal 运行命令行工具的时候建议以管理员身份，避免踩坑 为了保证操作顺畅，建议使用PowerShell先执行一下set-ExecutionPolicy RemoteSigned 安装Docker因为Dapr CLI默认会在Docker内启动 redis、zipkin、placement。 当然这些也不是必须要安装的，只是推荐安装可以体验Dapr的完整能力，方便后续章节的学习。 下载并安装Docker Desktop https://www.docker.com/products/docker-desktop 安装WSL2，使用命令行工具执行命令 1wsl --instal 如果不能使用wsl直接安装的话可以手动安装，运行PowerShell并执行下面两句命令12dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestartdism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 如果你再次遇到错误提示：0x800f080c 功能名称 VirtualMachinePlatform 未知。 请保证自己的操作系统版本在Windows 10 build 18917以上 重启电脑后下载WSL2内核 https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi 运行命令行工具，设置默认使用WSL2 1wsl --set-default-version 2 下载Ubuntu 20.04 https://www.microsoft.com/store/apps/9n6svws3rx71 设置Docker使用WSL2 你“可能”需要一个小工具不能说的秘密，看文件名猜功能 https://github.com.cnpmjs.org/dotnetcore/FastGithub/releases/download/2.0.4/fastgithub_win-x64.zip 安装Dapr CLI官方解释：Dapr CLI 是您用于各种 Dapr 相关任务的主要工具。 您可以使用它来运行一个带有Dapr sidecar的应用程序， 以及查看sidecar日志、列出运行中的服务、运行 Dapr 仪表板。 CLI是必须要安装吗？其实也不是，但新手不建议去体验这些骚操作。后续文章会讲解脱离dapr cli工作。 运行Windows Terminal或PowerShell，执行命令，这里要耐心等待一下 1iwr -useb https://raw.githubusercontent.com/dapr/cli/master/install/install.ps1 | iex 如果是cmd执行下面命令： 1powershell -Command &quot;iwr -useb https://raw.githubusercontent.com/dapr/cli/master/install/install.ps1 | iex&quot; 验证安装，重新打开命令行工具执行命令dapr，看到下面的提示即安装正确 123456789101112131415161718192021222324252627282930313233343536 __ ____/ /___ _____ _____ / __ / __ '/ __ \\/ ___/ / /_/ / /_/ / /_/ / / \\__,_/\\__,_/ .___/_/ /_/===============================Distributed Application RuntimeUsage: dapr [command]Available Commands: completion Generates shell completion scripts components List all Dapr components. Supported platforms: Kubernetes configurations List all Dapr configurations. Supported platforms: Kubernetes dashboard Start Dapr dashboard. Supported platforms: Kubernetes and self-hosted help Help about any command init Install Dapr on supported hosting platforms. Supported platforms: Kubernetes and self-hosted invoke Invoke a method on a given Dapr application. Supported platforms: Self-hosted list List all Dapr instances. Supported platforms: Kubernetes and self-hosted logs Get Dapr sidecar logs for an application. Supported platforms: Kubernetes mtls Check if mTLS is enabled. Supported platforms: Kubernetes publish Publish a pub-sub event. Supported platforms: Self-hosted run Run Dapr and (optionally) your application side by side. Supported platforms: Self-hosted status Show the health status of Dapr services. Supported platforms: Kubernetes stop Stop Dapr instances and their associated apps. . Supported platforms: Self-hosted uninstall Uninstall Dapr runtime. Supported platforms: Kubernetes and self-hosted upgrade Upgrades a Dapr control plane installation in a cluster. Supported platforms: KubernetesFlags: -h, --help help for dapr -v, --version version for daprUse &quot;dapr [command] --help&quot; for more information about a command. 初始化Dapr 使用命令行工具执行命令 1dapr init 如此之外还有一个精简版的安装方式 1dapr init --slim 看看官方解释slim 在此模式下安装了两个不同的二进制文件 daprd 和 placement。 placement是给actor用的，之前有提到过。 在此模式下，不会为状态管理或发布/订阅安装任何默认组件（如 Redis），那就只能用服务调用。其他的需要用户自己设置环境和自定义组件。 说白了，你只用服务调用，那slim是可以的，否则的话你需要手动配置来解决CLI代替你做的那部分工作。 验证Dapr版本 1dapr --version 当前时间下，我的版本是 12CLI version: 1.4.0Runtime version: 1.4.3 验证容器 1docker ps dapr init的容器是包括dapr_placement, dapr_redis, dapr_zipkin 验证组件目录，打开目录%USERPROFILE%\\.dapr\\，看到如下结构即代表安装完成 运行一个示例代码看看效果运行环境准备vs 2022/2019，建议直接上VS2022体验64位VS https://visualstudio.microsoft.com/zh-hans/vs/preview/#download-preview .net 6，如果你用的不是vs2022，需要自行安装.net 6 https://download.visualstudio.microsoft.com/download/pr/5bc3c525-d6d5-4370-8468-e44a1b948c03/fe758c9942966b88b52d92ce2823f6c0/dotnet-sdk-6.0.100-rc.2.21505.57-win-x64.exe 从Github下载示例代码使用命令行工具克隆代码库到本地 ssh（推荐）用下面的命令 1git clone git@github.com:doddgu/dapr-study-room.git https用下面的命令 1git clone https://github.com/doddgu/dapr-study-room.git 没有git的需要先安装一下git，具体教程可以自行百度 https://github.com/git-for-windows/git/releases/download/v2.33.1.windows.1/Git-2.33.1-64-bit.exe 使用Dapr运行.Net示例代码 使用命令行工具，跳转到源码目录dapr-study-room\\Assignment03\\Assignment.Server Tips：在资源管理器找到源码目录 Win 11可以右键空白区域 -&gt; 在Windows终端中打开即可 Win 11以下在资源管理器输入cmd 执行命令dapr run --app-id assignment-server --app-port 5038 dotnet run 可以先不用了解命令行的意思，后续章节会讲解 看到输入内容如下即运行成功 123456789101112131415== APP == info: Microsoft.Hosting.Lifetime[14]== APP == Now listening on: https://localhost:7038== APP == info: Microsoft.Hosting.Lifetime[14]== APP == Now listening on: http://localhost:5038== APP == info: Microsoft.Hosting.Lifetime[0]== APP == Application started. Press Ctrl+C to shut down.== APP == info: Microsoft.Hosting.Lifetime[0]== APP == Hosting environment: Development== APP == info: Microsoft.Hosting.Lifetime[0]== APP == Content root path: D:\\Project\\OpenSource\\dapr-study-room\\Assignment03\\Assignment.Servertime=&quot;2021-10-27T18:06:11.8422605+08:00&quot; level=info msg=&quot;application discovered on port 5038&quot; app_id=assignment-server instance=SSHZ014 scope=dapr.runtime type=log ver=1.4.3time=&quot;2021-10-27T18:06:11.8788949+08:00&quot; level=info msg=&quot;application configuration loaded&quot; app_id=assignment-server instance=SSHZ014 scope=dapr.runtime type=log ver=1.4.3time=&quot;2021-10-27T18:06:11.8803982+08:00&quot; level=info msg=&quot;actor runtime started. actor idle timeout: 1h0m0s. actor scan interval: 30s&quot; app_id=assignment-server instance=SSHZ014 scope=dapr.runtime.actor type=log ver=1.4.3time=&quot;2021-10-27T18:06:11.8844485+08:00&quot; level=info msg=&quot;dapr initialized. Status: Running. Init Elapsed 1830.3305ms&quot; app_id=assignment-server instance=SSHZ014 scope=dapr.runtime type=log ver=1.4.3time=&quot;2021-10-27T18:06:11.8920835+08:00&quot; level=info msg=&quot;placement tables updated, version: 0&quot; app_id=assignment-server instance=SSHZ014 scope=dapr.runtime.actor.internal.placement type=log ver=1.4.3 还有一个验证方式，使用命令行工具执行命令dapr list 其中APP ID，APP PORT，COMMAND是不变的，其余都是变的 APP ID HTTP PORT GRPC PORT APP PORT COMMAND AGE CREATED PID assignment-server 49948 49949 5038 dotnet run 13m 2021-10-27 18:06.09 22596 调用Dapr API 重新打开一个命令行工具 测试Dapr API，再打开一个命令行工具 1dapr invoke --app-id assignment-server --method hello 验证运行是否成功 执行dapr inovoke的命令行窗口输出如下 App invoked successfully 执行dapr run的命令行窗口输出如下 == APP == Hello World! 这个Hello World就是Assignment.Server的API /hello 打印出来的，此时你的环境已经ok，且第一个示例也运行成功了 给自己点个赞吧👍在这个环境的搭建过程中，可以看到dapr还有点“稚嫩”，毕竟现在才1.4版本，还有很长的路要走 但是这并不妨碍他带来的一些思想的进步，如果你错过了微服务的第一波浪潮，也错过了Service Mesh，那分布式应用运行时（Dapr）可以作为你新的起点 本章源码Assignment03 https://github.com/doddgu/dapr-study-room 我们正在行动，新的框架、新的生态我们的目标是自由的、易用的、可塑性强的、功能丰富的、健壮的。 所以我们借鉴Building blocks的设计理念，正在做一个新的框架MASA Framework，它有哪些特点呢？ 原生支持Dapr，且允许将Dapr替换成传统通信方式 架构不限，单体应用、SOA、微服务都支持 支持.Net原生框架，降低学习负担，除特定领域必须引入的概念，坚持不造新轮子 丰富的生态支持，除了框架以外还有组件库、权限中心、配置中心、故障排查中心、报警中心等一系列产品 核心代码库的单元测试覆盖率90%+ 开源、免费、社区驱动 还有什么？我们在等你，一起来讨论 经过几个月的生产项目实践，已完成POC，目前正在把之前的积累重构到新的开源项目中 目前源码已开始同步到Github（文档站点在规划中，会慢慢完善起来）： MASA.BuildingBlocks MASA.Contrib MASA.Utils MASA.EShop BlazorComponent MASA.Blazor QQ群：7424099 微信群：加技术运营微信（MasaStackTechOps），备注来意，邀请进群","link":"/2021/10/27/tech-dapr-by-the-hand/3/"},{"title":"手把手教你学Dapr - 4. 服务调用","text":"介绍通过使用服务调用，您的应用程序可以使用标准的gRPC或HTTP协议与其他应用程序可靠、安全地通信。 为什么不直接用HttpClientFactory呢先问几个问题： 如何发现和调用不同服务的方法 如何安全地调用其他服务，并对方法应用访问控制 如何处理重试和瞬态错误 如何使用分布式跟踪指标来查看调用图来诊断生产中的问题 此时你会发现这些事情HttpClientFactory没有帮你完成，而在微服务中这些又是必不可少的能力，接下来看看服务调用都做了什么 服务调用如何工作的先看一下两个服务之间的调用顺序 服务A 向服务B发起一个HTTP/gRPC的调用。调用转到了本地的Dapr sidecar Dapr使用名称解析组件发现服务B的位置 Dapr 将消息转发至服务 B的 Dapr sidecar 注: Dapr sidecar之间的所有调用都通过gRPC来提高性能。 仅服务与 Dapr sidecar之间的调用可以是 HTTP或gRPC 服务B 的 Dapr sidecar将请求转发至服务B 上的特定端点 (或方法) 。 服务B 随后运行其业务逻辑代码 服务B 发送响应给服务A。 响应将转至服务B 的Dapr sidecar Dapr 转发响应至服务A 的 Dapr sidecar 服务 A 接收响应 命名空间作用域默认情况下，调用同一个命名空间的其他服务可以直接使用AppID（假设是：nodeapp） 1localhost:3500/v1.0/invoke/nodeapp/method/neworder 服务调用也支持跨命名空间调用，在所有受支持的宿主平台上，Dapr AppID遵循FQDN格式，其中包括目标命名空间。 FQDN：(Fully Qualified Domain Name)全限定域名：同时带有主机名和域名的名称。（通过符号“.”） 例如：主机名是bigserver,域名是mycompany.com,那么FQDN就是bigserver.mycompany.com ​ 注：FQDN是通过符号.来拼接域名的，这也就解释了AppID为什么不能用符号.，这里不记住的话，应该会有不少小伙伴会踩坑 ​ 比如.net开发者习惯用 A.B.C 来命名项目，但AppID需要把.换成-且所有单词最好也变成小写 （a-b-c），建议把它变成约定遵守 比如调用命名空间：production，AppID：nodeapp 1localhost:3500/v1.0/invoke/nodeapp.production/method/neworder 这在K8s集群中的跨名称空间调用中特别有用 服务间安全性通过托管平台上的相互(mTLS)身份验证，包括通过Dapr Sentry服务的自动证书转移，可以确保Dapr应用程序之间的所有调用的安全。 下图显示了自托管应用程序的情况。 访问控制应用程序可以控制哪些其他应用程序可以调用它们，以及通过访问策略授权它们做什么。 这使您能够限制具有个人信息的敏感应用程序不被未经授权的应用程序访问，并结合服务到服务的安全通信，提供了软多租户部署。 具体的访问控制后续章节会介绍 重试在调用失败和瞬态错误的情况下，服务调用执行自动重试，并在回退时间段内执行。 注：自动重试，默认是开启的，可以关。但如果不关且业务又不支持幂等是很危险的。建议服务的接口要设计支持幂等，这在微服务里也是一个标配的选择。 导致重试的错误有: 网络错误，包括端点不可用和拒绝连接。 由于在调用/被调用的Dapr sidecars上更新证书而导致的身份验证错误。 每次呼叫重试的回退间隔为1秒，最多为3次。 通过gRPC与目标Sidecar连接的超时时间为5秒 可插拔的服务发现Dapr可以在各种托管平台上运行。 为了启用服务发现和服务调用，Dapr使用可插拔的名称解析组件。 例如，K8s名称解析组件使用K8s DNS服务来解析集群中运行的其他应用程序的位置。 自托管机器可以使用mDNS名称解析组件。 Consul名称解析组件可以在任何托管环境中使用，包括K8s或自托管环境 划重点，自托管机器使用mDNS，在开发环境中后面文章会推荐VS上的无缝开发体验，就是基于mDNS的 但它有点点小问题，我们已经解决了。你只需要像开发一个控制台程序一样，基于Minimal API开心的F5就可以了 建议还没有了解Minimal API的小伙伴可以研究起来了，真香 使用mDNS进行轮询负载均衡一图胜千言，就使用mDNS轮着调用 可观测性的跟踪和指标默认情况下，将跟踪应用程序之间的所有调用，并收集指标，以提供应用程序的洞察力和诊断，这在生产场景中尤其重要。 这为您提供了服务之间调用的调用图和指标。 服务调用API和gRPC代理pythonapp 通过Dapr sidecar调用nodeapp，通过服务调用的API及gRPC代理依然是上面见到的那个调用流程，做到了语言无关 使用HTTP调用服务创建Assignment.Server创建ASP.NET Core空项目，并修改launchSettings.json，让启动HTTP的启动端口变为5000 profiles.Assignment.Server.applicationUrl 的值改为 “https://localhost:6000;http://localhost:5000&quot; 修改Program.cs文件 1234567891011121314151617var builder = WebApplication.CreateBuilder(args);var app = builder.Build();app.MapPost(&quot;/&quot;, () =&gt; Console.WriteLine(&quot;Hello!&quot;));app.MapGet(&quot;/Hello1&quot;, () =&gt;{ Console.WriteLine(&quot;Hello World1!&quot;); return $&quot;\\&quot;Hello World1!\\&quot;&quot;;});app.MapPost(&quot;/Hello2&quot;, () =&gt; Console.WriteLine(&quot;Hello World2!&quot;));app.Map(&quot;/Hello3&quot;, () =&gt; Console.WriteLine(&quot;Hello World3!&quot;));app.Run(); 此时一共有4个服务 / ：Post方法，打印Hello! /Hello1：Get方法，打印Hello World1!，返回Hello World1! 注：返回的类型要是Json字符串，方便SDK反序列化 /Hello2：Post方法，打印Hello World2! /Hello3：不带后缀表示适配所有方法，打印Hello World3! 先使用Dapr CLI来验证一下运行Assignment.Server：在目录dapr-study-room\\Assignment04\\Assignment.Server打开命令行工具，并执行下面命令 1dapr run --app-id assignment-server --app-port 5000 dotnet watch 细心的小伙伴应该可以发现与上一篇的命令有一点点不同，dontet run变成了dotnet watch，这样会开启热重载，方便调试 调用服务：再打开一个新的命令行工具，并执行下面命令 1234dapr invoke --app-id assignment-server --method /dapr invoke --app-id assignment-server --method Hello1dapr invoke --app-id assignment-server --method Hello2dapr invoke --app-id assignment-server --method Hello3 可以发现4个命令都调用成功了，但是Assignment.Server输出结果有点意外 123== APP == Hello!== APP == Hello World2!== APP == Hello World3! 是的，没有Hello World1!，那怎么办呢？我们把Hello1的命令改一下 1dapr invoke --app-id assignment-server --method Hello1 --verb GET invoke调用的输出除了App invoked successfully以外还多了一行Hello World1! 与此同时Assignment.Server的输出正确了 1== APP == Hello World1! 除此之外invoke还有一些参数，比如--data,--data-file，喜欢研究Dapr CLI的小伙伴可以继续尝试。不过一般情况下用SDK就可以了 创建Assignment.ClientHTTP服务调用创建控制台应用程序项目，使用NuGet包管理器添加Dapr.Client SDK，并修改Program.cs文件 1234567891011121314using Dapr.Client;var appId = &quot;assignment-server&quot;;var client = new DaprClientBuilder().Build();await client.InvokeMethodAsync(appId, &quot;/&quot;);var resp = await client.InvokeMethodAsync&lt;string&gt;(HttpMethod.Get, appId, &quot;Hello1&quot;);Console.WriteLine($&quot;Hello1 Response: {resp}&quot;);await client.InvokeMethodAsync(appId, &quot;Hello2&quot;);await client.InvokeMethodAsync(appId, &quot;Hello3&quot;); 看几个细节 DaprClient是从DaprClinetBuilder Build出来的 还有一种方式使用DaprClient，通过DI 首先都是需要添加Dapr.AspNetCore NuGet包 然后开始有分支了，如果是以前Web API的方式可以在Startup.cs文件ConfigureServices方法加入一行代码 1services.AddControllers().AddDapr(); 如果使用Minimal API默认是没有Controllers的，那可以在var builder = WebApplication.CreateBuilder(args); 之后加入一行代码 1builder.Services.AddDaprClient(); 成功的注入进来了，在构造函数或者[FromServices]里愉快的玩耍吧 HttpMethod.Post 的我都没有指定，默认就是Post HttpMethod.Get的时候，返回值会自动用Json反序列化 不喜欢Json？可以通过 DaprClient.CreateInvokeHttpClient 构造 HttpClient，聪明的你肯定知道后面怎么办了 注： 1. Minimal API虽香，但新，所以不是所有功能都支持，比如从参数中直接映射状态管理，要等Minimal API支持Model Binder以后且SDK也同步支持了才可以 2. DaprClient是TCP的，也是线程安全的，可以大胆的复用，如果不用DI的话不需要频繁构建DaprClient 验证调用成功使用命令行工具打开目录dapr-study-room\\Assignment04\\Assignment.Client，然后执行命令 1dotnet run 如果你不是用VS Code终端的PowerShell执行dapr run就可能遇到下面的错误 即便你没有遇到也建议了解一下如何支持非默认端口 123An exception occurred while invoking method: '/' on app-id: 'assignment-server' ---&gt; System.Net.Http.HttpRequestException: 由于目标计算机积极拒绝，无法连接。 (127.0.0.1:3500) ---&gt; System.Net.Sockets.SocketException (10061): 由于目标计算机积极拒绝，无法连接。 因为上面使用dapr run的时候没有指定dapr http port，而默认client访问的是3500端口 解决的办法有两种： 修改Assignment.Server启动参数，增加--dapr-http-port 3500，这个方法治标不治本，因为将来我们可能启动多个服务 1dapr run --app-id assignment-server --app-port 5000 --dapr-http-port 3500 dotnet watch 修改Assignment.Client的环境变量 首先执行dapr list查看端口，以下面为例，HTTP PORT是51460 APP ID HTTP PORT GRPC PORT APP PORT COMMAND AGE CREATED PID assignment-server 51460 51461 5000 dotnet watch 7s 2021-10-29 14:13.49 11676 修改Assignment.Client的启动参数，注意把51460换成你自己的端口，使用PowerShell执行下面命令 12$Env:DAPR_HTTP_PORT = 51460dotnet run 再执行一次dotnet run就可以看到正确的输出结果了 1Hello1 Response: Hello World1! gRPC服务调用篇幅太长了，举一反三吧。就是调用InvokeMethodGrpcAsync，然后dapr-http-port换成dapr-grpc-port，DAPR_HTTP_PORT换成DAPR_GRPC_PORT 查看跟踪还记得dapr init的时候docker里有个zipkin吧，通过zipkin可以看一下调用跟踪，通过浏览器打开下面地址 http://localhost:9411/ 此时页面是空的 根据步骤操作一下就可以看到了 随便点开一行数据尾部的SHOW，就可以看到调用详情 本章源码Assignment04 https://github.com/doddgu/dapr-study-room 我们正在行动，新的框架、新的生态我们的目标是自由的、易用的、可塑性强的、功能丰富的、健壮的。 所以我们借鉴Building blocks的设计理念，正在做一个新的框架MASA Framework，它有哪些特点呢？ 原生支持Dapr，且允许将Dapr替换成传统通信方式 架构不限，单体应用、SOA、微服务都支持 支持.Net原生框架，降低学习负担，除特定领域必须引入的概念，坚持不造新轮子 丰富的生态支持，除了框架以外还有组件库、权限中心、配置中心、故障排查中心、报警中心等一系列产品 核心代码库的单元测试覆盖率90%+ 开源、免费、社区驱动 还有什么？我们在等你，一起来讨论 经过几个月的生产项目实践，已完成POC，目前正在把之前的积累重构到新的开源项目中 目前源码已开始同步到Github（文档站点在规划中，会慢慢完善起来）： MASA.BuildingBlocks MASA.Contrib MASA.Utils MASA.EShop BlazorComponent MASA.Blazor QQ群：7424099 微信群：加技术运营微信（MasaStackTechOps），备注来意，邀请进群","link":"/2021/10/28/tech-dapr-by-the-hand/4/"},{"title":"手把手教你学Dapr - 5. 状态管理","text":"介绍使用状态管理，您的应用程序可以将数据作为键/值对存储在支持的状态存储中。 您的应用程序可以使用 Dapr 的状态管理 API 使用状态存储组件来保存和读取键/值对，如下图所示。例如，通过使用 HTTP POST，您可以保存键/值对，通过使用 HTTP GET，您可以读取键并返回其值。 特性可插拔状态存储Dapr 数据存储被建模为组件，可以在不更改代码的情况下更换它。例如：MySQL、Redis、Azure CosmosDB等。 可配置的状态存储行为Dapr 允许开发人员将额外的元数据附加到状态操作请求中，用以描述请求的处理方式。如： 并发要求 一致性要求 默认情况下，您的应用程序应假定数据存储最终一致并使用最后写入获胜的并发模式 并发Dapr 支持使用 ETags 的乐观并发控制 (OCC)。当请求状态时，Dapr 总是将 ETag 属性附加到返回的状态。当用户代码尝试更新或删除状态时，应该通过请求正文附加 ETag 以进行更新或通过 If-Match 标头进行删除。只有当提供的 ETag 与状态存储中的 ETag 匹配时，写操作才能成功。建议您在使用 ETag 时使用重试策略来补偿此类冲突。 如果您的应用程序在写入请求时省略 ETag，则 Dapr 在处理请求时会跳过 ETag 检查。与使用 ETag 的先写赢模式相比，这实质上启用了最后写赢模式。 自动加密Dapr 支持应用程序状态的自动客户端加密，并支持密钥轮换。这是一项预览功能，所有 Dapr 状态存储都支持。 一致性Dapr 支持强一致性和最终一致性，最终一致性作为默认行为。 当使用强一致性时，Dapr 在确认写入请求之前等待所有副本（或指定的仲裁）确认。 当使用最终一致性时，一旦底层数据存储接受写入请求，Dapr 就会立即返回，即使这是单个副本。 批量操作Dapr 支持两种类型的批量操作 - 批量（bulk）或多（multi）。 注：bulk与multi的区别在于bulk不是事务性的，multi是事务处理。 Actor状态事务状态存储可用于存储Actor状态。要指定用于Actor的状态存储，请在状态存储组件的元数据部分中将属性 actorStateStore 的值指定为 true。 注：Actors 状态以特定方案存储在事务状态存储中允许一致的查询。所以只能有一个状态存储组件被用于所有的Actor。 直接查询状态存储Dapr 无需任何转换即可保存和检索状态值。您可以直接从底层状态存储查询和聚合状态。 例如，要在 Redis 中获取与应用程序 ID “myApp” 关联的所有状态键，请使用： 1KEYS &quot;myApp*&quot; 查询Actor状态如果数据存储支持 SQL 查询，您可以使用 SQL 查询查询参与者的状态。例如使用： 1SELECT * FROM StateTable WHERE Id='&lt;app-id&gt;||&lt;actor-type&gt;||&lt;actor-id&gt;||&lt;key&gt;' 您还可以跨Actor实例执行聚合查询，避免Actor 框架常见的基于回合的并发限制。例如，要计算所有温度计Actor的平均温度，请使用： 1SELECT AVG(value) FROM StateTable WHERE Id LIKE '&lt;app-id&gt;||&lt;thermometer&gt;||*||temperature' 保存并获取状态状态管理是任何应用程序最常见的需求之一：新的或遗留的、单体或微服务。处理不同的数据库、测试、处理重试和故障可能既费时又费力。 先决条件准备好Dapr运行环境可以看之前的文章 手把手教你学Dapr - 3. 使用Dapr运行第一个.Net程序 设置状态存储Windows打开目录%USERPROFILE%\\.dapr\\components 创建文件statestore.yaml 使用redis作为状态存储的数据库 123456789101112131415apiVersion: dapr.io/v1alpha1kind: Componentmetadata: name: statestorespec: type: state.redis version: v1 metadata: - name: redisHost value: localhost:6379 - name: redisPassword value: &quot;&quot; - name: actorStateStore value: &quot;true&quot; 注：这个yaml已经通过actorStateStore开启了Actor状态 保存和检索单个状态注：设置 app-id 很重要，因为状态键以该值作为前缀。如果您不设置它，则在运行时为您生成一个，下次运行该命令时将生成一个新的，您将无法再访问以前保存的状态。换句话说，如果你要共享状态可以自定义一个保留app-id作为共享状态而不是留空。 运行Dapr Sidecar运行一个空的Sidecar，因为我们只用它来帮助访问状态存储，所以与之前不同的是，dapr run后面没有接dotnet run去作为某一个程序的Sidecar 1dapr run --app-id myapp --dapr-http-port 3500 --dapr-grpc-port 50001 创建客户端创建控制台程序，添加Dapr.Client NuGet包引用。 修改Program.cs 1234567891011121314using Dapr.Client;var storeName = &quot;statestore&quot;;var key = &quot;myFirstKey&quot;;var value = &quot;myFirstValue&quot;;var client = new DaprClientBuilder().Build();await client.SaveStateAsync(storeName, key, value);Console.WriteLine(&quot;State has been stored&quot;);var data = await client.GetStateAsync&lt;string&gt;(storeName, key);Console.WriteLine($&quot;Got value: {data}&quot;);Console.ReadKey(); 删除单个状态1await client.DeleteStateAsync(storeName, key); 通过事务保存和检索多个状态Dapr 还允许您在同一个调用中保存和检索多个状态。 123456789var lst = new List&lt;StateTransactionRequest&gt;(){ new StateTransactionRequest(&quot;test1&quot;, System.Text.Encoding.UTF8.GetBytes(&quot;value1&quot;), StateOperationType.Upsert), new StateTransactionRequest(&quot;test2&quot;, System.Text.Encoding.UTF8.GetBytes(&quot;value2&quot;), StateOperationType.Upsert),};await client.ExecuteStateTransactionAsync(storeName, lst);var datas = await client.GetBulkStateAsync(storeName, lst.Select(r =&gt; r.Key).ToList(), 0);Console.WriteLine($&quot;Got items: {string.Join(&quot;,&quot;, datas.Select(d =&gt; $&quot;{d.Key}={d.Value}&quot;))}&quot;); 强一致性使用强一致性时，Dapr将确保底层状态存储在写入或删除状态之前，一旦数据被写入到所有副本或收到来自quorum的ack，就会返回响应。 对于GET请求，Dapr 将确保存储在副本之间一致地返回最新数据。默认为最终一致性，除非在对状态 API 的请求中另有说明。 123456await client.SaveStateAsync(storeName, key, value, new StateOptions() { Consistency = ConsistencyMode.Strong });var etagData = await client.GetStateAndETagAsync&lt;string&gt;(storeName, key, ConsistencyMode.Strong);Console.WriteLine($&quot;ETag:{etagData.etag}&quot;);await client.DeleteStateAsync(storeName, key, new StateOptions() { Consistency = ConsistencyMode.Strong }); 先写赢和最后写赢Dapr 允许开发人员在使用数据存储时选择两种常见的并发模式：首先写入获胜和``最后写入获胜`。 First-Write-Wins 在您有多个应用程序实例的情况下很有用，所有实例都同时写入同一个键。 Dapr 的默认模式是最后写入获胜。 下面的例子展示了如何获取一个 ETag，然后使用它来保存状态，然后删除状态： 1234567891011await client.SaveStateAsync(storeName, key, value, new StateOptions() { Concurrency = ConcurrencyMode.FirstWrite });var firstWriteWinData = await client.GetStateAndETagAsync&lt;string&gt;(storeName, key);var etag = firstWriteWinData.etag;await client.TrySaveStateAsync(storeName, key, DateTime.Now.Ticks.ToString(), etag, new StateOptions() { Concurrency = ConcurrencyMode.FirstWrite });var firstWriteWinDeleteSucceeded = await client.TryDeleteStateAsync(storeName, key, etag);Console.WriteLine($&quot;First write wins delete:{firstWriteWinDeleteSucceeded}&quot;);firstWriteWinData = await client.GetStateAndETagAsync&lt;string&gt;(storeName, key);firstWriteWinDeleteSucceeded = await client.TryDeleteStateAsync(storeName, key, firstWriteWinData.etag);Console.WriteLine($&quot;First write wins delete:{firstWriteWinDeleteSucceeded}&quot;); 注：这里演示了ETag在更新后尝试删除失败的例子，最后再重新获取新的状态以修正ETag再删除 在不同的应用程序之间共享状态为了实现状态共享，Dapr 支持以下键前缀策略 appid - 这是默认策略。 appid 前缀允许状态只能由具有指定 appid 的应用程序管理。所有状态键都将以 appid 为前缀，并以应用程序为范围。 name - 此设置使用状态存储组件的名称作为前缀。对于给定的状态存储，多个应用程序可以共享相同的状态。 none - 此设置不使用前缀。多个应用程序在不同的状态存储之间共享状态 举个例子：要指定前缀策略，请在状态组件上添加名为 keyPrefix 的元数据键 1234567891011apiVersion: dapr.io/v1alpha1kind: Componentmetadata: name: statestore namespace: productionspec: type: state.redis version: v1 metadata: - name: keyPrefix value: &lt;key-prefix-strategy&gt; 注：此示例演示相对较复杂，思路大概是使用多个statestore.yaml，然后根据不同的storename切换不同策略即可。感兴趣的小伙伴可以自行尝试。 自动加密状态并管理密钥轮换注：截止目前，这个功能是个预览版，感兴趣的小伙伴可以自行尝试 应用程序状态通常需要静态加密，以在企业工作负载或受监管环境中提供更强的安全性。 Dapr 提供基于 AES256 的自动客户端加密。 状态的生存时间（TTL）Dapr 为每个状态在请求时设置生存时间 (TTL)。这意味着应用程序可以为每个存储的状态设置生存时间，并且这些状态在到期后无法检索。 注：只有一部分 Dapr 状态存储组件与状态 TTL 兼容。对于支持的状态存储，只需在发布消息时设置 ttlInSeconds 元数据。其他状态存储将忽略此值。 1234567await client.SaveStateAsync(storeName, key, value, metadata: new Dictionary&lt;string, string&gt;() { { &quot;ttlInSeconds&quot;, &quot;3&quot; } });var ttlData = await client.GetStateAsync&lt;string&gt;(storeName, key);Console.WriteLine($&quot;TTL Data:{ttlData}&quot;);Thread.Sleep(5000);ttlData = await client.GetStateAsync&lt;string&gt;(storeName, key);Console.WriteLine($&quot;TTL Data:{ttlData}&quot;); 持久化状态要显式设置持久化状态（忽略为键设置的任何 TTL），请将 ttlInSeconds 值指定为 -1。 本章源码Assignment05 https://github.com/doddgu/dapr-study-room 我们正在行动，新的框架、新的生态我们的目标是自由的、易用的、可塑性强的、功能丰富的、健壮的。 所以我们借鉴Building blocks的设计理念，正在做一个新的框架MASA Framework，它有哪些特点呢？ 原生支持Dapr，且允许将Dapr替换成传统通信方式 架构不限，单体应用、SOA、微服务都支持 支持.Net原生框架，降低学习负担，除特定领域必须引入的概念，坚持不造新轮子 丰富的生态支持，除了框架以外还有组件库、权限中心、配置中心、故障排查中心、报警中心等一系列产品 核心代码库的单元测试覆盖率90%+ 开源、免费、社区驱动 还有什么？我们在等你，一起来讨论 经过几个月的生产项目实践，已完成POC，目前正在把之前的积累重构到新的开源项目中 目前源码已开始同步到Github（文档站点在规划中，会慢慢完善起来）： MASA.BuildingBlocks MASA.Contrib MASA.Utils MASA.EShop BlazorComponent MASA.Blazor QQ群：7424099 微信群：加技术运营微信（MasaStackTechOps），备注来意，邀请进群","link":"/2021/11/09/tech-dapr-by-the-hand/5/"},{"title":"手把手教你学Dapr - 6. 发布订阅","text":"介绍发布/订阅模式允许微服务使用消息相互通信。生产者或发布者在不知道哪个应用程序将接收它们的情况下向主题发送消息。这涉及将它们写入输入通道。同样，消费者或订阅者订阅该主题并接收其消息，而不知道是什么服务产生了这些消息。这涉及从输出通道接收消息。中间消息代理负责将每条消息从输入通道复制到所有对该消息感兴趣的订阅者的输出通道。当您需要将微服务彼此分离时，这种模式特别有用。 Dapr 中的发布/订阅 API 提供至少一次（at-least-once）的保证，并与各种消息代理和队列系统集成。 您的服务所使用的特定实现是可插入的，并被配置为运行时的 Dapr Pub/Sub 组件。 这种方法消除了您服务的依赖性，从而使您的服务可以更便携，更灵活地适应更改。 Dapr 发布/订阅构建块提供了一个与平台无关的 API 来发送和接收消息。您的服务将消息发布到命名主题，并订阅主题以使用这些消息。 下图显示了一个“shipping”服务和一个“email”服务的例子，它们都订阅了“cart”服务发布的主题。每个服务都会加载指向同一发布/订阅消息总线组件的发布/订阅组件配置文件，例如 Redis Streams、NATS Streaming、Azure Service Bus 或 GCP Pub/Sub。 下图具有相同的服务，但是这次显示的是 Dapr 发布 API，它发送“订单”主题和订阅服务上的订单端点，这些主题消息由 Dapr 发布到。 特性Cloud Events消息格式为了启用消息路由并为每条消息提供额外的上下文，Dapr 使用 CloudEvents 1.0 规范作为其消息格式。应用程序使用 Dapr 发送到主题的任何消息都会自动“包装”在 Cloud Events 信封中，使用 datacontenttype 属性的 Content-Type 标头值。 Dapr 实现了以下 Cloud Events 字段： id source specversion type datacontenttype (Optional) 以下示例显示了 CloudEvent v1.0 中序列化为 JSON 的 XML 内容： 12345678910{ &quot;specversion&quot; : &quot;1.0&quot;, &quot;type&quot; : &quot;xml.message&quot;, &quot;source&quot; : &quot;https://example.com/message&quot;, &quot;subject&quot; : &quot;Test XML Message&quot;, &quot;id&quot; : &quot;id-1234-5678-9101&quot;, &quot;time&quot; : &quot;2020-09-23T06:23:21Z&quot;, &quot;datacontenttype&quot; : &quot;text/xml&quot;, &quot;data&quot; : &quot;&lt;note&gt;&lt;to&gt;User1&lt;/to&gt;&lt;from&gt;user2&lt;/from&gt;&lt;message&gt;hi&lt;/message&gt;&lt;/note&gt;&quot;} 消息订阅Dapr 应用程序可以订阅已发布的主题。 Dapr 允许您的应用程序订阅主题的两种方法： 声明式，其中订阅在外部文件中定义 程序化，在用户代码中定义订阅 消息传递原则上，当订阅者在处理消息后以非错误响应进行响应时，Dapr 认为消息已成功传递。为了进行更精细的控制，Dapr 的发布/订阅 API 还提供了在响应负载中定义的显式状态，订阅者可以使用这些状态向 Dapr 指示特定的处理指令（例如 RETRY 或 DROP）。如果两个不同的应用程序（不同的 app-ID）订阅了同一个主题，Dapr 将每条消息只传递给每个应用程序的一个实例。 主题范围默认情况下，所有支持 Dapr 发布/订阅组件（例如 Kafka、Redis Stream、RabbitMQ）的主题都可用于配置了该组件的每个应用程序。为了限制哪个应用程序可以发布或订阅主题，Dapr 提供了主题范围。这使您能够允许应用程序发布哪些主题以及允许应用程序订阅哪些主题。 消息生存时间(TTL)Dapr 可以在每条消息的基础上设置超时消息，这意味着如果没有从 pub/sub 组件读取消息，则该消息将被丢弃。这是为了防止堆积未读的消息。在队列中比配置的 TTL 时间长的消息称为死消息。 注：也可以在组件创建时为给定队列设置消息 TTL。 与不使用 Dapr 和 CloudEvents 的应用程序通信对于一个应用程序使用 Dapr 而另一个应用程序不使用的场景，可以为发布者或订阅者禁用 CloudEvent 包装。这允许在不能一次全部采用 Dapr 的应用程序中部分采用 Dapr 发布订阅。 使用.Net调用Dapr的发布订阅以下示例创建应用程序来发布和订阅名为 deathStarStatus 的主题 先决条件运行 dapr init 时，Redis Streams 默认安装在本地机器上。如果是 dapr init --slim 需要自己动手操作一些东西了，这里就不演示了。 通过打开您的组件文件进行验证 %UserProfile%\\.dapr\\components\\pubsub.yaml 123456789101112apiVersion: dapr.io/v1alpha1kind: Componentmetadata: name: pubsubspec: type: pubsub.redis version: v1 metadata: - name: redisHost value: localhost:6379 - name: redisPassword value: &quot;&quot; 注：这里redisHost的value可以根据实际情况设置，比如某云的redis实例等。又有人问过是否可以切换默认db，当然可以，name设置redisDB，value设置为你要使用的db即可 如果你要更详细的yaml配置参数，比如并发设置、最大重试次数等等都可以看这里 https://docs.dapr.io/reference/components-reference/supported-pubsub/setup-redis-pubsub/ 订阅主题订阅主题有两种方式：声明式、程序化 声明式订阅您可以使用以下自定义资源定义 (CRD) 订阅主题。创建一个名为 subscription.yaml 的文件并粘贴以下内容： 1234567891011apiVersion: dapr.io/v1alpha1kind: Subscriptionmetadata: name: myevent-subscriptionspec: topic: deathStarStatus route: /dsstatus pubsubname: pubsubscopes:- app1- app2 上面的示例显示了对 pubsub 组件 pubsub 主题 deathStarStatus 的事件订阅。 将CRD文件放到组件目录即可，这里不继续展开说了。 程序化订阅Dapr 实例在启动时调用您的应用程序并期待主题订阅的 JSON 响应： pubsubname：Dapr 应该使用哪个 pub/sub 组件 topic：订阅哪个主题 route：当消息涉及该主题时，Dapr 调用哪个endpoint 注：你可能会觉得，这是不是很麻烦？是的，所以我们用dapr dotnet-sdk来帮助我们自动完成这些事情 .Net订阅以上是让dapr sidecar知道这个消息的订阅最终给谁。但我们的程序里要怎么写呢？ 如果你选择的是声明式订阅，你做一个route即可，而如果是程序化订阅则不需要多写一个yaml文件，且通过特性即可支持，接下来看看.Net SDK怎么做的吧。 创建Assignment.Server(Sub)创建ASP.NET Core 空项目，同时根据之前的文章内容添加Dapr.AspNetCoreNuGet包和修改程序端口为5000 修改program.cs代码 123456789101112131415using Microsoft.AspNetCore.Mvc;var builder = WebApplication.CreateBuilder(args);var app = builder.Build();app.UseRouting();app.UseCloudEvents();app.UseEndpoints(endpoints =&gt;{ endpoints.MapSubscribeHandler();});app.MapPost(&quot;/dsstatus&quot;, ([FromBody] string word) =&gt; Console.WriteLine($&quot;Hello {word}!&quot;)).WithTopic(&quot;pubsub&quot;, &quot;deathStarStatus&quot;);app.Run(); 注：为了告诉 Dapr 消息已成功处理，请返回 200 OK 响应。如果 Dapr 收到除 200 之外的任何其他返回状态代码，或者如果您的应用程序崩溃，Dapr 将尝试按照 At-Least-Once 语义重新传递消息。 运行Assignment.Server使用Dapr CLI来启动，先使用命令行工具跳转到目录 dapr-study-room\\Assignment06\\Assignment.Server，然后执行下面命令 1dapr run --app-id testpubsub --app-port 5000 --dapr-http-port 3500 --dapr-grpc-port 50001 dotnet run 创建Assignment.Client(Publish)创建控制台项目，并修改program.cs 12var client = new Dapr.Client.DaprClientBuilder().Build();await client.PublishEventAsync&lt;string&gt;(&quot;pubsub&quot;, &quot;deathStarStatus&quot;, &quot;World&quot;); 运行Assignment.Client即可看到Assignment.Server中会打印Hello World! 将消息路由到不同的事件处理程序基于内容的路由是一种使用 DSL 而不是命令式应用程序代码的消息传递模式。PubSub 路由是此模式的一种实现，它允许开发人员使用表达式根据 CloudEvents 的内容将其路由到应用程序中的不同 URI/路径和事件处理程序。 注：这是个预览功能，如果你感兴趣可自行尝试，值得一提的是Common Expression Language (CEL)很有趣，这里就只贴一段代码看看吧。 1234567891011121314151617181920212223[Topic(&quot;pubsub&quot;, &quot;inventory&quot;, &quot;event.type ==\\&quot;widget\\&quot;&quot;, 1)][HttpPost(&quot;widgets&quot;)]public async Task&lt;ActionResult&lt;Stock&gt;&gt; HandleWidget(Widget widget, [FromServices] DaprClient daprClient){ // Logic return stock;}[Topic(&quot;pubsub&quot;, &quot;inventory&quot;, &quot;event.type ==\\&quot;gadget\\&quot;&quot;, 2)][HttpPost(&quot;gadgets&quot;)]public async Task&lt;ActionResult&lt;Stock&gt;&gt; HandleGadget(Gadget gadget, [FromServices] DaprClient daprClient){ // Logic return stock;}[Topic(&quot;pubsub&quot;, &quot;inventory&quot;)][HttpPost(&quot;products&quot;)]public async Task&lt;ActionResult&lt;Stock&gt;&gt; HandleProduct(Product product, [FromServices] DaprClient daprClient){ // Logic return stock;} 发布/订阅主题访问权限命名空间或组件范围可用于限制对特定应用程序的组件访问。添加到组件的这些应用程序范围仅限制具有特定 ID 的应用程序能够使用该组件。 除了这个通用组件范围之外，发布/订阅组件还可以限制以下内容： 可以使用哪些主题（已发布或已订阅） 允许哪些应用程序发布到特定主题 允许哪些应用程序订阅特定主题 主题访问权限1234567891011121314151617apiVersion: dapr.io/v1alpha1kind: Componentmetadata: name: pubsub namespace: defaultspec: type: pubsub.redis version: v1 metadata: - name: redisHost value: &quot;localhost:6379&quot; - name: redisPassword value: &quot;&quot; - name: publishingScopes value: &quot;app1=topic1;app2=topic2,topic3;app3=&quot; - name: subscriptionScopes value: &quot;app2=;app3=topic1&quot; 下表显示了允许哪些应用程序发布到主题中： topic1 topic2 topic3 app1 X app2 X X app3 下表显示了允许哪些应用程序订阅主题： topic1 topic2 topic3 app1 X X X app2 app3 X 注：如果应用程序未列出（例如 subscriptionScopes 中的 app1），则允许订阅所有主题。由于未使用 allowedTopics 且 app1 没有任何订阅范围，因此它还可以使用上面未列出的其他主题。 限制允许的主题如果 Dapr 应用程序向其发送消息，则会创建一个主题。在某些情况下，应该控制这个主题的创建。例如： 在Dapr应用程序中，在生成主题名称时出现的错误可能导致创建无限数量的主题 精简主题名称和总数，防止主题无限增长 123456789101112131415apiVersion: dapr.io/v1alpha1kind: Componentmetadata: name: pubsub namespace: defaultspec: type: pubsub.redis version: v1 metadata: - name: redisHost value: &quot;localhost:6379&quot; - name: redisPassword value: &quot;&quot; - name: allowedTopics value: &quot;topic1,topic2,topic3&quot; 结合 allowedTopics 和 scopes有时您希望组合这两个作用域，因此只允许一组固定的主题，并将作用域指定给特定的应用程序。 12345678910111213141516171819apiVersion: dapr.io/v1alpha1kind: Componentmetadata: name: pubsub namespace: defaultspec: type: pubsub.redis version: v1 metadata: - name: redisHost value: &quot;localhost:6379&quot; - name: redisPassword value: &quot;&quot; - name: allowedTopics value: &quot;A,B&quot; - name: publishingScopes value: &quot;app1=A&quot; - name: subscriptionScopes value: &quot;app1=;app2=A&quot; 注：第三个应用程序没有列出，因为如果一个应用程序没有在范围内指定，它是允许使用所有主题的。 下表显示了允许发布到主题的应用程序： A B C app1 X app2 X X app3 X X 下表显示了哪个应用程序可以订阅主题: A B C app1 app2 X app3 X X 消息TTL同状态管理，使用 metadata 的 ttlInSeconds 本章源码Assignment06 https://github.com/doddgu/dapr-study-room 我们正在行动，新的框架、新的生态我们的目标是自由的、易用的、可塑性强的、功能丰富的、健壮的。 所以我们借鉴Building blocks的设计理念，正在做一个新的框架MASA Framework，它有哪些特点呢？ 原生支持Dapr，且允许将Dapr替换成传统通信方式 架构不限，单体应用、SOA、微服务都支持 支持.Net原生框架，降低学习负担，除特定领域必须引入的概念，坚持不造新轮子 丰富的生态支持，除了框架以外还有组件库、权限中心、配置中心、故障排查中心、报警中心等一系列产品 核心代码库的单元测试覆盖率90%+ 开源、免费、社区驱动 还有什么？我们在等你，一起来讨论 经过几个月的生产项目实践，已完成POC，目前正在把之前的积累重构到新的开源项目中 目前源码已开始同步到Github（文档站点在规划中，会慢慢完善起来）： MASA.BuildingBlocks MASA.Contrib MASA.Utils MASA.EShop BlazorComponent MASA.Blazor QQ群：7424099 微信群：加技术运营微信（MasaStackTechOps），备注来意，邀请进群","link":"/2021/11/12/tech-dapr-by-the-hand/6/"},{"title":"手把手教你学Dapr - 7. Actors","text":"介绍Actor模式将Actor描述为最低级别的“计算单元”。换句话说，您在一个独立的单元（称为actor）中编写代码，该单元接收消息并一次处理一个消息，没有任何并发或线程。 再换句话说，根据ActorId划分独立计算单元后，相同的ActorId重入要排队，可以理解为lock(ActorId) 注：这里有个反例，就是重入性的引入，这个概念目前还是Preview，它允许同一个链内可以重复进入，判断的标准不止是ActorId这么简单，即自己调自己是被允许的。这个默认是关闭的，需要手动开启，即默认不允许自己调自己。 当您的代码处理一条消息时，它可以向其他参与者发送一条或多条消息，或者创建新的参与者。底层运行时管理每个参与者运行的方式、时间和地点，并在参与者之间路由消息。 大量的Actor可以同时执行，Actor彼此独立执行。 Dapr 包含一个运行时，它专门实现了 Virtual Actor 模式。 通过 Dapr 的实现，您可以根据 Actor 模型编写 Dapr Actor，而 Dapr 利用底层平台提供的可扩展性和可靠性保证。 什么时候用ActorsActor 设计模式非常适合许多分布式系统问题和场景，但您首先应该考虑的是该模式的约束。一般来说，如果出现以下情况，请考虑使用Actors模式来为您的问题或场景建模： 您的问题空间涉及大量（数千个或更多）小的、独立且孤立的状态和逻辑单元。 您希望使用不需要与外部组件进行大量交互的单线程对象，包括跨一组Actors查询状态。 您的 Actor 实例不会通过发出 I/O 操作来阻塞具有不可预测延迟的调用者。 Dapr Actor每个Actor都被定义为Actor类型的实例，就像对象是类的实例一样。 例如，可能有一个执行计算器功能的Actor类型，并且可能有许多该类型的Actor分布在集群的各个节点上。每个这样的Actor都由一个Acotr ID唯一标识。 生命周期Dapr Actors是虚拟的，这意味着他们的生命周期与他们的内存表现无关。因此，它们不需要显式创建或销毁。Dapr Actors运行时在第一次收到对该Actor ID 的请求时会自动激活该Actor。如果一个Actor在一段时间内没有被使用，Dapr Actors运行时就会对内存中的对象进行垃圾回收。如果稍后需要重新激活，它还将保持对参与者存在的了解。如果稍后需要重新激活，它还将保持对 Actor 的一切原有数据。 调用 Actor 方法和提醒会重置空闲时间，例如提醒触发将使Actor保持活跃。无论Actor是活跃还是不活跃，Actor提醒都会触发，如果为不活跃的Actor触发，它将首先激活演员。Actor 计时器不会重置空闲时间，因此计时器触发不会使 Actor 保持活动状态。计时器仅在Actor处于活动状态时触发。 Reminders 和 Timers 最大的区别就是Reminders会保持Actor的活动状态，而Timers不好会 Dapr 运行时用来查看Actor是否可以被垃圾回收的空闲超时和扫描间隔是可配置的。当 Dapr 运行时调用 Actor 服务以获取支持的 Actor 类型时，可以传递此信息。 由于Virtual Actor模型的存在，这种Virtual Actor生命周期抽象带来了一些注意事项，事实上，Dapr Actors实现有时会偏离这个模型。 第一次将消息发送到Actor ID时，Actor被自动激活(导致构建Actor对象)。 经过一段时间后，Actor对象将被垃圾回收。被回收后再次使用Actor ID将导致构造一个新的Actor对象。 Actor 的状态比对象的生命周期长，因为状态存储在 Dapr 运行时配置的状态管理组件中。 注：Actor被垃圾回收之前，Actor对象是会复用的。这里会导致一个问题，在.Net Actor类中，构造函数在Actor存活期间只会被调用一次。 分发和故障转移为了提供可扩展性和可靠性，Actor 实例分布在整个集群中，Dapr 根据需要自动将它们从故障节点迁移到健康节点。 Actors 分布在 Actor 服务的实例中，而这些实例分布在集群中的节点之间。 对于给定的Actor类型，每个服务实例都包含一组Actor。 Dapr安置服务(Placement Service)Dapr Actor 运行时为您管理分发方案和密钥范围设置。这是由Actor Placement 服务完成的。创建服务的新实例时，相应的 Dapr 运行时会注册它可以创建的Actor类型，并且安置服务会计算给定Actor类型的所有实例的分区。每个Actor类型的分区信息表被更新并存储在环境中运行的每个Dapr实例中，并且可以随着Actor服务的新实例的创建和销毁而动态变化。这如下图所示： 当客户端调用具有特定ID的Actor(例如，Actor ID 123)时，客户端的 Dapr 实例会Hash Actor类型和 ID，并使用该信息调用可以为特定Actor ID的请求提供服务的相应Dapr实例。因此，始终为任何给定的Actor ID 调用相同的分区（或服务实例）。这如下图所示： 这简化了一些选择，但也带来了一些考虑: 默认情况下，Actor 随机放置到 pod 中，从而实现均匀分布。 因为Actor是随机放置的，应该可以预料到Actor操作总是需要网络通信，包括方法调用数据的序列化和反序列化，产生延迟和开销。 注：Dapr Actor 放置服务仅用于 Actor 放置，因此如果您的服务不使用 Dapr Actors，则不需要。 放置服务可以在所有托管环境中运行，包括自托管和 Kubernetes。 Actor通讯您可以通过HTTP/gRPC调用Actor，当然也可以用SDK。 1POST/GET/PUT/DELETE http://localhost:3500/v1.0/actors/&lt;actorType&gt;/&lt;actorId&gt;/&lt;method/state/timers/reminders&gt; 并发Dapr Actor 运行时为访问 Actor 方法提供了一个简单的回合制（turn-basesd）的访问模型。这意味着在任何时候，Actor 对象的代码中都不能有超过一个线程处于活动状态。 单个Actor实例一次不能处理多个请求。如果预期要处理并发请求，Actor 实例可能会导致吞吐量瓶颈。 单个Actor实例指每个Actor ID对应的Actor对象。单个Actor不并发就没有问题 如果两个 Actor 之间存在循环请求，而同时向其中一个 Actor 发出外部请求，则 Actor 之间可能会陷入僵局。Dapr Actor运行时自动超时Actor调用并向调用者抛出异常以中断可能的死锁情况。 重入性（Preview）作为对 dapr 中基础 Actor 的增强。现在重入性为预览功能，感兴趣的小伙伴可以到看官方文档。 回合制访问（Turn-based access）一个回合包括一个Actor方法的完整执行以响应来自其他Actor或客户端的请求，或者一个计时器/提醒回调的完整执行。即使这些方法和回调是异步的，Dapr Actor运行时也不会将它们交叉。一个回合必须完全完成后，才允许进行新的回合。换句话说，当前正在执行的Actor方法或计时器/提醒回调必须完全完成，才能允许对方法或回调的新调用。 Dapr Actor运行时通过在回合开始时获取每个Actor的锁并在回合结束时释放锁来实现基于回合的并发性。 因此，基于回合的并发是在每个Actor的基础上执行的，而不是跨Actor。Actor 方法和计时器/提醒回调可以代表不同的 Actor 同时执行。 以下示例说明了上述概念。考虑实现两个异步方法（例如 Method1 和 Method2）、计时器和提醒的Actor 类型。下图显示了代表属于此Actor类型的两个Actors（ActorId1 和 ActorId2）执行这些方法和回调的时间线示例。 Actor状态管理Actor可以使用状态管理功能可靠地保存状态。您可以通过 HTTP/gRPC 端点与 Dapr 交互以进行状态管理。 要使用 actor，您的状态存储必须支持事务。这意味着您的状态存储组件必须实现 TransactionalStore 接口。只有一个状态存储组件可以用作所有参与者的状态存储。 事务支持列表：https://docs.dapr.io/reference/components-reference/supported-state-stores/ 注：建议学习的时候都用Redis，官方所有的示例也都是基于Redis，比较容易上手，且Dapr init默认集成 Actor计时器和提醒Actor可以通过注册计时器或提醒来安排自己的定期工作。 计时器和提醒的功能非常相似。主要区别在于，Dapr Actor 运行时在停用后不保留有关计时器的任何信息，而使用 Dapr Actor 状态提供程序保留有关提醒的信息。 定时器和提醒的调度配置是相同的，总结如下： DueTime 是一个可选参数，用于设置第一次调用回调之前的时间或时间间隔。如果省略 DueTime，则在定时器/提醒注册后立即调用回调。 支持的格式： RFC3339 日期格式，例如2020-10-02T15:00:00Z time.Duration 格式，例如2h30m ISO 8601 持续时间格式，例如PT2H30M period 是一个可选参数，用于设置两次连续回调调用之间的时间间隔。当以 ISO 8601-1 持续时间格式指定时，您还可以配置重复次数以限制回调调用的总数。如果省略 period，则回调将仅被调用一次。 支持的格式： time.Duration 格式，例如2h30m ISO 8601 持续时间格式，例如PT2H30M, R5/PT1M30S ttl 是一个可选参数，用于设置计时器/提醒到期和删除的时间或时间间隔。如果省略 ttl，则不应用任何限制。 支持的格式： RFC3339 日期格式，例如2020-10-02T15:00:00Z time.Duration 格式，例如2h30m ISO 8601 持续时间格式，例如PT2H30M 当您同时指定周期内的重复次数和 ttl 时，计时器/提醒将在满足任一条件时停止。 Actor 运行时配置 actorIdleTimeout - 停用空闲 actor 之前的超时时间。每个 actorScanInterval 间隔都会检查超时。默认值：60 分钟 actorScanInterval - 指定扫描演员以停用空闲Actor的频率的持续时间。闲置时间超过 actor_idle_timeout 的 Actor 将被停用。默认值：30 秒 drainOngoingCallTimeout - 在耗尽Rebalanced的Actor的过程中的持续时间。这指定了当前活动 Actor 方法完成的超时时间。如果当前没有 Actor 方法调用，则忽略此项。默认值：60 秒 drainRebalancedActors - 如果为 true，Dapr 将等待 drainOngoingCallTimeout 持续时间以允许当前角色调用完成，然后再尝试停用角色。默认值：true drainRebalancedActors与上面的drainOngoingCallTimeout需搭配使用 reentrancy - (ActorReentrancyConfig) - 配置角色的重入行为。如果未提供，则禁用可重入。默认值：disabled, 0 remindersStoragePartitions - 配置Actor提醒的分区数。如果未提供，则所有提醒都将保存为Actor状态存储中的单个记录。默认值：0 123456789101112131415161718192021// In Startup.cspublic void ConfigureServices(IServiceCollection services){ // Register actor runtime with DI services.AddActors(options =&gt; { // Register actor types and configure actor settings options.Actors.RegisterActor&lt;MyActor&gt;(); // Configure default settings options.ActorIdleTimeout = TimeSpan.FromMinutes(60); options.ActorScanInterval = TimeSpan.FromSeconds(30); options.DrainOngoingCallTimeout = TimeSpan.FromSeconds(60); options.DrainRebalancedActors = true; options.RemindersStoragePartitions = 7; // reentrancy not implemented in the .NET SDK at this time }); // Register additional services for use with actors services.AddSingleton&lt;BankService&gt;();} 分区提醒（Preview）在 sidecar 重新启动后，Actor 提醒会保留并继续触发。在 Dapr 运行时版本 1.3 之前，提醒被保存在 actor 状态存储中的单个记录上。 此为Preview功能，感兴趣可以看官方文档 .Net调用Dapr的Actor与以往不同，Actor示例会多创建一个共享类库用于存放Server和Client共用的部分 创建Assignment.Shared创建类库项目，并添加Dapr.ActorsNuGet包引用，最后添加以下几个类： AccountBalance.cs 1234567namespace Assignment.Shared;public class AccountBalance{ public string AccountId { get; set; } = default!; public decimal Balance { get; set; }} IBankActor.cs 注：这个是Actor接口，IActor是Dapr SDK提供的 123456789using Dapr.Actors;namespace Assignment.Shared;public interface IBankActor : IActor{ Task&lt;AccountBalance&gt; GetAccountBalance(); Task Withdraw(WithdrawRequest withdraw);} OverdraftException.cs 12345678namespace Assignment.Shared;public class OverdraftException : Exception{ public OverdraftException(decimal balance, decimal amount) : base($&quot;Your current balance is {balance:c} - that's not enough to withdraw {amount:c}.&quot;) { }} WithdrawRequest.cs 12345namespace Assignment.Shared;public class WithdrawRequest{ public decimal Amount { get; set; }} 创建Assignment.Server创建类库项目，并添加Dapr.Actors.AspNetCoreNuGet包引用和Assignment.Shared项目引用，最后修改程序端口为5000。 注：Server与Shared和Client的NuGet包不一样，Server是集成了服务端的一些功能 修改program.cs 1234567891011121314151617var builder = WebApplication.CreateBuilder(args);builder.Services.AddSingleton&lt;BankService&gt;();builder.Services.AddActors(options =&gt;{ options.Actors.RegisterActor&lt;DemoActor&gt;();});var app = builder.Build();app.UseRouting();app.UseEndpoints(endpoints =&gt;{ endpoints.MapActorsHandlers();});app.Run(); 添加BankService.cs 123456789101112131415161718192021using Assignment.Shared;namespace Assignment.Server;public class BankService{ // Allow overdraft of up to 50 (of whatever currency). private readonly decimal OverdraftThreshold = -50m; public decimal Withdraw(decimal balance, decimal amount) { // Imagine putting some complex auditing logic here in addition to the basics. var updated = balance - amount; if (updated &lt; OverdraftThreshold) { throw new OverdraftException(balance, amount); } return updated; }} 添加BankActor.cs 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273using Assignment.Shared;using Dapr.Actors.Runtime;using System;namespace Assignment.Server;public class BankActor : Actor, IBankActor, IRemindable // IRemindable is not required{ private readonly BankService bank; public BankActor(ActorHost host, BankService bank) : base(host) { // BankService is provided by dependency injection. // See Program.cs this.bank = bank; } public async Task&lt;AccountBalance&gt; GetAccountBalance() { var starting = new AccountBalance() { AccountId = this.Id.GetId(), Balance = 10m, // Start new accounts with 100, we're pretty generous. }; var balance = await StateManager.GetOrAddStateAsync(&quot;balance&quot;, starting); return balance; } public async Task Withdraw(WithdrawRequest withdraw) { var starting = new AccountBalance() { AccountId = this.Id.GetId(), Balance = 10m, // Start new accounts with 100, we're pretty generous. }; var balance = await StateManager.GetOrAddStateAsync(&quot;balance&quot;, starting)!; if (balance.Balance &lt;= 0) { // Simulated reminder deposit if (Random.Shared.Next(100) &gt; 90) { await RegisterReminderAsync(&quot;Deposit&quot;, null, TimeSpan.FromSeconds(5), TimeSpan.FromMilliseconds(-1)); } } // Throws Overdraft exception if the account doesn't have enough money. var updated = this.bank.Withdraw(balance.Balance, withdraw.Amount); balance.Balance = updated; await StateManager.SetStateAsync(&quot;balance&quot;, balance); } public async Task ReceiveReminderAsync(string reminderName, byte[] state, TimeSpan dueTime, TimeSpan period) { if (reminderName == &quot;Deposit&quot;) { var balance = await StateManager.GetStateAsync&lt;AccountBalance&gt;(&quot;balance&quot;)!; if (balance.Balance &lt;= 0) { balance.Balance += 60; // 50(Overdraft Threshold) + 10 = 60 Console.WriteLine(&quot;Deposit: 10&quot;); } else { Console.WriteLine(&quot;Deposit: ignore&quot;); } } }} 运行Assignment.Server使用Dapr CLI来启动，先使用命令行工具跳转到目录 dapr-study-room\\Assignment07\\Assignment.Server，然后执行下面命令 1dapr run --app-id testactor --app-port 5000 --dapr-http-port 3500 --dapr-grpc-port 50001 dotnet run 创建Assignment.Client创建控制台项目，并添加Dapr.ActorsNuGet包引用和Assignment.Shared项目引用。 修改Program.cs 12345678910111213141516171819202122232425262728using Assignment.Shared;using Dapr.Actors;using Dapr.Actors.Client;Console.WriteLine(&quot;Creating a Bank Actor&quot;);var bank = ActorProxy.Create&lt;IBankActor&gt;(ActorId.CreateRandom(), &quot;BankActor&quot;);Parallel.ForEach(Enumerable.Range(1, 10), async i =&gt;{ while (true) { var balance = await bank.GetAccountBalance(); Console.WriteLine($&quot;[Worker-{i}] Balance for account '{balance.AccountId}' is '{balance.Balance:c}'.&quot;); Console.WriteLine($&quot;[Worker-{i}] Withdrawing '{1m:c}'...&quot;); try { await bank.Withdraw(new WithdrawRequest() { Amount = 1m }); } catch (ActorMethodInvocationException ex) { Console.WriteLine(&quot;[Worker-{i}] Overdraft: &quot; + ex.Message); } Task.Delay(1000).Wait(); }});Console.ReadKey(); 运行Assignment.Client使用Dapr CLI来启动，先使用命令行工具跳转到目录 dapr-study-room\\Assignment07\\Assignment.Client，然后执行下面命令 1dotnet run 本章源码Assignment07 https://github.com/doddgu/dapr-study-room 我们正在行动，新的框架、新的生态我们的目标是自由的、易用的、可塑性强的、功能丰富的、健壮的。 所以我们借鉴Building blocks的设计理念，正在做一个新的框架MASA Framework，它有哪些特点呢？ 原生支持Dapr，且允许将Dapr替换成传统通信方式 架构不限，单体应用、SOA、微服务都支持 支持.Net原生框架，降低学习负担，除特定领域必须引入的概念，坚持不造新轮子 丰富的生态支持，除了框架以外还有组件库、权限中心、配置中心、故障排查中心、报警中心等一系列产品 核心代码库的单元测试覆盖率90%+ 开源、免费、社区驱动 还有什么？我们在等你，一起来讨论 经过几个月的生产项目实践，已完成POC，目前正在把之前的积累重构到新的开源项目中 目前源码已开始同步到Github（文档站点在规划中，会慢慢完善起来）： MASA.BuildingBlocks MASA.Contrib MASA.Utils MASA.EShop BlazorComponent MASA.Blazor QQ群：7424099 微信群：加技术运营微信（MasaStackTechOps），备注来意，邀请进群","link":"/2021/11/15/tech-dapr-by-the-hand/7/"},{"title":"手把手教你学Dapr - 8. 绑定","text":"介绍使用绑定，您可以使用来自外部系统的事件触发您的应用程序，或与外部系统交互。这个构建块为您和您的代码提供了几个好处： 消除连接和轮询消息系统（如队列和消息总线）的复杂性 关注业务逻辑，而不是如何与系统交互的实现细节 让您的代码不受 SDK 或库的影响 处理重试和故障恢复 运行时在绑定之间切换 构建可移植的应用程序，其中设置了特定于环境的绑定，不需要更改代码 目录手把手教你学Dapr - 1. .Net开发者的大时代 手把手教你学Dapr - 2. 必须知道的概念 手把手教你学Dapr - 3. 使用Dapr运行第一个.Net程序 手把手教你学Dapr - 4. 服务调用 手把手教你学Dapr - 5. 状态管理 手把手教你学Dapr - 6. 发布订阅 手把手教你学Dapr - 7. Actors 手把手教你学Dapr - 8. 绑定 输入绑定输入绑定用于在发生来自外部资源的事件时触发您的应用程序。可选的payload和元数据可以与请求一起发送。 为了从输入绑定接收事件： 定义描述绑定类型及其元数据（连接信息等）的组件 YAML 侦听传入事件的 HTTP 端点，或使用 gRPC proto 库获取传入事件 输出绑定输出绑定允许您调用外部资源。可选的payload和元数据可以与请求一起发送。 为了调用输出绑定： 定义描述绑定类型及其元数据（连接信息等）的组件 YAML 使用 HTTP 或 gRPC 方法调用具有可选payload的绑定 使用场景使用绑定，你的代码可以被来自不同资源的传入事件触发，这些资源可以是任何东西：队列、消息传递管道、云服务、文件系统等。 这对于事件驱动处理、数据管道或只是对事件做出一般反应并进行进一步处理是理想的。 Dapr 绑定允许您： 在不包含特定 SDK 或库的情况下接收事件 在不更改代码的情况下替换绑定 专注于业务逻辑而不是事件资源实现 目前Dapr还不支持跨Dapr互调用，而yaron给出的解决方案之一就是绑定 目前绑定支持40中组件，包括Aliyun、Azure、AWS等多家云服务厂商的产品，也包括常见的如Cron, kafaka, MQTT, SMTP, Redis以及各种MQ等。 以下图片是.Net Dapr官方教程里的一个示例 配置组件本篇文章将用rabbitmq来演示（为什么不用redis，因为redis翻车了，只支持output，没注意看supported），如前几篇文章所说，先配置yaml 安装rabbitmq 1docker pull rabbitmq:3.8.25-management 运行rabbitmq 1docker run -d --hostname rabbitMQ --name my-rabbitMQ -p 15672:15672 -p 5672:5672 -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin rabbitmq:3.8.25-management Windows打开目录%USERPROFILE%\\.dapr\\components，创建binding.yaml，内容如下 12345678910111213141516171819202122232425apiVersion: dapr.io/v1alpha1kind: Componentmetadata: name: myevent namespace: defaultspec: type: bindings.rabbitmq version: v1 metadata: - name: queueName value: queue1 - name: host value: amqp://admin:admin@localhost:5672 - name: durable value: true - name: deleteWhenUnused value: false - name: ttlInSeconds value: 60 - name: prefetchCount value: 0 - name: exclusive value: false - name: maxPriority value: 5 打开浏览器，输入url：http://localhost:15672/，账号密码为admin，查看rabbitmq已经正常运行 .Net调用Dapr的绑定创建Assignment.Server创建类库项目，并添加Dapr.Actors.AspNetCoreNuGet包引用和Assignment.Shared项目引用，最后修改程序端口为5000。 修改program.cs 123456var builder = WebApplication.CreateBuilder(args);var app = builder.Build();app.MapPost(&quot;/myevent&quot;, ([Microsoft.AspNetCore.Mvc.FromBody] string word) =&gt; Console.WriteLine($&quot;Hello {word}!&quot;));app.Run(); 注：一定要用POST Method，参数记得在Body里面。默认Url与bindings的name对应。能改路由吗？当然能，看下面配置 12345spec: type: binding.rabbitmq metadata: - name: route value: /onevent 运行Assignment.Server使用Dapr CLI来启动，先使用命令行工具跳转到目录 dapr-study-room\\Assignment07\\Assignment.Server，然后执行下面命令 1dapr run --app-id testbinding --app-port 5000 --dapr-http-port 3500 --dapr-grpc-port 50001 dotnet run 验证服务端绑定配置是否成功打开浏览器，输入url：http://localhost:15672/#/queues，账号密码为admin，查看是否已经创建一个名为queue1的队列，如下图所示： 创建Assignment.Client创建控制台项目，并添加Dapr.ActorsNuGet包引用和Assignment.Shared项目引用。 修改Program.cs 123456using Dapr.Client;var client = new DaprClientBuilder().Build();await client.InvokeBindingAsync(&quot;myevent&quot;, &quot;create&quot;, &quot;World&quot;);Console.WriteLine(&quot;Binding sent.&quot;); 运行Assignment.Client使用Dapr CLI来启动，先使用命令行工具跳转到目录 dapr-study-room\\Assignment07\\Assignment.Client，然后执行下面命令 1dotnet run 本章源码Assignment08 https://github.com/doddgu/dapr-study-room 我们正在行动，新的框架、新的生态我们的目标是自由的、易用的、可塑性强的、功能丰富的、健壮的。 所以我们借鉴Building blocks的设计理念，正在做一个新的框架MASA Framework，它有哪些特点呢？ 原生支持Dapr，且允许将Dapr替换成传统通信方式 架构不限，单体应用、SOA、微服务都支持 支持.Net原生框架，降低学习负担，除特定领域必须引入的概念，坚持不造新轮子 丰富的生态支持，除了框架以外还有组件库、权限中心、配置中心、故障排查中心、报警中心等一系列产品 核心代码库的单元测试覆盖率90%+ 开源、免费、社区驱动 还有什么？我们在等你，一起来讨论 经过几个月的生产项目实践，已完成POC，目前正在把之前的积累重构到新的开源项目中 目前源码已开始同步到Github（文档站点在规划中，会慢慢完善起来）： MASA.BuildingBlocks MASA.Contrib MASA.Utils MASA.EShop BlazorComponent MASA.Blazor QQ群：7424099 微信群：加技术运营微信（MasaStackTechOps），备注来意，邀请进群","link":"/2021/11/16/tech-dapr-by-the-hand/8/"},{"title":"手把手教你学Dapr - 9. 可观测性","text":"目录手把手教你学Dapr - 1. .Net开发者的大时代 手把手教你学Dapr - 2. 必须知道的概念 手把手教你学Dapr - 3. 使用Dapr运行第一个.Net程序 手把手教你学Dapr - 4. 服务调用 手把手教你学Dapr - 5. 状态管理 手把手教你学Dapr - 6. 发布订阅 手把手教你学Dapr - 7. Actors 手把手教你学Dapr - 8. 绑定 手把手教你学Dapr - 9. 可观测性 介绍通过Tracing(跟踪)、Metrics(指标)、Logs(日志)和Health(运行状况)监控应用程序。 分布式跟踪Dapr 使用 Zipkin 协议进行分布式跟踪 和 Metrics 收集。由于 Zipkin 协议的普遍性，许多后端都是开箱即用的，例如 Stackdriver、Zipkin、New Relic 等。结合 OpenTelemetry Collector，Dapr 可以将跟踪导出到许多其他后端，包括但不限于 Azure Monitor、Datadog、Instana、Jaeger 和 SignalFX。 Tracing设计Dapr 在 Dapr Sidecar 中添加了一个 HTTP/gRPC 中间件。中间件拦截所有 Dapr 和应用程序流量，并自动注入关联 ID 以跟踪分布式事务。这种设计有几个好处： 无需代码检测。使用可配置的跟踪级别自动跟踪所有流量。 跨微服务的一致性跟踪行为。跟踪是在 Dapr Sidecar 上配置和管理的，因此它在由不同团队制作并可能用不同编程语言编写的服务之间保持一致。 可配置和可扩展。利用 Zipkin API 和 OpenTelemetry Collector，Dapr 跟踪可以配置为与流行的跟踪后端一起使用，包括客户可能拥有的自定义后端。 您可以同时定义和启用多个导出器。 W3C 关联 IDDapr 使用标准的 W3C 跟踪上下文标头。对于 HTTP 请求，Dapr 使用 traceparent 标头。对于 gRPC 请求，Dapr 使用 grpc-trace-bin 标头。当一个没有跟踪 ID 的请求到达时，Dapr 会创建一个新的。否则，它会沿着调用链传递跟踪 ID。 配置Dapr 使用概率抽样。采样率定义了对跟踪跨度进行采样的概率，其值可以介于 0 和 1（含）之间。默认采样率为 0.0001（即采样 10,000 个跨度中的 1 个）。 要更改默认跟踪行为，请使用配置文件。例如，以下配置对象将采样率更改为 1（即每个跨度都被采样），并使用 Zipkin 协议将跟踪发送到位于 http://zipkin.default.svc.cluster.local 的 Zipkin 服务器 yaml文件路径：%UserProfile%\\.dapr\\config.yaml 12345678910apiVersion: dapr.io/v1alpha1kind: Configurationmetadata: name: tracing namespace: defaultspec: tracing: samplingRate: &quot;1&quot; zipkin: endpointAddress: &quot;http://zipkin.default.svc.cluster.local:9411/api/v2/spans&quot; 注：将采样率更改为 0 会完全禁用跟踪。 W3C 跟踪上下文Dapr 使用 W3C 跟踪上下文对服务调用和发布/订阅消息进行分布式跟踪。Dapr 完成了生成和传播跟踪上下文信息的所有繁重工作，仅在极少数情况下，您需要传播或创建跟踪上下文。 W3C trace context有以下优势： 为单个跟踪和请求提供唯一标识符，允许将多个提供程序的跟踪数据链接在一起。 提供转发特定于供应商的跟踪数据的商定机制，并避免跟踪在多个工具参与单个事务时中断。 提供中间商、平台和硬件提供商可以支持的行业标准。 有两种情况需要了解如何使用跟踪： Dapr 在服务之间生成并传播跟踪上下文。 Dapr 生成跟踪上下文，您需要将跟踪上下文传播到另一个服务，或者您生成跟踪上下文，Dapr 将跟踪上下文传播到服务。 Dapr 在服务之间生成并传播跟踪上下文在某些情况下，Dapr 会为您完成所有工作。您不需要创建和传播任何跟踪标头。 Dapr 负责创建所有跟踪标头并传播它们。让我们通过示例来了解场景； 单个服务调用（服务 A -&gt; 服务 B） Dapr 在服务 A 中生成跟踪标头，这些跟踪标头从服务 A 传播到服务 B。 多个顺序服务调用（服务 A -&gt; 服务 B -&gt; 服务 C） Dapr 在服务 A 中的请求开始时生成跟踪标头，这些跟踪标头从服务 A-&gt; 服务 B -&gt; 服务 C 等传播到进一步启用 Dapr 的服务。 请求是来自外部endpoint（例如从网关服务到启用 Dapr 的服务 A） Dapr Sidecar 健康检查Dapr 提供了一种使用 HTTP /healthz endpoint来确定其健康状况的方法。有了这个endpoint，可以探测 Dapr 进程或边车的健康状况，从而确定其准备情况和活跃度。 在将 Dapr 部署到托管平台（例如 Kubernetes）时，会自动为您配置 Dapr health endpoint。您无需进行任何配置。 Health endpoint: 与 Kubernetes 集成Kubernetes 使用 readiness 和 liveness 探测来确定容器的健康状况。 kubelet使用活动探针来知道何时重新启动容器。 例如，活动探测可以捕获死锁，即应用程序正在运行，但无法取得进展。在这种状态下重新启动容器有助于使应用程序更可用，尽管存在缺陷。 kubelet 使用就绪探针来了解容器何时准备好开始接受流量。当 pod 的所有容器都准备就绪时，它就被认为是准备好了的。这种准备信号的一个用途是控制哪些Pods被用作Kubernetes服务的后端。 当 Pod 未准备好时，它将从Kubernetes服务负载均衡器中删除。 当与 Kubernetes 集成时，Dapr Sidecar 被注入了一个 Kubernetes 探针配置，告诉它使用 Dapr healthz endpoint。这是由 Sidecar Injector 系统服务完成的。与 kubelet 的集成如下图所示。 如何在 Kubernetes 中配置活性探针在 pod 配置文件中，在容器规范部分添加了 liveness 探针，如下所示： 123456livenessProbe: httpGet: path: /healthz port: 8080 initialDelaySeconds: 3 periodSeconds: 3 在上面的例子中， periodSeconds 字段指定 kubelet 应该每 3 秒执行一次活性探测。 initialDelaySeconds 字段告诉 kubelet 在执行第一次探测之前应该等待 3 秒。 注：任何大于或等于 200 且小于 400 的代码都表示成功。其他代码表示失败。 如何在 Kubernetes 中配置就绪探针就绪探针的配置类似于活性探针。唯一的区别是您使用 readinessProbe 字段而不是 livenessProbe 字段。 123456readinessProbe: httpGet: path: /healthz port: 8080 initialDelaySeconds: 3 periodSeconds: 3 如何使用 Kubernetes 配置 Dapr Sidecar health endpoint此配置由 Sidecar Injector 服务自动完成。Dapr 在端口 3500 上有它的 HTTP health endpint /v1.0/healthz，这可以与 Kubernetes 一起使用以进行就绪和活跃度探测。当注入 Dapr sidecar 时，readiness 和 liveness 探针在 pod 配置文件中配置为以下值。 12345678910111213141516livenessProbe: httpGet: path: v1.0/healthz port: 3500 initialDelaySeconds: 5 periodSeconds: 10 timeoutSeconds : 5 failureThreshold : 3readinessProbe: httpGet: path: v1.0/healthz port: 3500 initialDelaySeconds: 5 periodSeconds: 10 timeoutSeconds : 5 failureThreshold: 3 .Net中使用可观测性创建Assignment.Server创建类库项目，并添加Dapr.AspNetCore, OpenTelemetry, OpenTelemetry.Instrumentation.AspNetCore, OpenTelemetry.Instrumentation.Http,OpenTelemetry.Extensions.Hosting和OpenTelemetry.Exporter.ZipkinNuGet包引用，最后修改程序端口为5000。 !!!注：版本很重要，NuGet要打开包含预发行版，并且使用指定版本 OpenTelemetry-1.2.0-beta1 OpenTelemetry.Instrumentation.AspNetCore-1.0.0-rc8 OpenTelemetry.Instrumentation.Http-1.0.0-rc8 OpenTelemetry.Exporter.Zipkin-1.2.0-beta1 OpenTelemetry.Extensions.Hosting-1.0.0-rc8 修改program.cs 12345678910111213141516171819202122232425262728293031323334using OpenTelemetry.Resources;using OpenTelemetry.Trace;var builder = WebApplication.CreateBuilder(args);builder.Services.AddOpenTelemetryTracing((tracerProviderBuilder) =&gt; tracerProviderBuilder .SetResourceBuilder(ResourceBuilder.CreateDefault().AddService(&quot;testobservability&quot;)) .AddAspNetCoreInstrumentation() .AddHttpClientInstrumentation() .AddZipkinExporter(zipkinOptions =&gt; { zipkinOptions.Endpoint = new Uri(&quot;http://localhost:9411/api/v2/spans&quot;); } ));var app = builder.Build();app.Map(&quot;/Amazing&quot;, async (HttpContext context) =&gt;{ if (context.Request.Headers.TryGetValue(&quot;traceparent&quot;, out var traceparent)) { Console.WriteLine($&quot;TraceParent: {traceparent}&quot;); } if (context.Request.Headers.TryGetValue(&quot;tracestate&quot;, out var tracestate)) { Console.WriteLine($&quot;TraceState: {tracestate}&quot;); } System.Diagnostics.Activity.Current?.SetParentId(traceparent.ToString()); _ = await new HttpClient().GetStringAsync(&quot;https://www.baidu.com&quot;); Console.WriteLine($&quot;Invoke succeed: traceID:{traceparent}&quot;);});app.Run(); 可以看到我们直接演示了一个好玩的用法，就是开启.Net的OpenTelemetry，然后修改Diagnostics.Activity的ParentId，让当前的Tracing跟Dapr Sidecar传来的TraceId一致。 运行Assignment.Server使用Dapr CLI来启动，先使用命令行工具跳转到目录 dapr-study-room\\Assignment07\\Assignment.Server，然后执行下面命令 1dapr run --app-id testobservability --app-port 5000 --dapr-http-port 3500 --dapr-grpc-port 50001 dotnet run 使用Dapr CLI发个命令看看 1dapr invoke --app-id testobservability --method /Amazing 打开Zipkin，地址：http://localhost:9411/, 来看一下Zipkin的Tracing，不单有Dapr Sidecar的请求记录进来了，还跟HttpClient的捆绑在了起来，是的，有趣的就在这里。 除了可以跟踪HttpClient以外，还有EF Core等都集成了。 至于Metrics和Logs集成也是非常简单，需要搭配不同的后端如Prometheus, Fluentd等。甚至可以通过自定义Exporter自行对接一些云厂商的云服务。 本章源码Assignment09 https://github.com/doddgu/dapr-study-room 我们正在行动，新的框架、新的生态我们的目标是自由的、易用的、可塑性强的、功能丰富的、健壮的。 所以我们借鉴Building blocks的设计理念，正在做一个新的框架MASA Framework，它有哪些特点呢？ 原生支持Dapr，且允许将Dapr替换成传统通信方式 架构不限，单体应用、SOA、微服务都支持 支持.Net原生框架，降低学习负担，除特定领域必须引入的概念，坚持不造新轮子 丰富的生态支持，除了框架以外还有组件库、权限中心、配置中心、故障排查中心、报警中心等一系列产品 核心代码库的单元测试覆盖率90%+ 开源、免费、社区驱动 还有什么？我们在等你，一起来讨论 经过几个月的生产项目实践，已完成POC，目前正在把之前的积累重构到新的开源项目中 目前源码已开始同步到Github（文档站点在规划中，会慢慢完善起来）： MASA.BuildingBlocks MASA.Contrib MASA.Utils MASA.EShop BlazorComponent MASA.Blazor QQ群：7424099 微信群：加技术运营微信（MasaStackTechOps），备注来意，邀请进群","link":"/2021/11/17/tech-dapr-by-the-hand/9/"},{"title":"1. 堪比JMeter的.Net压测工具 - Crank 入门篇","text":"1. 前言Crank 是.NET 团队用来运行基准测试的基准测试基础架构，包括（但不限于）来自TechEmpower Web 框架基准测试的场景,是2021年.NET Conf 大会上介绍的一项新的项目，其前身是Benchmarks。 Crank目标之一是为开发人员提供一种工具，让他们能够非常轻松地处理性能并衡量潜在的改进。其中一些功能是： 部署和基准测试基于 .NET 或 Docker 容器的多层应用程序 通过指定.Net项目(本地路径或git远程仓库地址)，支持直接部署或通过Docker部署应用程序，用于基准测试） 通过Yml配置，不仅仅支持结果存储在 JSON 、SQL Server 中还支持存储到csv文件中以用于图表 目前有小伙伴已经在提议将支持存储在es 支持更改自定义应用程序的Franework环境，测试在不同环境下的性能 收集诊断跟踪信息 2. 核心组成Crank由Agent、Controller两部分组成 Controller是任务的调度者，可以调度负载任务以及输出结果 Agent是基准代理，任务的实际执行者，接收来自Controller的任务并执行。 3. 安装欲先工其善 必先利其器，我们先学习下如何安装crank，以及如何验证是否安装成功 3.1. 准备工作 安装 .NET 5.0. 打开shell：安装Crank Controller 安装命令： 1dotnet tool update Microsoft.Crank.Controller --version &quot;0.2.0-alpha.21567.1&quot; --global 验证命令： 1crank 打开shell: 安装Crank Agent 安装命令： 1dotnet tool update Microsoft.Crank.Agent --version &quot;0.2.0-alpha.21567.1&quot; --global 验证命令： 1crank-agent 3.2. 小结为方便阅读、文章中Crank Controller简称Crank，Crank Agent简称Agent Agent以及Crank需要根据实际情况安装，可分以下几种情况: 只是为了学习Crank，没有单独的测试环境，则需要分别安装Agent、Controller Agent有单独提供测试环境，则本地不需要安装Agent，只安装Controller即可 Agent有单独提供测试环境，且压测任务由ci来触发执行，则本地不需要安装任何配置，通过构建ci任务完成压力计划即可 打开shell：查看Agent、Controller版本 1dotnet tool list -g 4. 基础知识4.1. variables: 参数variables分为局部参数与全局参数两种类型，在根节点的为全局参数，在其他节点下的是局部参数。 例： hello.benchmarks.yml &gt; scenarios &gt; hello-load &gt; variables节点下的serverPort以及path以及profiles&gt;local&gt;variables节点下的serverAddress是局部参数 1234567891011121314scenarios: hello: application: job: server load: job: bombardier variables: serverPort: 5000 path: /profiles: local: variables: serverAddress: localhost bombardier.yml &gt; variables &gt; headers为全局参数 12345678variables: headers: none: '' plaintext: '--header &quot;Accept: text/plain,text/html;q=0.9,application/xhtml+xml;q=0.9,application/xml;q=0.8,*/*;q=0.7&quot; --header &quot;Connection: keep-alive&quot;' html: '--header &quot;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot; --header &quot;Connection: keep-alive&quot;' json: '--header &quot;Accept: application/json,text/html;q=0.9,application/xhtml+xml;q=0.9,application/xml;q=0.8,*/*;q=0.7&quot; --header &quot;Connection: keep-alive&quot;' connectionclose: '--header &quot;Connection: close&quot;' --------------------------------------------------------------------- 4.2. profiles: 配置profiles其实就是配置文件信息，profiles允许被多次使用，这点在可以在文档中找到对应介绍。 123456789Usage: crank [options]Options: -?|-h|--help Show help information These options are not specific to a Job ---------------------------------------------------------------------- --profile &lt;profile&gt; Profiles to apply. Can be used multiple times. 命名规则: 建议 *.profiles.yml 4.3. jobs: 任务将我们要做的事定义为一个job。方便之后重用。此处的事指的是一类事，而不是指特定的某件事。 例如：微软内置定义的bombardier就是一个job，这个job是通过bombardier对其进行基准测试，并将结果记录并输出，而具体针对哪个接口进行基准测试其实并不关心。 job根据应用程序源有分为远程、本地两种。 本地源： 123456jobs: server: #任务名称，可根据任务作用自行命名 source: #任务源 localFolder: ../hello project: hello.csproj #要构建的 .NET 项目的文件名 readyStateText: Application started. #控制台中通知服务器它已启动的文本 本地源localFolder针对当前运行crank –config执行命令所在的相对路径即可，任务开始后会将本地的项目发送到agent后再执行任务。 远程源 1234567jobs: server: source: repository: https://github.com/dotnet/crank branchOrCommit: main #远程源执行任务的分支 project: samples/hello/hello.csproj #要构建的 .NET 项目的文件名，格式：相对根的相对路径+项目名.csproj readyStateText: Application started. 远程源会将仓库信息发送到Agent，Agent会先将仓库下载下来并切换到指定的分支后再执行构建任务启动项目 4.4. scenarios: 场景job关心的是一类事，而特定的事情并不关心，那具体的事是谁比较关心呢，没错那就是场景，也就是scenarios，scenarios通过多个job来完成对指定场景的基准测试，做的是具体任务的编排 4.5. imports: 导入imports为我们提供了yml重用的可能，因为有imports的支持，我们才可以将公共的yml提取到一个单独的yml中，通过imports将使用到的yml导入即可，与js、css的导入有异曲同工之妙 4.6. 小结 在crank中，variables、profiles都不是必须的，但因为它们的存在，才使得我们可以以面向对象的思想开发，可以通过新增变量或指定配置完成基准测试，这块后面的实战中会有详细解释 5. 入门经过之前的学习，我们对crank的基本配置也有了一定的了解，那接下来的时间，我们先试着学习下官方已经给我们准备好的Sample，下面的教程也会详细讲解一下各个配置的作用，希望能通过下面的学习了解到Crank的工作基本原理 5.1. 启动Agent 1crank-agent --dotnethome &quot;/home/{your-account}/dotnet&quot; 5.1.0.1. 启动Agent并指定dotnet环境 格式：crank-agent –dotnethome “dotnet安装地址” crank-agent –dotnethome “C:\\Program Files\\dotnet” (windows) crank-agent –dotnethome “/usr/share/dotnet” (Linux) 在启动agent时，强烈建议大家增加dotnethome 配置，为agent运行指定环境，以免运行任务时由于环境问题而卡在install sdk这里 因演示机器本地dotnet的使用的是安装路径为/home/gushoudao/dotnet，所以视频中运行的命令有所不同，这块还需要根据本地的实际情况自行调整路径即可 (因视频录制原因，在录制结束后会停止agent，我们真实使用中启动后不需要退出，一旦退出agent，就无法执行任务) 5.1.0.2. 启动Agent并指定不清理临时文件 crank-agen –no-cleanup (指定不清理临时文件) 默认agent执行任务结束后会删除当前任务执行过程中产生的临时文件 5.1.0.3. 启动Agent并指定构建任务的最大持续时间 crank-agent –build-timeout 默认构建任务的最大持续时间为10 minutes 更多配置点击查看 5.2. 新建hello.benchmarks.yml配置配置文件源码来自hello.benchmarks.yml 1234567891011121314151617181920212223242526272829303132imports: - https://raw.githubusercontent.com/doddgu/crank/sample/src/Microsoft.Crank.Jobs.Bombardier/bombardier.ymljobs: server: source: repository: https://github.com/doddgu/crank branchOrCommit: sample project: samples/hello/hello.csproj readyStateText: Application started.scenarios: hello: application: job: server load: job: bombardier variables: serverPort: 5000 path: /profiles: local: variables: serverAddress: localhost jobs: application: endpoints: - http://localhost:5010 load: endpoints: - http://localhost:5010 5.3. 启动任务启动agent（打开放在一边）： 1crank-agent --dotnethome &quot;/usr/share/dotnet&quot; 启动任务（另起一个新的Shell）： 1234git clone https://github.com/doddgu/crank.gitcd crankgit checkout samplecrank --config ./samples/hello/hello.original.benchmarks.yml --scenario hello --load.framework net5.0 --application.framework net5.0 然后我们等待片刻会输出以下结果 crank-agent： crank： 12345678910111213141516171819| load | || --------------------- | -------------- || CPU Usage (%) | 39 | CPU使用率| Cores usage (%) | 631 | 多核CPU使用率| Working Set (MB) | 35 | 内存使用率| Private Memory (MB) | 35 | 进程使用的私有内存量| Build Time (ms) | 4,853 | 构建应用程序需要多长时间（毫秒）| Start Time (ms) | 386 | 启动应用程序需要多长时间（毫秒）| Published Size (KB) | 66,731 | 已发布应用程序的大小 (KB)| .NET Core SDK Version | 5.0.403 | .Net Core SDK 版本| ASP.NET Core Version | 5.0.12+0bc3c37 | .Net Core版本| .NET Runtime Version | 5.0.12+7211aa0 | .Net运行时版本| First Request (ms) | 172 | 第一个请求耗时（这里请求是Get）| Requests | 2,086,594 | 总发送请求数| Bad responses | 0 | 糟糕请求数（响应状态码不是2**也不是3**）| Mean latency (us) | 1,833 | 平均延迟时间| Max latency (us) | 89,001 | 最大延迟时间| Requests/sec | 138,067 | 每秒支持请求数| Requests/sec (max) | 255,442 | 每秒最大支持请求数 当你能输出以上信息的时候，证明了你已经成功跑通了整个流程 在上面我们可以很清楚的看到场景hello下的测试结果，其中包含CPU使用率、多核CPU的使用率、内存使用率以及每秒执行的请求数等等指标 在这一刻是不是突然觉得这个crank挺强大的，虽然还不清楚具体是咋做到的，但是真的很赞！！在这一刻是不是对它来了兴趣，想知道它到底可以做什么，为什么可以输出以上的结果？ 6. 结尾为确保后续不会因更新导致按照文档操作不可用，源码从官方源Fork了一份，其中绝大多数来自官方提供的Sample、部分文件为了更好的满足个人习惯，会在一定程度上进行调整。 源码地址：https://github.com/doddgu/crank/tree/sample 参考链接： https://github.com/dotnet/crank https://github.com/aspnet/Benchmarks https://www.youtube.com/watch?v=2IgfrnG-128 开源地址MASA.BuildingBlocks：https://github.com/masastack/MASA.BuildingBlocks MASA.Contrib：https://github.com/masastack/MASA.Contrib MASA.Utils：https://github.com/masastack/MASA.Utils MASA.EShop：https://github.com/masalabs/MASA.EShop MASA.Blazor：https://github.com/BlazorComponent/MASA.Blazor 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们","link":"/2022/02/23/independent/crank/1.%20basics/"},{"title":"2. 堪比JMeter的.Net压测工具 - Crank 进阶篇 - 认识yml","text":"1. 前言入门篇我们已经成功运行hello.benchmarks.yml并输出测试结果，本篇我们就hello.benchmarks.yml、以及运行的shell脚本详细解读下其中的含义 2. 剖析hello.benchmarks.yml2.1. job 在hello.benchmarks.yml中我们定义了一个新的job: server，并指定了仓库信息 ( 远程仓库 )： 123repository：https://github.com/doddgu/crank.git # 仓库源branchOrCommit：sample # 分支project: samples/hello/hello.csproj # 项目 并通过import导入了bombardier.yml，其中定义了另外一个job: bombardier，并指定了仓库信息 ( 远程仓库 ): 12345repository: https://github.com/doddgu/crank.gitbranchOrCommit: sampleproject: src/Microsoft.Crank.Jobs.Bombardier/Microsoft.Crank.Jobs.Bombardier.csprojsourceKey: bombardier # 服务器使用它来重用相同的源文件夹。noBuild: true # 定义 SourceKey时，指示是否仍应进行构建 2.2. scenarios 在hello.benchmarks.yml中我们定义了场景: hello，并为此场景指定了两个任务: 第一个任务名为application，使用的是项目server 第二个任务名为load，并指定使用项目bombardier 2.3. variables 变量 在bombardier.yml中 定义了全局变量: headers、presetHeaders（预设header） 定义了局部变量: connections、warmup、duration、requests、rate、transport、serverScheme等等 在hello.benchmarks.yml中为load定义了局部变量serverPort、path 2.4. profiles 配置 在hello.benchmarks.yml中我们 定义了配置local 并指定了局部变量: serverAddress = localhost 为任务application、load指定了部署作业的endpoint 是 http://localhost:5010 （指定执行任务的Agent地址） 2.5. arguments 参数 在bombardier.yml中与variables同级的配置: arguments，此参数是在启动job后传递的参数，其中定义的全局参数、局部参数信息也都是为构建完整的参数做准备，bombardier真实的参数信息是: 1-c {{connections}} -w {{warmup}} -d {{duration}} -n {{requests}} --insecure -l {% if rate != 0 %} --rate {{ rate }} {% endif %} {% if transport %} --{{ transport}} {% endif %} {{headers[presetHeaders]}} {% for h in customHeaders %}{% assign s = h | split : ':' %}--header \\&quot;{{ s[0] }}: {{ s[1] | strip }}\\&quot; {% endfor %} {% if serverUri == blank or serverUri == empty %} {{serverScheme}}://{{serverAddress}}:{{serverPort}}{{path}} {% else %} {{serverUri}}:{{serverPort}}{{path}} {% endif %} {% if bodyFile != blank and bodyFile != empty %} -f {{bodyFile}} {% endif %} {% if verb != blank and verb != empty %} -m {{verb}} {% endif %} 3. 改造hello.benchmarks.yml改造hello.benchmarks.yml，不考虑重用，最原始的代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657variables: headers: none: '' plaintext: '--header &quot;Accept: text/plain,text/html;q=0.9,application/xhtml+xml;q=0.9,application/xml;q=0.8,*/*;q=0.7&quot; --header &quot;Connection: keep-alive&quot;' html: '--header &quot;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot; --header &quot;Connection: keep-alive&quot;' json: '--header &quot;Accept: application/json,text/html;q=0.9,application/xhtml+xml;q=0.9,application/xml;q=0.8,*/*;q=0.7&quot; --header &quot;Connection: keep-alive&quot;' connectionclose: '--header &quot;Connection: close&quot;' presetHeaders: nonejobs: bombardier: source: repository: https://github.com/dotnet/crank.git branchOrCommit: main project: src/Microsoft.Crank.Jobs.Bombardier/Microsoft.Crank.Jobs.Bombardier.csproj sourceKey: bombardier noBuild: true readyStateText: Bombardier Client waitForExit: true variables: connections: 256 warmup: 15 duration: 15 requests: 0 rate: 0 transport: fasthttp # | http1 | http2 serverScheme: http serverAddress: localhost serverPort: 5000 path: bodyFile: # path or url for a file to use as the body content verb: # GET when nothing is specified customHeaders: [ ] # list of headers with the format: '&lt;name1&gt;: &lt;value1&gt;', e.g. [ 'content-type: application/json' ] arguments: &quot;-c {{connections}} -w {{warmup}} -d {{duration}} -n {{requests}} --insecure -l {% if rate != 0 %} --rate {{ rate }} {% endif %} {% if transport %} --{{ transport}} {% endif %} {{headers[presetHeaders]}} {% for h in customHeaders %}{% assign s = h | split : ':' %}--header \\&quot;{{ s[0] }}: {{ s[1] | strip }}\\&quot; {% endfor %} {% if serverUri == blank or serverUri == empty %} {{serverScheme}}://{{serverAddress}}:{{serverPort}}{{path}} {% else %} {{serverUri}}:{{serverPort}}{{path}} {% endif %} {% if bodyFile != blank and bodyFile != empty %} -f {{bodyFile}} {% endif %} {% if verb != blank and verb != empty %} -m {{verb}} {% endif %}&quot; onConfigure: # - job.timeout = Number(job.variables.duration) + Number(job.variables.warmup) + 10; endpoints: - http://localhost:5010 server: source: repository: https://github.com/doddgu/crank branchOrCommit: sample project: samples/hello/hello.csproj readyStateText: Application started. endpoints: - http://localhost:5010scenarios: hello: application: job: server load: job: bombardier variables: serverPort: 5000 path: / 4. 解读crank shell之前我们通过shell执行： crank –config hello.benchmarks.yml –scenario hello –profile local –load.framework net5.0 –application.framework net5.0 其中crank 是固定的、代表：Crank Controller –config：固定的配置，指执行哪个yml配置，每次仅能指定一个yml配置 –scenario：固定的配置，设置场景是hello –profile：固定的配置，非必选，可多次设置，指定当前Crank命令申请的配置是local，使用local下配置的所有信息 –load.framework: 格式：&lt;任务名&gt;.framework，为任务load指定framework的运行框架版本是net5.0、–application.framework同理 改造hello.benchmarks.yml，因为移除了profile，所以执行: crank –config hello.yml –scenario hello –load.framework net5.0 –application.framework net5.0 即可 查看crank更多文档 5. 疑问 为什么启动crank时要增加–application.framework net5.0？ 安装crank要求必须有net5.0的环境，所以指定net5.0不需要再单独安装框架环境 为什么启动crank时不指定framework时默认是netcore3.1呢？ 使用记事本打开hello.csproj、Microsoft.Crank.Jobs.Bombardier.csproj 即可了解 scenarios节点下application以及load两个节点名称可以更换吗？只能有两个节点？ 节点名称不固定，可以更换，也没有限制必须是两个节点，具体多少个节点根据自己的需要来 6. 结尾通过上面的学习，我们也已经完全的了解了各配置的作用，但对bombardier.yml与开源项目bombardier存在什么样的联系还不清楚，以及为什么叫做bombardier.yml而不是其他名字，并且是如何实现性能指标的输出，接下来就会讲到bombardier.yml与开源项目bombardier的关系，以及wrk.yml与wrk的关系 源码地址：https://github.com/doddgu/crank/tree/sample 开源地址MASA.BuildingBlocks：https://github.com/masastack/MASA.BuildingBlocks MASA.Contrib：https://github.com/masastack/MASA.Contrib MASA.Utils：https://github.com/masastack/MASA.Utils MASA.EShop：https://github.com/masalabs/MASA.EShop MASA.Blazor：https://github.com/BlazorComponent/MASA.Blazor 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们","link":"/2022/02/24/independent/crank/2.%20advancement/"},{"title":"3. 堪比JMeter的.Net压测工具 - Crank 进阶篇 - 认识bombardier","text":"1. 前言通过之前的学习，我们已经了解了各参数以及配置的意义，接下来的文章我们分别从bombardier以及wrk入手，进一步了解彼此之间的联系 2. 认识 bombardierbombardier 是一个 HTTP(S) 基准测试工具。它是用 Go 编程语言编写的，并使用优秀的fasthttp代替 Go 的默认 http 库，因为它具有闪电般的快速性能，详细文档查看 其支持参数： 12345678910111213141516171819202122232425262728293031323334353637383940-c, --connections=125 Maximum number of concurrent connections-t, --timeout=2s Socket/request timeout-l, --latencies Print latency statistics-m, --method=GET Request method-b, --body=&quot;&quot; Request body-f, --body-file=&quot;&quot; File to use as request body-s, --stream Specify whether to stream body using chunked transfer encoding or to serve it from memory --cert=&quot;&quot; Path to the client's TLS Certificate --key=&quot;&quot; Path to the client's TLS Certificate Private Key-k, --insecure Controls whether a client verifies the server's certificate chain and host name-H, --header=&quot;K: V&quot; ... HTTP headers to use(can be repeated)-n, --requests=[pos. int.] Number of requests-d, --duration=10s Duration of test-r, --rate=[pos. int.] Rate limit in requests per second --fasthttp Use fasthttp client --http1 Use net/http client with forced HTTP/1.x --http2 Use net/http client with enabled HTTP/2.0-p, --print=&lt;spec&gt; Specifies what to output. Comma-separated list of values 'intro' (short: 'i'), 'progress' (short: 'p'), 'result' (short: 'r'). Examples: * i,p,r (prints everything) * intro,result (intro &amp; result) * r (result only) * result (same as above)-q, --no-print Don't output anything-o, --format=&lt;spec&gt; Which format to use to output the result. &lt;spec&gt; is either a name (or its shorthand) of some format understood by bombardier or a path to the user-defined template, which uses Go's text/template syntax, prefixed with 'path:' string (without single quotes), i.e. &quot;path:/some/path/to/your.template&quot; or &quot;path:C:\\some\\path\\to\\your.template&quot; in case of Windows. Formats understood by bombardier are: * plain-text (short: pt) * json (short: j) 并且bombardier支持多平台，可以在Windows、Linux、OSX系统上运行，那接下来我们使用bombardier测试一下百度的压测情况 安装（WSL-Ubuntu）： 12sudo apt install wgetsudo wget https://github.com/codesenberg/bombardier/releases/download/v1.2.5/bombardier-linux-arm64 运行： 1./bombardier-linux-arm64 -c 200 -d 1s --insecure -l https://www.baidu.com --print r --format json 其中: req1xx代表http响应码为1** req2xx代表http响应码为2** req3xx代表http响应码为3** req4xx代表http响应码为4** req5xx代表http响应码为5** result.rps.mean代表每秒请求数 result.rps.max代表每秒最大请求数 result.latency.mean代表每毫秒延迟 result.latency.max代表每毫秒最大延迟 3. 了解Microsoft.Crank.Jobs.Bombardier在Microsoft.Crank.Jobs.Bombardier项目中Program.cs 根据参数获取-w、-d、-n、-f参数信息 校验压测时长、请求数等参数信息 判断当前运行环境是Windows、Linux、OSX，根据环境下载对应的bombardier，并根据传递的 根据yml参数最后拼装bombardier的原始命令: bombardier -c 200 -d 1s –insecure -l https://www.baidu.com –print r –format json 将输出的结果使用追加到stringBuilder上，再赋值给output 通过JObject.Parse解析指标，最后通过BenchmarksEventSource存储并输出到控制台或数据库、csv、json中 其中 请求总数 = req1xx + req2xx + req3xx + req4xx + req5xx + others 成功请求数 = req2xx + req3xx 失败请求数 = 请求总数 - 成功请求数 1234567891011121314151617181920212223242526272829303132333435363738BenchmarksEventSource.Register(&quot;bombardier/requests;http/requests&quot;, Operations.Max, Operations.Sum, &quot;Requests&quot;, &quot;Total number of requests&quot;, &quot;n0&quot;);BenchmarksEventSource.Register(&quot;bombardier/badresponses;http/requests/badresponses&quot;, Operations.Max, Operations.Sum, &quot;Bad responses&quot;, &quot;Non-2xx or 3xx responses&quot;, &quot;n0&quot;);BenchmarksEventSource.Register(&quot;bombardier/latency/mean;http/latency/mean&quot;, Operations.Max, Operations.Avg, &quot;Mean latency (us)&quot;, &quot;Mean latency (us)&quot;, &quot;n0&quot;);BenchmarksEventSource.Register(&quot;bombardier/latency/max;http/latency/max&quot;, Operations.Max, Operations.Max, &quot;Max latency (us)&quot;, &quot;Max latency (us)&quot;, &quot;n0&quot;);BenchmarksEventSource.Register(&quot;bombardier/rps/mean;http/rps/mean&quot;, Operations.Max, Operations.Sum, &quot;Requests/sec&quot;, &quot;Requests per second&quot;, &quot;n0&quot;);BenchmarksEventSource.Register(&quot;bombardier/rps/max;http/rps/max&quot;, Operations.Max, Operations.Sum, &quot;Requests/sec (max)&quot;, &quot;Max requests per second&quot;, &quot;n0&quot;);BenchmarksEventSource.Register(&quot;bombardier/throughput;http/throughput&quot;, Operations.Max, Operations.Sum, &quot;Read throughput (MB/s)&quot;, &quot;Read throughput (MB/s)&quot;, &quot;n2&quot;);BenchmarksEventSource.Register(&quot;bombardier/raw&quot;, Operations.All, Operations.All, &quot;Raw results&quot;, &quot;Raw results&quot;, &quot;json&quot;);var total = document[&quot;result&quot;][&quot;req1xx&quot;].Value&lt;long&gt;() + document[&quot;result&quot;][&quot;req2xx&quot;].Value&lt;long&gt;() + document[&quot;result&quot;][&quot;req3xx&quot;].Value&lt;long&gt;() + document[&quot;result&quot;][&quot;req3xx&quot;].Value&lt;long&gt;() + document[&quot;result&quot;][&quot;req4xx&quot;].Value&lt;long&gt;() + document[&quot;result&quot;][&quot;req5xx&quot;].Value&lt;long&gt;() + document[&quot;result&quot;][&quot;others&quot;].Value&lt;long&gt;();var success = document[&quot;result&quot;][&quot;req2xx&quot;].Value&lt;long&gt;() + document[&quot;result&quot;][&quot;req3xx&quot;].Value&lt;long&gt;();BenchmarksEventSource.Measure(&quot;bombardier/requests;http/requests&quot;, total);BenchmarksEventSource.Measure(&quot;bombardier/badresponses;http/requests/badresponses&quot;, total - success);BenchmarksEventSource.Measure(&quot;bombardier/latency/mean;http/latency/mean&quot;, document[&quot;result&quot;][&quot;latency&quot;][&quot;mean&quot;].Value&lt;double&gt;());BenchmarksEventSource.Measure(&quot;bombardier/latency/max;http/latency/max&quot;, document[&quot;result&quot;][&quot;latency&quot;][&quot;max&quot;].Value&lt;double&gt;());BenchmarksEventSource.Measure(&quot;bombardier/rps/max;http/rps/max&quot;, document[&quot;result&quot;][&quot;rps&quot;][&quot;max&quot;].Value&lt;double&gt;());BenchmarksEventSource.Measure(&quot;bombardier/rps/mean;http/rps/mean&quot;, document[&quot;result&quot;][&quot;rps&quot;][&quot;mean&quot;].Value&lt;double&gt;());BenchmarksEventSource.Measure(&quot;bombardier/raw&quot;, output);var bytesPerSecond = document[&quot;result&quot;][&quot;bytesRead&quot;].Value&lt;long&gt;() / document[&quot;result&quot;][&quot;timeTakenSeconds&quot;].Value&lt;double&gt;();// B/s to MB/sBenchmarksEventSource.Measure(&quot;bombardier/throughput&quot;, bytesPerSecond / 1024 / 1024); 4. 解读bombardier.yml各参数作用 connections: 最大并发连接数，默认: 256 warmup: 预热时间，默认15s，与执行duration类似，而并非压测次数 当warmup &gt; 0时，会先预热warmup秒后再执行一次压测，第二次的压测才是最后返回的结果 当warmup = 0时，不进行预热，直接开始压测 duration: 测试时长，单位: s requests: 请求数 rate: 每秒请求数限制 transport: 传输方式。默认: fasthttp 、支持fasthttp、http1、http2三种 presetHeaders: 预设header，根据全局参数headers，自选其一即可，选择json，那请求的header即为: –header “Accept: application/json,text/html;q=0.9,application/xhtml+xml;q=0.9,application/xml;q=0.8,/;q=0.7” –header “Connection: keep-alive” customHeaders: 自定义headers，如果预设headers中没有需要的header，则通过重写customHeaders，以完成自定义header的目的 serverUri: 自定义url，如果此参数存在，则请求地址为: {serverUri}:{serverPort}{path} serverPort: 服务端口 serverScheme: 服务的Scheme，默认http、支持http、https两种 serverAddress: 服务地址、不包含http、例如: www.baidu.com，如果serverUri存在，此配置无效，如果不存在，请求格式为: {serverScheme}://{serverAddress}:{serverPort}{path} path: 服务接口地址，不包含域，例如: /api/check/healthy bodyFile: body内容，仅在非Get请求时使用，支持远程路径与本地绝对路径（Agent服务的绝对地址，非Controller端的绝对地址） verb: 请求方式: 默认GET、支持POST、PUT、DELETE、PATCH、GET 5. 总结优势: 跨平台 用法简单 使用go语言开发、性能高 劣势: 不支持动态参数 不支持多个接口同时压测 bombardier.yml的存在是为Microsoft.Crank.Jobs.Bombardier提供配置参数，Microsoft.Crank.Jobs.Bombardier通过调用开源项目bombardier实现压测，并将压测结果通过BenchmarksEventSource存储并输出到控制台或数据库、csv、json中 源码地址：https://github.com/doddgu/crank/tree/sample 开源地址MASA.BuildingBlocks：https://github.com/masastack/MASA.BuildingBlocks MASA.Contrib：https://github.com/masastack/MASA.Contrib MASA.Utils：https://github.com/masastack/MASA.Utils MASA.EShop：https://github.com/masalabs/MASA.EShop MASA.Blazor：https://github.com/BlazorComponent/MASA.Blazor 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们","link":"/2022/02/25/independent/crank/3.%20advancement%202/"},{"title":"4. 堪比JMeter的.Net压测工具 - Crank 进阶篇 - 认识wrk、wrk2","text":"1. 前言上一篇文章我们了解了bombardier，并知道了bombardier.yml与开源项目bombardier的关系，接下来的文章我们了解一下wrk、wrk2，并对比一下它们与bombardier的关系 2. 认识wrkwrk是一种现代 HTTP 基准测试工具，能够在单个多核 CPU 上运行时产生大量负载。它结合了多线程设计和可扩展的事件通知系统，例如 epoll 和 kqueue。 其支持参数： 123456789101112131415-c, --connections: total number of HTTP connections to keep open with each thread handling N = connections/threads-d, --duration: duration of the test, e.g. 2s, 2m, 2h-t, --threads: total number of threads to use-s, --script: LuaJIT script, see SCRIPTING-H, --header: HTTP header to add to request, e.g. &quot;User-Agent: wrk&quot; --latency: print detailed latency statistics --timeout: record a timeout if a response is not received within this amount of time. 基础用法： 运行了30秒的基准测试, 使用2个线程、100个http连接: 1wrk -t2 -c100 -d30s http://127.0.0.1:8080/index.html 进阶用法: 每次发送三个http请求: 1wrk -t2 -c100 -d30s --script ./pipeline.lua http://127.0.0.1:8080 新建pipeline.lua 1234567891011121314-- example script demonstrating HTTP pipelininginit = function(args) local r = {} r[1] = wrk.format(nil, &quot;/?foo&quot;) r[2] = wrk.format(nil, &quot;/?bar&quot;) r[3] = wrk.format(nil, &quot;/?baz&quot;) req = table.concat(r)endrequest = function() return reqend 3. 认识wrk2wrk2是一个主要基于 wrk 的 HTTP 基准测试工具。是一个被 wrk 修改以产生恒定的吞吐量负载，并将延迟细节精确到高 9s（即当运行足够长的时间时可以产生准确的 99.9999%’ile）。除了 wrk 的参数之外，wrk2 通过 –rate 或 -R 参数（默认为 1000）采用吞吐量参数（每秒总请求数） 除支持wrk的参数之外，还支持参数： 1-R, --rate: 采用吞吐量参数（每秒总请求数）,默认为1000 基础用法： 运行了30秒的基准测试, 使用2个线程、100个http连接、并保持每秒2000个请求的恒定吞吐量: 1wrk -t2 -c100 -d30s -R2000 http://127.0.0.1:8080/index.html 高级用法与wrk一致，此处忽略不写 我们使用wrk2测试一下百度的压测情况 安装： 12sudo apt install wgetsudo wget https://aspnetbenchmarks.blob.core.windows.net/tools/wrk2 运行： 1./wrk2 -d 3s -c 200 -t 200 -R 10 -L https://www.baidu.com 输出了本次请求每秒请求次数、吞吐量以及详细情况： Requests/sec: 每秒请求次数 Transfer/sec: 每秒吞吐量 4. 了解Microsoft.Crank.Jobs.Wrk在Microsoft.Crank.Jobs.Wrk项目中Program.cs 检查平台是否是64位的Linux系统、并检查参数是否满足要求 通过HttpClient发送请求，并记录第一次发送请求所消耗的时间 下载wrk，并设置wrk是可执行的 通过yml传递过来的参数构建完整的wrk命令 将输出的结果使用追加到stringBuilder上，再赋值给output， 通过正则匹配结果，最后通过BenchmarksEventSource存储并输出到控制台或数据库、csv、json中 其中: connections: 每个线程处理时保持打开的 HTTP 连接总数 N = 连接数/线程数 serverUri: 自定义url，如果此参数存在，则请求地址为: {serverUri}:{serverPort}{path} serverPort: 服务端口 serverScheme: 服务的Scheme，默认http、支持http、https两种 serverAddress: 服务地址、不包含http、例如: www.baidu.com，如果serverUri存在，此配置无效，如果不存在，请求格式为: {serverScheme}://{serverAddress}:{serverPort}{path} path: 服务接口地址，不包含域，例如: /api/check/healthy warmup: 预热时间，默认15s，与执行duration类似，而并非压测次数 当warmup &gt; 0时，会先预热warmup秒后再执行一次压测，第二次的压测才是最后返回的结果 当warmup = 0时，不进行预热，直接开始压测 duration: 测试时长，默认15s threads: 线程数、默认：32 customHeaders: 自定义headers，如果预设headers中没有需要的header，则通过重写customHeaders，以完成自定义header的目的 pipeline: 管道数量，默认为1，当大于1时，支持同时发送多个请求 script: 如果pipeline不大于1时，支持自定义lua脚本以及lua参数{scriptArguments} 5. 总结优势: 支持lua脚本，支持动态参数或者更改请求等复杂操作 使用C语言开发、性能高 劣势: lua脚本存在学习成本 wrk.yml的存在是为Microsoft.Crank.Jobs.Wrk提供配置参数，Microsoft.Crank.Jobs.Wrk通过调用开源项目wrk实现压测，并将压测结果通过BenchmarksEventSource存储并输出到控制台或数据库、csv、json中 wrk2是基于wrk二次开发，拥有所有wrk的配置，并且支持吞吐量限制，bombardier、wrk、wrk2都是http基准测试工具，丰富了crank对于Http的基准测试能力，三者之间并无优劣之分，根据三者之间的优劣势自行选择适合自己的即可 源码地址：https://github.com/doddgu/crank/tree/sample 开源地址MASA.BuildingBlocks：https://github.com/masastack/MASA.BuildingBlocks MASA.Contrib：https://github.com/masastack/MASA.Contrib MASA.Utils：https://github.com/masastack/MASA.Utils MASA.EShop：https://github.com/masalabs/MASA.EShop MASA.Blazor：https://github.com/BlazorComponent/MASA.Blazor 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们","link":"/2022/02/26/independent/crank/4.%20advancement%203/"},{"title":"5. 堪比JMeter的.Net压测工具 - Crank 实战篇 - 接口以及场景压测","text":"1. 前言通过之前的学习，我们已经掌握了crank的配置以及对应http基准工具bombardier、wrk、wrk2的用法，本篇文章介绍一下如何将其用于实战，在实际的项目中我们如何使用crank来完成压测任务。 2. 项目背景目前有一个项目，我们希望通过压测来了解其QPS、吞吐量、以及临界值，并通过压测来分析出其瓶颈在哪里？并通过解决瓶颈问题以提高QPS、吞吐量等指标 先看下我们手头掌握了什么： 项目信息 项目中的接口基本都需要登录 通过与开发沟通可以得到每个页面的接口信息以及参数信息 环境信息 压测项目有单独的环境部署应用、Redis、数据库等基础配置 此处项目名我们暂定为ProjectA。 3. 如何开展首先我们先回顾一下Agent、Controller的职责以及特点 Controller 做任务调度以及结果输出 无需单独服务器，可以在本机执行发送命令，需要与Agent相通 Agent 任务的实际执行者 单任务执行，不能做到接收到多个任务并同时执行，先收到哪个任务，哪个任务会先执行 相同一个任务可以被多个Agent同时执行，最终指标结果会自动累加，可以通过提升Agent来模拟更高的并发能力 3.1. 思路 先做好单独接口的压测，大概掌握每个接口的指标情况 同时压测多个接口，完成对场景的压测 通过压测观察应用服务器、基础服务器的CPU、带宽、内存等指标，观察Redis、数据库、消息队列等基础组件情况，根据压测的返回结果得到每个场景的基础指标 通过分析发现瓶颈、然后再考虑如何突破瓶颈，提升QPS、吞吐量等 3.2. 如何做？了解到单个Agent同时执行多个任务会进行排队，无法做到多任务同时执行，那么我们可以通过多个Agent同时执行不同的任务来模拟用户访问页面。 3.2.1. 构建Agent之前与开发沟通得到每个页面最多可发送的请求是6个，那么我们准备6个Agent，分别为Agent1、Agent2、Agent3、Agent4、Agent5、Agent6 我们这里使用Docker来启动Agent、Agent对内开放端口: 5010、对外端口随机，镜像使用我们自建的: doddgu/crankagent:net5.0 并新建load.yml为之后压测使用: 12345678910111213141516171819202122232425262728293031profiles: crankAgent1: jobs: load: endpoints: - http://localhost:5010 crankAgent2: jobs: load: endpoints: - http://localhost:5011 crankAgent3: jobs: load: endpoints: - http://localhost:5012 crankAgent4: jobs: load: endpoints: - http://localhost:5013 crankAgent5: jobs: load: endpoints: - http://localhost:5014 crankAgent6: jobs: load: endpoints: - http://localhost:5015 load.yml 中记录了所有的压测机信息，其信息一般不做修改，我们可以作为公共的配置来使用无需每个项目都单独维护一份新的 3.2.2. 构建压测脚本在这里我们选择wrk2作为本次基准测试工具，选择wrk2的原因是： 支持随机参数 可支持设置恒定的吞吐量负载 具备wrk的所有功能 此时我们针对ProjectA项目新建配置：project.profiles.yml，作为本次压测的环境配置来使用，其配置如下 1234567891011121314imports: - https://raw.githubusercontent.com/doddgu/crank/sample/samples/wrk2/common/load.profiles.yml # 这边建议使用远程load.profiles.yml地址。(如果输入的是本地路径、则需输入与当前命令所在路径的相对路径)profiles: local: # 本地环境 variables: serverAddress: localhost # 应用服务域 serverPort: 80 # 应用服务端口 connections: 256 # 每个线程处理时保持打开的 HTTP 连接总数 N = 连接数/线程数 threads: 32 # 线程数 warmup: 3 # 预热时间: 3s duration: 180 # 测试时长: 3分钟 rate: # 吞吐量参数（每秒总请求数） project.profiles.yml中记录了指定项目的各环境的配置，项目自己独立维护即可 除了项目信息、压测机配置之外，我们还需要有地方维护我们压测的接口信息，这边我的做法是将api独立拆分出来，每个yml只配置一个接口的压测信息，至于为什么不放到一块，而要单独拆分开呢？ 这块考虑到我们压测的最小单元是API接口，如果把API接口独立拆分开，那么可以对单接口压测，而如果我们需要场景压测，也可以通过组合接口完成多接口同时压测，并且一旦我们完成了某个接口的压测编写，后续不需要再改动这个配置，如果我们按照场景拆分成不同的yml，在yml中再根据定义不同的scenario来做，那么后续场景新增加接口，还需要再更改这个场景的yml，并且scenario中的场景实际上也是根据接口维度区分的，目前crank并不能完成单个场景任务同时处理，基于以上原因，这边我们新调整好的配置格式为： 新增load.benchmarks.yml 123456789101112131415161718192021222324252627282930imports: - https://raw.githubusercontent.com/doddgu/crank/sample/src/Microsoft.Crank.Jobs.Wrk2/wrk2.yml - https://raw.githubusercontent.com/doddgu/crank/sample/samples/wrk2/common/project.profiles.ymljobs: server: source: repository: https://github.com/doddgu/crank branchOrCommit: sample project: samples/hello/hello.csproj readyStateText: Application started.scenarios: api: application: # 实际压测项目时可移除此节点，此处是为模拟应用服务启动 job: server variables: duration: 1 load: job: wrk2 variables: serverPath: /user/get script: request.lua duration: 1profiles: defaultParamLocal: # 本地环境的参数信息 variables: serverQueryString: ?id={1} serverQueryParameter: 1||2 # 随机请求/get?id=1、/get?id=2 按照此格式保存，后续新增接口也可以快速复制，简单修改即可快速完成压测工作的编写，这样一来，如果我们希望对localhost:5000/user/get这个接口做压测，仅需要在crank控制端输入： 1crank --config load.benchmarks.yml --scenario api --load.framework net5.0 --application.framework net5.0 --profile local --profile crankAgent1 --description &quot;获取用户详情&quot; --profile defaultParamLocal 3.2.3. 构建批处理命令但作为一个开发人员，总是希望事情能更简单一点，每次输入命令太麻烦了，所以就想到了通过批处理快速完成任务的发送，最终的项目结构就变成了 123456benchmarks├─ defaultTitle 接口名称( Description )└─ load.bat 最终执行的脚本，其中指定了要指定的yml配置、场景、以及任务环境是.net 5.0└─ load.benchmarks.yml yml配置└─ load.local.bat 测试本地环境时要执行的脚本、格式：load.{环境}.bat└─ README.md 帮助文档 每次通过双击load.{环境}.bat就完成了对当前接口的压力测试，然后就是等待结果输出…… 123456789101112131415161718192021222324252627282930313233343536| application | || --------------------- | -------------- || CPU Usage (%) | 1 || Cores usage (%) | 10 || Working Set (MB) | 85 || Private Memory (MB) | 278 || Build Time (ms) | 3,469 || Start Time (ms) | 352 || Published Size (KB) | 93,323 || .NET Core SDK Version | 5.0.404 || ASP.NET Core Version | 5.0.13+55738ff || .NET Runtime Version | 5.0.13+b3afe99 || load | || --------------------- | -------------- || Build Time (ms) | 3,281 || Start Time (ms) | 0 || Published Size (KB) | 74,276 || .NET Core SDK Version | 5.0.404 || ASP.NET Core Version | 5.0.13+55738ff || .NET Runtime Version | 5.0.13+b3afe99 || First Request (ms) | 86 || Requests/sec | 2 || Requests | 2 || Mean latency (ms) | 2.68 || Max latency (ms) | 2.68 || Bad responses | 0 || Socket errors | 0 || Latency 50th (ms) | 2.68 || Latency 75th (ms) | 2.68 || Latency 90th (ms) | 2.68 || Latency 99th (ms) | 2.68 || Latency 99.9th (ms) | 2.68 || Latency 99.99th (ms) | 2.68 || Latency 99.999th (ms) | 2.68 | 3.2.4. 构建场景压测批处理命令通过上面的一番操作，我们已经可以很容易的对单接口进行压测，但目前想模拟完成多接口同时压测，还需要再改造一下，之前我们想到，crank目前只能完成单独压测任务，那是不是有多个Agent，每个Agent单独压测一个接口，并同时启动多个Agent同时压测是不是可以模拟出来场景压测，那我通过批处理任务多点几次不同的接口压测不就可以了，基于以上考虑，又做了一个批处理脚本，用于调用多个接口的压测任务启动，最后的结构如下所示： 123456789101112131415161718192021Crank├─ benchmarks 压测脚本│ ├─ api 接口压测脚本 │ │ ├─ add │ │ └─ get │ ├─ scipts lua脚本 │ │ ├─ common lua公共脚本│ │ │ ├─ oauth.lua 认证lua脚本│ │ │ ├─ util.lua lua工具类脚本│ │ ├─ request.lua 封装请求lua脚本 │ ├─ scripts.tar lua脚本压缩包├─ common │ ├─ load.profiles.yml agent 负载机配置│ ├─ project.profiles.yml 项目配置│ ├─ scripts.profiles crank 执行script配置，用于对输出结果的二次处理│ ├─ project.profiles.yml 项目配置├─ scripts 场景压测脚本│ ├─ 用户.bat 用户压测 └─ env 环境配置，标记当前需要压测的环境在哪个配置文件中存储└─ env.local 本地环境，存储本地环境的配置信息└─ README.md 帮助文档 4. 结尾通过上面的操作我们已经完成了对单接口以及单场景的压测，通过控制台可以清晰的看到每个接口的压测结果，我们只需要耐心等待压测任务结束，并整理压测结果数据，最后进行汇总我们的任务就完成了，但压测结果的收集也是一个费事费力的工作，作为一个开发，是不想把时间花费到这些整理表格的事情上，那我们如何做可以把整理表格数据的工作节省下来让我们可以歇会儿呢…… 源码地址：https://github.com/doddgu/crank/tree/sample/samples/wrk2 参考链接： https://www.cnblogs.com/xinzhao/p/6233009.html 开源地址MASA.BuildingBlocks：https://github.com/masastack/MASA.BuildingBlocks MASA.Contrib：https://github.com/masastack/MASA.Contrib MASA.Utils：https://github.com/masastack/MASA.Utils MASA.EShop：https://github.com/masalabs/MASA.EShop MASA.Blazor：https://github.com/BlazorComponent/MASA.Blazor 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们","link":"/2022/02/27/independent/crank/5.%20actualcombat/"},{"title":"6. 堪比JMeter的.Net压测工具 - Crank 实战篇 - 收集诊断跟踪信息与如何分析瓶颈","text":"1. 前言上面我们已经做到了接口以及场景压测，通过控制台输出结果，我们只需要将结果收集整理下来，最后汇总到excel上，此次压测报告就可以完成了，但收集报告也挺麻烦的，交给谁呢…… 找了一圈、没找到愿意接手的人，该怎么办呢……思考了会儿还是决定看看能否通过程序解决我们的难题吧，毕竟整理表格太累╯﹏╰ 2. 收集结果通过查阅官方文档，我们发现官方提供了把数据保存成Json、csv、以及数据库三种方式，甚至还有小伙伴积极的对接要把数据保存到Es中，那选个最简单的吧！ 要不选择Json吧，不需要依赖外部存储，很简单，我觉得应该可试，试一下看看：输入命令： 1crank --config load.benchmarks.yml --scenario api --load.framework net5.0 --application.framework net5.0 --json 1.json --profile local --profile crankAgent1 --description &quot;wrk2-获取用户详情&quot; --profile defaultParamLocal 最后得到结果： 1234567891011121314151617181920212223242526272829303132{ &quot;returnCode&quot;: 0, &quot;jobResults&quot;: { &quot;jobs&quot;: { &quot;load&quot;: { &quot;results&quot;: { &quot;http/firstrequest&quot;: 85.0, &quot;wrk2/latency/mean&quot;: 1.81, &quot;wrk2/latency/max&quot;: 1.81, &quot;wrk2/requests&quot;: 2.0, &quot;wrk2/errors/badresponses&quot;: 0.0, &quot;wrk2/errors/socketerrors&quot;: 0.0, &quot;wrk2/latency/50&quot;: 1.81, &quot;wrk2/latency/distribution&quot;: [ [ { &quot;latency_us&quot;: 1.812, &quot;count&quot;: 1.0, &quot;percentile&quot;: 0.0 }, { &quot;latency_us&quot;: 1.812, &quot;count&quot;: 1.0, &quot;percentile&quot;: 1.0 } ] ] } } } }} 完整的导出结果 好吧，数据有点少，好像数据不太够吧，这些信息怎么处理能做成报表呢，再说了数据不对吧，QPS、延迟呢？好吧，被看出来了，因为信息太多，我删了一点点（也就1000多行指标信息吧），看来这个不行，用json的话还得配合个程序好难…… csv不用再试了，如果也是单个文本的话，也是这样，还得配个程序，都不能单干，干啥都得搭伴，那试试数据库如何 1crank --config load.benchmarks.yml --scenario api --load.framework net5.0 --application.framework net5.0 --sql &quot;Server=localhost;DataBase=crank;uid=sa;pwd=P@ssw0rd;&quot; --table &quot;local&quot; --profile local --profile crankAgent1 --description &quot;wrk2-获取用户详情&quot; --profile defaultParamLocal 我们根据压测环境，把不同的压测指标存储到不同的数据库的表中，当前是本地环境，即 table = local 最后我们把数据保存到了数据库中，那这样做回头需要报告的时候，我查询下数据库搞出来就好了，终于松了一口气，但好景不长，发现数据库存储也有个坑，之前json中看到的结果竟然在一个字段中存储，不过幸好SqlServer 2016之后支持了json，可以通过json解析搞定，但其中参数名有/等特殊字符，sql server处理不了，难道又得写个网站才能展示这些数据了吗？？真的绕不开搭伴干活这个坑吗？ 微软不会就做出个这么鸡肋的东西，还必须要配个前端才能清楚的搞出来指标吧……还得用vue、好吧，我知道虽然现在有blazer，可以用C#开发，但还是希望不那么麻烦，又仔细查找了一番，发现Crank可以对结果做二次处理，可以通过script，不错的东西，既然sql server数据库无法支持特殊字符，那我加些新参数取消特殊字符不就好了，新建scripts.profiles.yml 12345678910111213scripts: changeTarget: | benchmarks.jobs.load.results[&quot;cpu&quot;] = benchmarks.jobs.load.results[&quot;benchmarks/cpu&quot;] benchmarks.jobs.load.results[&quot;cpuRaw&quot;] = benchmarks.jobs.load.results[&quot;benchmarks/cpu/raw&quot;] benchmarks.jobs.load.results[&quot;workingSet&quot;] = benchmarks.jobs.load.results[&quot;benchmarks/working-set&quot;] benchmarks.jobs.load.results[&quot;privateMemory&quot;] = benchmarks.jobs.load.results[&quot;benchmarks/private-memory&quot;] benchmarks.jobs.load.results[&quot;totalRequests&quot;] = benchmarks.jobs.load.results[&quot;bombardier/requests;http/requests&quot;] benchmarks.jobs.load.results[&quot;badResponses&quot;] = benchmarks.jobs.load.results[&quot;bombardier/badresponses;http/requests/badresponses&quot;] benchmarks.jobs.load.results[&quot;requestSec&quot;] = benchmarks.jobs.load.results[&quot;bombardier/rps/mean;http/rps/mean&quot;] benchmarks.jobs.load.results[&quot;requestSecMax&quot;] = benchmarks.jobs.load.results[&quot;bombardier/rps/max;http/rps/max&quot;] benchmarks.jobs.load.results[&quot;latencyMean&quot;] = benchmarks.jobs.load.results[&quot;bombardier/latency/mean;http/latency/mean&quot;] benchmarks.jobs.load.results[&quot;latencyMax&quot;] = benchmarks.jobs.load.results[&quot;bombardier/latency/max;http/latency/max&quot;] benchmarks.jobs.load.results[&quot;bombardierRaw&quot;] = benchmarks.jobs.load.results[&quot;bombardier/raw&quot;] 以上处理的数据是基于bombardier的，同理大家可以完成对wrk或者其他的数据处理 通过以上操作，我们成功的把特殊字符的参数改成了没有特殊字符的参数，那接下来执行查询sql就可以了。 12345678910111213SELECT Description as '场景', JSON_VALUE (Document,'$.jobs.load.results.cpu') AS 'CPU使用率(%)', JSON_VALUE (Document,'$.jobs.load.results.cpuRaw') AS '多核CPU使用率(%)', JSON_VALUE (Document,'$.jobs.load.results.workingSet') AS '内存使用(MB)', JSON_VALUE (Document,'$.jobs.load.results.privateMemory') AS '进程使用的私有内存量(MB)', ROUND(JSON_VALUE (Document,'$.jobs.load.results.totalRequests'),0) AS '总发送请求数', ROUND(JSON_VALUE (Document,'$.jobs.load.results.badResponses'),0) AS '异常请求数', ROUND(JSON_VALUE (Document,'$.jobs.load.results.requestSec'),0) AS '每秒支持请求数', ROUND(JSON_VALUE (Document,'$.jobs.load.results.requestSecMax'),0) AS '每秒最大支持请求数', ROUND(JSON_VALUE (Document,'$.jobs.load.results.latencyMean'),0) AS '平均延迟时间(us)', ROUND(JSON_VALUE (Document,'$.jobs.load.results.latencyMax'),0) AS '最大延迟时间(us)', CONVERT(varchar(100),DATEADD(HOUR, 8, DateTimeUtc),20) as '时间'FROM dev; 3. 如何分析瓶颈通过上面的操作，我们已经可以轻松的完成对场景的压测，并能快速生成相对应的报表信息，那正题来了，可以模拟高并发场景，那如何分析瓶颈呢？毕竟报告只是为了知晓当前的系统指标，而我们更希望的是知道当前系统的瓶颈是多少，怎么打破瓶颈，完成突破呢…… 首先我们要先了解我们当前的应用的架构，比如我们现在使用的是微服务架构，那么 应用拆分为几个服务？了解清楚每个服务的作用 服务之间的调用关系 各服务依赖的基础服务有哪些、基础服务基本的信息情况 举例我们当前的微服务架构如下： 通过架构图可以快速了解到项目结构，我们可以看到用户访问web端，web端根据请求对应去查询redis或者通过http、grpc调用服务获取数据、各服务又通过redis、db获取数据。 首先我们先通过crank把当前的数据指标保存入库。调出其中不太理想的接口开始分析。 在这里我们拿两个压测接口举例： 获取首页Banner、QPS：3800 /s (Get) 下单、QPS：8 /s (Post) 3.1. 获取首页Banner通过单测首页banner的接口，QPS是3800多不到4000这样，虽然这个指标还不错，但我们仍然觉得很慢，毕竟首页banner就是很简单几个图片+标题组合的数据，数据量不大，并且是直连Redis，仅在Redis不存在时才查询对应服务获取banner数据，这样的QPS实在不应该，并且这个还是仅压测单独的banner，如果首页同时压测十几个接口，那其性能会暴降十倍不止，这样肯定是不行的 我们又压测了一次首页banner接口，发现有几个疑点： redis请求数徘徊在3800左右的样子，网络带宽占用1M的样子，无法继续上涨 查看web服务，发现时不时的会有调用服务超时出错的问题，Db的访问量有上涨，但不明显，很快就下去了 思考: Redis的请求数与最后的压测结果差不多，最后倒也对上了，但为什么redis的请求数这么低呢？难道是带宽限制！！ 虽然是单机redis，但4000也绝对不可能是它的瓶颈，怀疑是带宽被限制了，应该就是带宽被限制了，后来跟运维一番切磋后，得到结论是redis没限制带宽…… 那为什么不行呢，这么奇怪，redis不可能就这么点并发就不行了，算了还是写个程序试一下吧，看看是不是真的测试环境不给力，redis配置太差了，一番操作后发现，同一个redis数据，redis读可以到6万8，不到7万、带宽占用10M，redis终于洗清了它的嫌疑，此接口的QPS不行与Redis无关，但这么简单的一个结构为什么QPS就上不去呢……，如果不是redis的问题，那会不会是因为请求就没到redis上，是因为压测机的强度不够，导致请求没到redis……当时冒出来这个有点愚蠢的想法，那就增加压测机的数量，通过更改负载压测机配置，1台压测机升到了3台，但可惜的是单台压测机的指标不升反降，最后所有压测机的指标加到一起正好与之前一台压测机的压测结果差不多一样，那说明QPS低与压测机无关，后来想到试试通过增加多副本来提升QPS，后来web副本由1台提升到了3台，之前提到的服务调用报错的情况更加严重，之前只是偶尔有一个错误，但提升web副本后，看到一大片的错误 提示Thread is busy，很多线程开始等待 大量的服务调用超时，DB查询缓慢 最后QPS 1000多一点，有几千个失败的错误，这盲目的提升副本貌似不大有效，之前尽管Qps不高，但起码也在4000,DB也没事，这波神操作后QPS直降4分之3，DB还差点崩了，思想滑坡了，做了负优化…… 继续思考，为何提升副本，QPS不升反降，为何出现大量的调用超时、为何DB会差点被干崩，我只是查询个redis，跟DB有毛关系啊！奇了怪了，看看代码怎么写的吧……烧脑 123456789101112131415161718192021222324252627282930public async Task&lt;List&lt;BannerResponse&gt;&gt; GetListAsync(){ List&lt;BannerResponse&gt; result = new List&lt;BannerResponse&gt;(); try { var cacheKey = &quot;banner_all&quot;; var cacheResult = await _redisClient.GetAsync&lt;List&lt;BannerResponse&gt;&gt;(cacheKey); if (cacheResult == null) { result = this.GetListServiceAsync().Result; _redisClient.SetAsync(cacheKey, result, new() { DistributedCacheEntryOptions = new() { AbsoluteExpirationRelativeToNow = TimeSpan.FromDays(5) } }).Wait(); } else { result = cacheResult; } } catch (Exception e) { result = await this.GetListServiceAsync(); } return result;} 看了代码后发现，仅当Reids查询不到的时候，会调用对应服务查询数据，对应服务再查询DB获取数据，另外查询异常时，会再次调用服务查询结果，确保返回结果一定是正确的，看似没问题，但为何压测会出现上面那些奇怪现象呢…… 请求超时、大量等待，那就是正好redis不存在，穿透到对应的服务查询DB了，然后压测同一时刻数据量过大，同一时刻查询到的Reids都是没有数据，最后导致调用服务的数量急剧上升，导致响应缓慢，超时加剧，线程因超时释放不及时，又导致可用线程较少。 这块我们查找到对应的日志显示以下信息 123System.TimeoutException: Timeout performing GET MyKey, inst: 2, mgr: Inactive, queue: 6, qu: 0, qs: 6, qc: 0, wr: 0, wq: 0, in: 0, ar: 0,IOCP: (Busy=6,Free=994,Min=8,Max=1000), WORKER: (Busy=152,Free=816,Min=8,Max=32767) 那么我们可以调整Startup.cs： 1234567public void ConfigureServices(IServiceCollection services){ ThreadPool.GetMinThreads(out int workerThreads, out int completionPortThreads); ThreadPool.SetMinThreads(1000, completionPortThreads);//根据情况调整最小工作线程，避免因创建线程导致的耗时操作 ……………………………………………………………此处省略…………………………………………………………………………………………………………} web服务调用底层服务太慢，那么提升底层服务的响应速度（优化代码）或者提高处理能力（提升副本） 防止高并发情况下全部穿透到下层，增加底层服务的压力 前两点也是一个好的办法，但不是最好的解决办法，最好还是不要穿透到底层服务，如果reids不存在，就放一个请求过去是最好的，拿到数据就持久化到redis，不要总穿透到下层服务，那么怎么做呢，最简单的办法就是使用加锁，但加锁会影响性能，但这个我们能接受，后来调整加锁测试，穿透到底层服务的情况没有了，但很可惜，请求数确实会随着副本的增加而增加，但是实在是有点不好看，后来又测试了下另外一个获取缓存数据的结果，结果QPS：1000多一点，比banner还要低的多，两边明明都使用的是Reids，性能为何还有这么大的差别，为何我们写的redis的demo就能到6万多的QPS，两边都是拿的一个缓存，差距有这么大？难道是封装redis的sdk有问题？后来仔细对比了后来写的redis的demo与banner调用redis的接口发现，一个是直接查询的redis的字符串，一个是封装redis的sdk，多了一个反序列化的过程，最后经过测试，反序列化之后性能降低了十几倍，好吧看来只能提升副本了……但为何另外的接口也是从redis获取，性能跟banner的接口不一样呢！！ 经过仔细对比发现，差别是信息量，QPS更低的接口的数据量更大，那结果就有了，随着数据量的增加，QPS会进一步降低，那这样一来的话，增加副本的作用不大啊，谁知道会不会有一个接口的数据量很大，那性能岂不是差的要死，那还怎么玩，能不能提升反序列化的性能或者不反序列化呢，经过认真思考，想到了二级缓存，如果用到了二级缓存，内存中有就不需要查询redis，也不需要再反序列化，那么性能应该有所提升，最后的结构如下图： 最后经过压测发现，单副本QPS接近50000，比最开始提升12倍，并且也不会出现服务调用超时，DB崩溃等问题、且内存使用平稳 此次压测发现其banner这类场景的性能瓶颈在反序列化，而非Redis、DB，如果按照一开始不清楚其工作原理、盲目的调整副本数，可能最后会加剧系统的雪崩，而如果我们把DB资源、Redis资源盲目上调、并不会对最后的结果有太大帮助，最多也只是延缓崩溃的时间而已 3.2. 下单下单的QPS是8，这样的QPS已经无法忍受了，每秒只有十个请求可以下单成功，如果中间再出现一个库存不足、账户余额不足、活动资格不够等等，实际能下单的人用一个手可以数过来，真的就这么惨……虽然下单确实很费性能，不过确实不至于这么低吧，先看下下单流程吧 简化后的下单流程就这么简单，web通过dapr的actor服务调用order service，然后就是漫长的查询db、操作redis操作，因涉及业务代码、具体代码就不再放出，但可以简单说一下其中做的事情，检查账户余额、反复的增加redis库存确保库存安全、检查是否满足活动、为推荐人计算待结算佣金等等一系列操作，整个看下来把人看懵了，常常是刚看了上面的，看下面代码的时候忘记上面具体干了什么事，代码太多了，一个方法数千行，其中再调用一些数百行的代码，真的吐血了，不免感叹我司的开发小哥哥是真的强大，这么复杂的业务居然能这么”顺畅”的跑起来，后面还有N个需求等待加到下单上，果然不是一般人 不过话说回来，虽然是业务是真的多，也真的乱，不过这样搞也不至于QPS才只有8这么可怜吧，服务器的处理能力可不是二十几年前的电脑可以比拟的，单副本8核16G的配置不支持这么拉胯吧，再看一下究竟谁才是真正的幕后黑手…… 但究竟哪里性能瓶颈在哪里，这块就要出杀手锏了 通过Tracing可以很清楚的看到各节点的耗时情况，这将对我们分析瓶颈提供了非常大的帮助、我们看到了虽然有几十次的查询DB操作，但DB还挺给力，基本也再很短时间内就给出了响应，那剩余时间耗费到了哪里呢？我们看到整体耗时11s、但查询Db加起来也仅仅不到1s，那么剩余操作都在哪里？要知道哪怕我们优化DB查询性能，减少DB查询，那提升的性能对现在的结果也是微乎其微 结合Tracing以及下单流程图，我们发现从Web到Order Service是通过actor来实现的，那会不是这里耗时影响的呢？ 但dapr是个新知识、开发的小哥哥速度真快，这么快就用上dapr了（ˇˍˇ）不知道小哥哥的头发还有多少…… 快速去找到下单使用actor的地方，如下: 12345678910[HttpPost][Authorize]public async Task&lt;CreateOrderResponse&gt; CreeateOrder([FromBody] CreateOrderModel request){ string actionType = &quot;SalesOrderActor&quot;; var salesOrderActor = ActorProxy.Create&lt;ISalesOrderActor&gt;(new ActorId(request.SkuList.OrderBy(sku =&gt; sku.Sku).FirstOrDefault().Sku), actionType); request.AccountId = Account.Id; var result = await salesOrderActor.CreateOrderAsync(request); return new Mapping&lt;ParentSalesOrderListViewModel, CreateOrderResponse&gt;().Map(result);} 我们看到了这边代码十分简单，获取商品信息的第一个sku编号作为actor的actorid使用，然后得到下单的actor，之后调用actor中的创建订单方法最后得到下单结果，这边的代码太简单了，让人心情愉快，那这块会不会有可能影响下单速度呢？它是不是那个性能瓶颈最大的幕后黑手？ 首先这块我们就需要了解下什么是Dapr、Actor又是什么，不了解这些知识我们只能靠抓阄来猜这块是不是瓶颈了…… Dapr 全称是Distributed Application Runtime，分布式应用运行时，并于今年加入了 CNCF 的孵化项目，目前Github的star高达16k，相关的学习文档在文档底部可以找到，我也是看着下面的文档了解dapr 通过了解actor，我们发现用sku作为actorid是极不明智的选择，像秒杀这类商品不就是抢的指定规格的商品吗？如果这样一来，这不是在压测actor吗？这块我们跟对应的开发小哥哥沟通了下，通过调整actorid顺利将Qps提升到了60作用，后面又通过优化减少db查询、调整业务规则的顺序等操作顺利将QPS提升到了不到一倍，虽然还是很低，不过接下来的优化工作就需要再深层次的调整业务代码了…… 4. 总结通过实战我们总结出分析瓶颈从以下几步走： 通过第一轮的压测获取性能差的接口以及指标 通过与开发沟通或者自己查看源码的方式梳理接口流程 通过分析其项目所占用资源情况、依赖第三方基础占用资源情况以及Tracing更进一步的确定瓶颈大概的点在哪几块 通过反复测试调整确定性能瓶颈的最大黑手 将最后的结论与相关开发、运维人员沟通，确保都知晓瓶颈在哪里，最后优化瓶颈 知识点： Dapr 手把手教你学Dapr系列 Tracing OpenTracing 简介、关于OpenTracing后续我们也会开源，可以提前关注我们的开源项目 Masa.BuildingBlocks Masa.Contrib 开源地址MASA.BuildingBlocks：https://github.com/masastack/MASA.BuildingBlocks MASA.Contrib：https://github.com/masastack/MASA.Contrib MASA.Utils：https://github.com/masastack/MASA.Utils MASA.EShop：https://github.com/masalabs/MASA.EShop MASA.Blazor：https://github.com/BlazorComponent/MASA.Blazor 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们","link":"/2022/02/28/independent/crank/6.%20actualcombat%202/"},{"title":"7. 堪比JMeter的.Net压测工具 - Crank 总结篇 - crank带来了什么","text":"1. 前言通过上面的学习，我们已经了解清楚crank的职责以及作用，那么我们重新回来思考一下，crank能为我们带来什么？ 2. Crank带来了什么？ 为分布式压测提供了解决方案、可以模拟更高强度的压测 单机压测最多提供65535，通过支持多个Agent可以很轻松的突破这个极限 提供了压测结果二次处理的能力，并支持将结果保存到json、csv、数据库甚至是es(目前仍在对接) 通过对以往压测数据的结果做折线图的展示 通过ci可以完成自动化触发压测，再通过折线图清晰了解每次代码对性能的提升情况 3. Crank还能更进一步吗？上面的实战训练我们仅仅是做了基础的工作，尽管我们通过模拟多接口同时压测完成了对单场景的压测，但真实的项目远远不会是所有人都同时访问一个页面，而不访问其它页面，那我们如何模拟出更贴近真实场景的用户轨迹呢？ 真实的用户场景应该更像 如果我们希望更进一步，想知道我们的系统的极限究竟在哪里，我们可以按照按照此用户场景进行深度还原压测场景，完成对整个场景的压测，并通过调整副本、带宽、Redis集群、数据库集群数量等方式提升QPS，最后通过不断的压测以及配置不断的增加，了解到我们使用什么样的配置、用多少副本、用多少带宽、什么样的Redis、数据库集群能够抗住多少的用户，但这个需要视我们真实的业务场景，如果QPS到100就够用的话，那么我们花费那么高的成本搞那么大的QPS有什么意义呢？我们又不是需要再做一个淘宝出来，实际没有那么高的用户量，搞到极致的优化也只是劳民伤财罢了 4. 疑问 Agent的压测机配置必须很高吗？ 压测机的配置高，将赋予压测机更高的压测能力，但QPS的高低并不是通过压测机来决定，Qps低的项目，搞个超级计算机过来，Qps仍然低 为何我启动Agent执行任务后每次都需要Install Sdk？每次安装都需要半天，翻墙我也处理过了，但还是很慢 建议Agent启动时指定dotnethome，并且在启动任务时，最好指定任务的框架环境是已经存在的环境，Agent的启动配置可以查看入门篇，指定任务运行框架可以查看进阶篇 为何我通过crank官方的命名运行出错呢？ crank还在持续更新升级中，可能会出现用新版本的crank发送上文示例不能使用的情况，可以安装指定版本的crank，以上示例都有在0.2.0-alpha.21567.1版本运行成功 我想自己搭建Agent的docker镜像，文中提供的镜像不知道是否安全？ 文中用到的镜像是通过下面的dockerfile编译的，没有搞很复杂的东西，不放心的可以使用自建镜像 doddgu/crankagent:net5.0是.net 5.0版本 我的压测场景也需要登录，但不需要实现每次请求都是一个新的用户，我该选择bombardier还是wrk、wrk2呢？ 针对压测场景简单的，又不需要实现多用户、不需要动态参数的可以用bombardier、简单不需要学习lua、成本低 希望可以用动态参数，玩一些复杂场景的，选择wrk或者wrk2更合适 压测场景单一，且不需要实现多用户、不需要动态参数不能使用wrk、wrk2吗？ bombardier能实现的场景，wrk、wrk2都可以做到 针对简单的get请求，不需要更改参数使用wrk一样很简单、使用post请求的需要多掌握一点lua脚本知识，有条件的还是建议使用wrk、wrk2，它更灵活入手成本也不是太大 crank agent dockerfile 123456789FROM mcr.microsoft.com/dotnet/sdk:5.0ENV PATH=&quot;${PATH}:/root/.dotnet/tools&quot;EXPOSE 5010RUN dotnet tool install -g Microsoft.Crank.Agent --version &quot;0.2.0-alpha.21567.1&quot; ENTRYPOINT crank-agent --dotnethome &quot;/usr/share/dotnet&quot; 5. 总结Crank的功能其实是很单一的，它不像我们起初想象的那样庞大，所有的事情都能做，也没那么复杂，但我们也可以说Crank什么都能干，因为它提供了让我们运行dotnet项目以及在docker中运行dotnet程序的能力。 但它最后能做什么事取决于使用它的人想用它来干什么，它只是一个工具而已，不要把它想得太美好，有了它以后可以不写代码，自动化完成测试工作，我只需要等结果，自动出报告等等……有这样想法的还是去洗洗脸吧，大白天的竟然在做梦？ 压测以及性能调优考验的是我们对整个系统的一个全局掌控能力，通过压测让我们知道目前系统的瓶颈在哪里？等我们的业务规模到了瓶颈时，可以通过调优提高项目的QPS、使其响应能力更快，不会因为系统而影响我们的业务，其目的是帮助业务发展的更好，但如果业务没发展起来，一味的陷入性能调优这个深坑中去，会使得我们花费高昂的代价做了没有实际意义的事，就比如说家里总共就四口人，非得搞个中巴，美其名曰可以拉更多的人，过年走亲戚不会坐不下什么的，每次出门费油又心疼的不得了，最后舍不得开了，最后还得花钱给它找停车位，那就得不偿失了 开源地址MASA.BuildingBlocks：https://github.com/masastack/MASA.BuildingBlocks MASA.Contrib：https://github.com/masastack/MASA.Contrib MASA.Utils：https://github.com/masastack/MASA.Utils MASA.EShop：https://github.com/masalabs/MASA.EShop MASA.Blazor：https://github.com/BlazorComponent/MASA.Blazor 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们","link":"/2022/03/01/independent/crank/7.%20cummarize/"},{"title":"使用Helm打造应用商店","text":"1. 简介利用Kubernetes部署一个应用，需要Kubernetes原生资源文件如deployment、replicationcontroller、service或pod 等。而对于一个复杂的应用，会有很多类似上面的资源描述文件，如果有更新或回滚应用的需求，可能要修改和维护所涉及的大量资源文件，且由于缺少对发布过的应用版本管理和控制，使Kubernetes上的应用维护和更新等面临诸多的挑战，而Helm可以帮我们解决这些问题。 Helm是目前Kubernetes服务编排领域的唯一开源子项目，做为Kubernetes应用的一个包管理工具，可理解为Kubernetes的apt-get / yum，由Deis 公司发起，该公司已经被微软收购。Helm通过软件打包的形式，支持发布的版本管理和控制，很大程度上简化了Kubernetes应用部署和管理的复杂性。 Helm把Kubernetes资源(比如deployments、services或 ingress等) 打包到一个chart中，而chart被保存到chart仓库。通过chart仓库可用来存储和分享chart。Helm使发布可配置，支持发布应用配置的版本管理，简化了Kubernetes部署应用的版本控制、打包、发布、删除、更新等操作。 Helm架构 Helm 有两个主要部分： Helm Client 是最终用户的命令行客户端。客户端负责以下部分： 本地 chart 开发 管理存储库 与 Tiller 服务交互 发送要安装的 chart 查询有关发布的信息 请求升级或卸载现有 release Tiller Server 是一个集群内服务，与 Helm 客户端进行交互，并与 Kubernetes API 服务进行交互。服务负责以下内容： 监听来自 Helm 客户端的传入请求 结合 chart 和配置来构建发布 将 chart 安装到 Kubernetes 中，然后跟踪后续 release 通过与 Kubernetes 交互来升级和卸载 chart 简而言之，客户端负责管理 chart，而服务端负责管理 release。 三大概念一个 Chart 是一个 Helm 包。它包含在 Kubernetes 集群内部运行应用程序，工具或服务所需的所有资源定义。把它想像为一个自制软件，一个 Apt dpkg 或一个 Yum RPM 文件的 Kubernetes 环境里面的等价物。 一个 Repository 是 Charts 收集和共享的地方。它就像 Perl 的 CPAN archive 或 Fedora 软件包 repoFedora Package Database。 一个 Release 是处于 Kubernetes 集群中运行的 Chart 的一个实例。一个 chart 通常可以多次安装到同一个群集中。每次安装时，都会创建一个新 release 。比如像一个 MySQL chart。如果希望在群集中运行两个数据库，则可以安装该 chart 两次。每个都有自己的 release，每个 release 都有自己的 release name。 有了这些概念，我们现在可以这样解释 Helm： Helm 将 charts 安装到 Kubernetes 中，每个安装创建一个新 release 。要找到新的 chart，可以搜索 Helm charts 存储库 repositories。 Helm 使用称为 chart 的包装格式。chart 是描述相关的一组 Kubernetes 资源的文件集合。单个 chart 可能用于部署简单的东西，比如 memcached pod，或者一些复杂的东西，比如完整的具有 HTTP 服务，数据库，缓存等的 Web 应用程序堆栈。 chart 通过创建为特定目录树的文件，将它们打包到版本化的压缩包，然后进行部署。 由于Rancher的应用商店很好的集成了Helm的客户都与服务端，所以本篇将主要讲解 chart 的格式，提供使用 Helm 构建 chart 的基本指导。 2. Chart 文件结构chart 被组织为一个目录内的文件集合。目录名称是 chart 的名称（没有版本信息）。例如，描述 WordPress 的 chart 将被存储在 wordpress / 目录中。 在这个目录里面，Helm 期望如下这样一个的结构的目录树： 12345678910wordpress/ Chart.yaml # A YAML file containing information about the chart LICENSE # OPTIONAL: A plain text file containing the license for the chart README.md # OPTIONAL: A human-readable README file requirements.yaml # OPTIONAL: A YAML file listing dependencies for the chart values.yaml # The default configuration values for this chart charts/ # A directory containing any charts upon which this chart depends. templates/ # A directory of templates that, when combined with values, # will generate valid Kubernetes manifest files. templates/NOTES.txt # OPTIONAL: A plain text file containing short usage notes Helm 保留使用 charts / 和 templates / 目录以及上面列出的文件名称。其他文件将被忽略。 2.1. Chart.yaml 文件Chart.yaml 文件是 chart 所必需的。它包含以下字段： 12345678910111213141516171819apiVersion: The chart API version, always &quot;v1&quot; (required)name: The name of the chart (required)version: A SemVer 2 version (required)kubeVersion: A SemVer range of compatible Kubernetes versions (optional)description: A single-sentence description of this project (optional)keywords: - A list of keywords about this project (optional)home: The URL of this project's home page (optional)sources: - A list of URLs to source code for this project (optional)maintainers: # (optional) - name: The maintainer's name (required for each maintainer) email: The maintainer's email (optional for each maintainer) url: A URL for the maintainer (optional for each maintainer)engine: gotpl # The name of the template engine (optional, defaults to gotpl)icon: A URL to an SVG or PNG image to be used as an icon (optional).appVersion: The version of the app that this contains (optional). This needn't be SemVer.deprecated: Whether this chart is deprecated (optional, boolean)tillerVersion: The version of Tiller that this chart requires. This should be expressed as a SemVer range: &quot;&gt;2.0.0&quot; (optional) 如果熟悉 Chart.yaml Helm Classic 的文件格式，注意到指定依赖性的字段已被删除。这是因为新的 chart 使用 charts / 目录表示依赖关系。 其他字段将被忽略。 2.2. Charts 和版本控制每个 chart 都必须有一个版本号。版本必须遵循 SemVer 2 标准。与 Helm Class 格式不同，Kubernetes Helm 使用版本号作为发布标记。存储库中的软件包由名称加版本识别。 例如，nginx version 字段设置为 1.2.3 将被命名为： 1nginx-1.2.3.tgz 更复杂的 SemVer 2 命名也是支持的，例如 version: 1.2.3-alpha.1+ef365。但非 SemVer 命名是明确禁止的。 ** 注意 ** ：虽然 Helm Classic 和 Deployment Manager 在 chart 方面都非常适合 GitHub，但 Kubernetes Helm 并不依赖或需要 GitHub 甚至 Git。因此，它不使用 Git SHA 进行版本控制。 许多 Helm 工具都使用 Chart.yaml 的 version 字段，其中包括 CLI 和 Tiller 服务。在生成包时，helm package 命令将使用它在 Chart.yaml 中的版本名作为包名。系统假定 chart 包名称中的版本号与 Chart.yaml 中的版本号相匹配。不符合这个情况会导致错误。 2.3. appVersion 字段请注意，appVersion 字段与 version 字段无关。这是一种指定应用程序版本的方法。例如，drupal chart 可能有一个 appVersion: 8.2.1，表示 chart 中包含的 Drupal 版本（默认情况下）是 8.2.1。该字段是信息标识，对 chart 版本没有影响。 弃用 charts在管理 chart tepo 库中的 chart 时，有时需要弃用 chart。Chart.yaml 的 deprecated 字段可用于将 chart 标记为已弃用。如果存储库中最新版本的 chart 标记为已弃用，则整个 chart 被视为已弃用。chart 名称稍后可以通过发布未标记为已弃用的较新版本来重新使用。废弃 chart 的工作流程根据 helm/charts 项目的工作流程如下： 更新 chart 的 Chart.yaml 以将 chart 标记为启用，并且更新版本 在 chart Repository 中发布新的 chart 版本 从源代码库中删除 chart（例如 git） 2.4. Chart 许可证文件，自述文件和说明文件Chart 还可以包含描述 chart 的安装，配置，使用和许可证的文件。 LICENSE 文件是一个纯文本文件，包含 chart 的 [许可证]（https://en.wikipedia.org/wiki/Software_license）。 Chart 可以包含许可证，它可能在模板中具有编程逻辑，因此不仅仅是配置。 如果需要，还可以为 chart 安装的应用程序提供单独的许可证。 Chart 的自述文件应由 Markdown（README.md）语法格式化，并且通常应包含： chart 提供的应用程序或服务的描述 运行 chart 的任何前提条件或要求 选项 values.yaml 和默认值的说明 任何其他可能与安装或配置 chart 相关的信息 chart 还可以包含一个简短的纯文本 templates/NOTES.txt 文件，在安装后以及查看版本状态时将打印出来。此文件将作为模板 template 进行评估 ，并可用于显示使用说明，后续步骤或任何其他与发布 chart 相关的信息。例如，可以提供用于连接到数据库或访问 Web UI 的指令。由于运行时，该文件被打印到标准输出 helm install 或 helm status，建议保持内容简短并把更多细节指向自述文件。 3. Chart 依赖关系在 Helm 中，一个 chart 可能依赖于任何数量的其他 chart。这些依赖关系可以通过 requirements.yaml 文件动态链接或引入 charts/ 目录并手动管理。 虽然有一些团队需要手动管理依赖关系的优势，但声明依赖关系的首选方法是使用 chart 内部的 requirements.yaml 文件。 ** 注意：** 传统 Helm 的 Chart.yaml dependencies: 部分字段已被完全删除弃用。 3.1. 用 requirements.yaml 来管理依赖关系requirements.yaml 文件是列出 chart 的依赖关系的简单文件。 1234567dependencies: - name: apache version: 1.2.3 repository: http://example.com/charts - name: mysql version: 3.2.1 repository: http://another.example.com/charts 该 name 字段是 chart 的名称。 version 字段是 chart 的版本。 repository 字段是 chart repo 的完整 URL。请注意，还必须使用 helm repo add 添加该 repo 到本地才能使用。 有了依赖关系文件，你可以通过运行 helm dependency update ，它会使用你的依赖关系文件将所有指定的 chart 下载到你的 charts/ 目录中。 12345678910$ helm dep up foochartHang tight while we grab the latest from your chart repositories......Successfully got an update from the &quot;local&quot; chart repository...Successfully got an update from the &quot;stable&quot; chart repository...Successfully got an update from the &quot;example&quot; chart repository...Successfully got an update from the &quot;another&quot; chart repositoryUpdate Complete. Happy Helming!Saving 2 chartsDownloading apache from repo http://example.com/chartsDownloading mysql from repo http://another.example.com/charts 当 helm dependency update 检索 chart 时，它会将它们作为 chart 存档存储在 charts/ 目录中。因此，对于上面的示例，可以在 chart 目录中看到以下文件： 123charts/ apache-1.2.3.tgz mysql-3.2.1.tgz 通过 requirements.yaml 管理 chart 是一种轻松更新 chart 的好方法，还可以在整个团队中共享 requirements 信息。 3.2. requirements.yaml 中的 alias 字段除上述其他字段外，每个 requirement 条目可能包含可选字段 alias。 为依赖的 chart 添加别名会将 chart 放入依赖关系中，并使用别名作为新依赖关系的名称。 如果需要使用其他名称访问 chart，可以使用 alias。 12345678910111213# parentchart/requirements.yamldependencies: - name: subchart repository: http://localhost:10191 version: 0.1.0 alias: new-subchart-1 - name: subchart repository: http://localhost:10191 version: 0.1.0 alias: new-subchart-2 - name: subchart repository: http://localhost:10191 version: 0.1.0 在上面的例子中，我们将得到 parentchart 的 3 个依赖关系 123subchartnew-subchart-1new-subchart-2 实现这一目的的手动方法是 charts/ 中用不同名称多次复制 / 粘贴目录中的同一 chart 。 3.3. requirements.yaml 中的 tags 和 condition 字段除上述其他字段外，每个需求条目可能包含可选字段 tags 和 condition。 所有 charts 都会默认加载。如果存在 tags 或 condition 字段，将对它们进行评估并用于控制应用的 chart 的加载。 Condition - condition 字段包含一个或多个 YAML 路径（用逗号分隔）。如果此路径存在于顶级父级的值中并且解析为布尔值，则将根据该布尔值启用或禁用 chart。只有在列表中找到的第一个有效路径才被评估，如果没有路径存在，那么该条件不起作用。 Tags - 标签字段是与此 chart 关联的 YAML 标签列表。在顶级父级的值中，可以通过指定标签和布尔值来启用或禁用所有带有标签的 chart。 1234567891011121314151617# parentchart/requirements.yamldependencies: - name: subchart1 repository: http://localhost:10191 version: 0.1.0 condition: subchart1.enabled, global.subchart1.enabled tags: - front-end - subchart1 - name: subchart2 repository: http://localhost:10191 version: 0.1.0 condition: subchart2.enabled,global.subchart2.enabled tags: - back-end - subchart2 1234567# parentchart/values.yamlsubchart1: enabled: truetags: front-end: false back-end: true 在上面的示例中，所有带有标签的 front-end 的 charts 都将被禁用，但由于 subchart1.enabled 的值在父项值中为 “真”，因此条件将覆盖该 front-end 标签，subchart1 会启用。 由于 subchart2 被标记 back-end 和标签的计算结果为 true，subchart2 将被启用。还要注意的是，虽然 subchart2 有一个在 requirements.yaml 中指定的条件，但父项的值中没有对应的路径和值，因此条件无效。 3.4. 使用命令行时带有 tag 和 conditions--set 参数可使用来更改 tag 和 conditions 值。 12helm install --set tags.front-end=true --set subchart2.enabled=false 3.5. tags 和 conditions 解析 **Conditions (设置 values) 会覆盖 tags 配置.**。第一个存在的 condition 路径生效，后续该 chart 的 condition 路径将被忽略。 如果 chart 的某 tag 的任一 tag 的值为 true，那么该 tag 的值为 true，并启用这个 chart。 Tags 和 conditions 值必须在顶级父级的值中进行设置。 tags: 值中的关键字必须是顶级关键字。目前不支持全局和嵌套 tags: 表格。 3.6. 通过 requirements.yaml 导入子值在某些情况下，希望允许子 chart 的值传到父 chart 并作为通用默认值共享。使用这种 exports 格式的另一个好处是它可以使未来的工具能够考虑用户可设置的值。 要导入的值的键可以在父 chart 文件中 requirements.yaml 使用 YAML list 指定。list 中的每个项目都是从子 chart exports 字段导入的 key。 要导入不包含在 exports key 中的值，请使用子父级 child-parent 格式。下面描述了两种格式的例子。 使用 exports 格式如果子 chart 的 values.yaml 文件 exports 在根目录中包含一个字段，则可以通过指定要导入的关键字将其内容直接导入到父项的值中，如下例所示： 1234# parent's requirements.yaml file ... import-values: - data 12345# child's values.yaml file...exports: data: myint: 99 由于我们在导入列表中指定了 data 键，因此 Helm 会在 exports 子图的字段中查找 data 键并导入其内容。 最终的父值将包含我们的导出字段： 1234# parent's values file...myint: 99 请注意，父键 data 不包含在父 chart 的最终值中。如果需要指定父键，请使用’child-parent’格式。 3.7. 使用 child-parent 格式要访问未包含在子 chart 键值 exports 的中的值，需要指定要导入的值的源键（child）和父 chart 值（parent）中的目标路径。 下面的例子中的 import-values 告诉 Helm 去拿在 child: 路径发现的任何值，并将其复制到父值 parent: 指定的路径 123456789# parent's requirements.yaml filedependencies: - name: subchart1 repository: http://localhost:10191 version: 0.1.0 ... import-values: - child: default.data parent: myimports 在上面的例子中，在 subchart1default.data 的值中找到的值将被导入到父 chart 值中 myimports 的键值，详细如下： 1234567# parent's values.yaml filemyimports: myint: 0 mybool: false mystring: &quot;helm rocks!&quot; 1234567# subchart1's values.yaml filedefault: data: myint: 999 mybool: true 父 chart 的结果值为： 1234567# parent's final valuesmyimports: myint: 999 mybool: true mystring: &quot;helm rocks!&quot; 父 chart 的最终值现在包含从 subchart1 导入的 myint 和 mybool 字段。 3.8. 通过 charts/ 目录手动管理依赖性如果需要更多的控制依赖关系，可以通过将依赖的 charts 复制到 charts/ 目录中来明确表达这些依赖关系 。 依赖关系可以是 chart 归档（foo-1.2.3.tgz）或解压缩的 chart 目录。但它的名字不能从 _ 或 . 开始。这些文件被 chart 加载器忽略。 例如，如果 WordPress chart 依赖于 Apache chart，则在 WordPress chart 的 charts/ 目录中提供（正确版本的）Apache chart： 1234567891011wordpress: Chart.yaml requirements.yaml # ... charts/ apache/ Chart.yaml # ... mysql/ Chart.yaml # ... 上面的示例显示了 WordPress chart 如何通过在其 charts/ 目录中包含这些 charts 来表示它对 Apache 和 MySQL 的依赖关系。 ** 提示：** 将依赖项放入 charts / 目录，请使用 helm fetch 命令 3.9. 使用依赖关系的操作方面影响上面的部分解释了如何指定 chart 依赖关系，但是这会如何影响使用 helm install 和 helm upgrade 的 chart 安装？ 假设名为 “A” 的 chart 创建以下 Kubernetes 对象 namespace “A-Namespace” statefulset “A-StatefulSet” service “A-Service” 此外，A 依赖于创建对象的 chart B. namespace “B-Namespace” replicaset “B-ReplicaSet” service “B-Service” 安装 / 升级 chart A 后，会创建 / 修改单个 Helm 版本。该版本将按以下顺序创建 / 更新所有上述 Kubernetes 对象： A-Namespace B-Namespace A-StatefulSet B-ReplicaSet A-Service B-Service 这是因为当 Helm 安装 / 升级 charts 时，charts 中的 Kubernetes 对象及其所有依赖项都是如下 聚合成一个单一的集合; 然后 按类型排序，然后按名称排序; 接着 按该顺序创建 / 更新。 因此，单个 release 是使用 charts 及其依赖关系创建的所有对象。 Kubernetes 类型的安装顺序由 kind_sorter.go 中的枚举 InstallOrder 给出（the Helm source file)）。 4. 模板 Templates 和值 ValuesHelm chart 模板是用 Go 模板语言 Go template language 编写的 ，其中添加了来自 Sprig 库 from the Sprig library 的 50 个左右的附加模板函数以及一些其他专用函数 specialized functions。 所有模板文件都存储在 chart 的 templates / 文件夹中。当 Helm 渲染 charts 时，它将通过模板引擎传递该目录中的每个文件。 模板的值有两种提供方法： chart 开发人员可能会在 chart 内部提供一个 values.yaml 文件。该文件可以包含默认值。 chart 用户可能会提供一个包含值的 YAML 文件。这可以通过命令行提供 helm install -f。 当用户提供自定义值时，这些值将覆盖 chart 中 values.yaml 文件中的值。 4.1. 模板文件模板文件遵循用于编写 Go 模板的标准约定（请参阅文 the text/template Go package documentation 以了解详细信息）。示例模板文件可能如下所示： 1234567891011121314151617181920212223242526apiVersion: v1kind: ReplicationControllermetadata: name: deis-database namespace: deis labels: app.kubernetes.io/managed-by: deisspec: replicas: 1 selector: app.kubernetes.io/name: deis-database template: metadata: labels: app.kubernetes.io/name: deis-database spec: serviceAccount: deis-database containers: - name: deis-database image: {{.Values.imageRegistry}}/postgres:{{.Values.dockerTag}} imagePullPolicy: {{.Values.pullPolicy}} ports: - containerPort: 5432 env: - name: DATABASE_STORAGE value: {{default &quot;minio&quot; .Values.storage}} 上面的示例基于 此网址，是 Kubernetes replication controller 的模板。它可以使用以下四个模板值（通常在 values.yaml 文件中定义 ）： imageRegistry：Docker 镜像的源。 dockerTag：docker 镜像的标签。 pullPolicy：Kubernetes 镜像拉取策略。 storage：存储后端，其默认设置为 &quot;minio&quot; 所有这些值都由模板作者定义。Helm 不需要或指定参数。 要查更多 charts，请查看 Kubernetes charts 项目 4.2. 预定义值通过 values.yaml 文件（或通过 --set 标志）提供的值可以从 .Values 模板中的对象访问。可以在模板中访问其他预定义的数据片段。 以下值是预定义的，可用于每个模板，并且不能被覆盖。与所有值一样，名称区分大小写。 Release.Name：release 的名称（不是 chart 的） Release.Time：chart 版本上次更新的时间。这将匹配 Last Released 发布对象上的时间。 Release.Namespace：chart release 发布的 namespace。 Release.Service：处理 release 的服务。通常是 Tiller。 Release.IsUpgrade：如果当前操作是升级或回滚，则设置为 true。 Release.IsInstall：如果当前操作是安装，则设置为 true。 Release.Revision：版本号。它从 1 开始，并随着每个 helm upgrade 增加。 Chart：Chart.yaml 的内容。chart 版本可以从 Chart.Version 和维护人员 Chart.Maintainers 一起获得。 Files：包含 chart 中所有非特殊文件的 map-like 对象。不会允许你访问模板，但会让你访问存在的其他文件（除非它们被排除使用 .helmignore）。可以使用 index .Files “file.name” 或使用. Files.Get name 或 .Files.GetString name 功能来访问文件。也可以使用. Files.GetBytes 访问该文件的内容 [byte] Capabilities：包含有关 Kubernetes 版本信息的 map-like 对象（.Capabilities.KubeVersion)，Tiller（.Capabilities.TillerVersion) 和支持的 Kubernetes API 版本（.Capabilities.APIVersions.Has “batch/v1”） ** 注意:** 任何未知的 Chart.yaml 字段将被删除。它们不会在 chart 对象内部被访问。因此，Chart.yaml 不能用于将任意结构化的数据传递到模板中。values 文件可以用于传递。 4.3. 值 values 文件考虑到上一节中的模板 values.yaml，提供了如下必要值的信息： 1234imageRegistry: &quot;quay.io/deis&quot;dockerTag: &quot;latest&quot;pullPolicy: &quot;Always&quot;storage: &quot;s3&quot; values 文件是 YAML 格式的。chart 可能包含一个默认 values.yaml 文件。Helm install 命令允许用户通过提供额外的 YAML 值来覆盖值： 1$ helm install --values=myvals.yaml wordpress 当以这种方式传递值时，它们将被合并到默认 values 文件中。例如，考虑一个如下所示的 myvals.yaml 文件： 1storage: &quot;gcs&quot; 当它与 chart 中 values.yaml 的内容合并时，生成的内容将为： 1234imageRegistry: &quot;quay.io/deis&quot;dockerTag: &quot;latest&quot;pullPolicy: &quot;Always&quot;storage: &quot;gcs&quot; 注意只有最后一个字段被覆盖了，其他的不变。 ** 注：** 包含在 chart 内的默认 values 文件必须命名 values.yaml。但是在命令行上指定的文件可以被命名为任何名称。 ** 注：** 如果在 helm install 或 helm upgrade 使用 --set，则这些值仅在客户端转换为 YAML。 ** 注意：** 如果 values 文件中存在任何必需的条目，则可以使用’required’功能 ‘required’ function 在 chart 模板中声明它们 然后可以在模板内部访问任何这些 .Values 对象值 ： 123456789101112131415161718192021222324252627apiVersion: v1kind: ReplicationControllermetadata: name: deis-database namespace: deis labels: app.kubernetes.io/managed-by: deisspec: replicas: 1 selector: app.kubernetes.io/name: deis-database template: metadata: labels: app.kubernetes.io/name: deis-database spec: serviceAccount: deis-database containers: - name: deis-database image: {{.Values.imageRegistry}}/postgres:{{.Values.dockerTag}} imagePullPolicy: {{.Values.pullPolicy}} ports: - containerPort: 5432 env: - name: DATABASE_STORAGE value: {{default &quot;minio&quot; .Values.storage}} 4.4. 范围 Scope，依赖 Dependencies 和值 Valuesvalues 文件可以声明顶级 chart 的值，也可以为 chart 的 charts / 目录中包含的任何 chart 声明值。或者，用不同的方式来描述它，values 文件可以为 chart 及其任何依赖项提供值。例如，上面的演示 WordPresschart 具有 mysql 和 apache 依赖性。values 文件可以为所有这些组件提供值： 12345678title: &quot;My WordPress Site&quot; # Sent to the WordPress templatemysql: max_connections: 100 # Sent to MySQL password: &quot;secret&quot;apache: port: 8080 # Passed to Apache 更高级别的 chart 可以访问下面定义的所有变量。所以 WordPresschart 可以访问 MySQL 密码 .Values.mysql.password。但较低级别的 chart 无法访问父 chart 中的内容，因此 MySQL 将无法访问该 title 属性。同样的，也不能访问 apache.port。 值是命名空间限制的，但命名空间已被修剪。因此对于 WordPresschart 来说，它可以访问 MySQL 密码字段 .Values.mysql.password。但是对于 MySQL chart 来说，这些值的范围已经减小了，并且删除了名 namespace 前缀，所以它会将密码字段简单地视为 .Values.password。 4.5. 全局值从 2.0.0-Alpha.2 开始，Helm 支持特殊的 “全局” 值。考虑前面例子的这个修改版本： 1234567891011title: &quot;My WordPress Site&quot; # Sent to the WordPress templateglobal: app: MyWordPressmysql: max_connections: 100 # Sent to MySQL password: &quot;secret&quot;apache: port: 8080 # Passed to Apache 上面添加了一个 global 区块，值 app: MyWordPress。此值可供所有 chart 使用 .Values.global.app。 比如，该 mysql 模板可以访问 app 如. Values.global.app，apache chart 也同样的。上面的 values 文件是这样高效重新生成的： 123456789101112131415title: &quot;My WordPress Site&quot; # Sent to the WordPress templateglobal: app: MyWordPressmysql: global: app: MyWordPress max_connections: 100 # Sent to MySQL password: &quot;secret&quot;apache: global: app: MyWordPress port: 8080 # Passed to Apache 这提供了一种与所有子 chart 共享一个顶级变量的方法，这对设置 metadata 中像标签这样的属性很有用。 如果子 chart 声明了一个全局变量，则该全局将向下传递 （到子 chart 的子 chart），但不向上传递到父 chart。子 chart 无法影响父 chart 的值。 此外，父 chart 的全局变量优先于子 chart 中的全局变量。 4.6. 参考当涉及到编写模板和 values 文件时，有几个标准参考可以帮助你。 Go templates Extra template functions The YAML format 4.7. 在Rancher中自定义应用商店5. 应用商店概述在Rancher中提供基于helm的应用商店，通过应用商店能够快速和容易的重复部署应用。应用商店的charts来源即可以是helm仓库或者git仓库，其中包含现成的用于部署的应用程序。应用程序捆绑在称为charts的对象中。charts是Helm推广的封装格式。可以将它们视为部署模板，对于每个Helm，图表是：描述相关Kubernetes资源集的文件集合。使用单个charts即可以部署简单的应用，例如memcached pod；也可以部署复杂的应用，例如具有HTTP服务器，数据库，缓存等的完整Web应用程序堆栈。 Rancher自身改进了Helm目录和charts。所有原生的Helm charts都可以在Rancher中运行，但为了提升用户体验，Rancher增加了一些功能。在Rancher中提供了由Rancher官方维护的模板仓库、由Kubernetes社区维护的模板仓库和未经测试验证的应用模板仓库这三种内置的应用商店。另外，也支持添加自定义的应用商店。 在Rancher中提供基于helm的应用商店，通过应用商店能够快速和容易的重复部署应用。 6. 自定义应用商店自定义的应用商店是一个git仓库，URL需要是一个git clone能够处理的，以及以.git结尾的地址。 6.1. Chart类型Rancher支持两种charts类型： Helm Charts：原生的Helm charts包含运行应用的所有内容。当部署一个原生的Helm charts时，需要通过Answers配置键值对形式的参数。Helm chart有Helm Stable和Helm Incubators这两种。 Rancher Charts：Rancher charts在原生的helm charts基础上，添加量app-readme.md和questions.yaml这两个文件，以提升用户体验。 Rancher charts的优势： 增强版本追踪：Helm支持版本化的部署，Rancher增加了追踪和版本历史管理，以显示不同版本之间的变化。 简化应用程序启动：Rancher chart增加简化的charts描述和配置表单，使应用商店中的应用程序部署更加容易。Rancher用户不需要阅读Helm整个列表中的变量来理解如何启动应用程序。 应用资源管理：Rancher追踪所创建的所有资源。用户能够跟踪所有的资源。用户能在一个页面上查看被用来支持应用的工作负载对象。 6.2. Chart目录结构下表展示了chart的目录结构，在目录中可以看到：charts/%application%/%app version%/。当为应用商店定制charts时，此信息很有用。用Rancher Specific表示的文件专门用于于Rancher chart，但对于chart自定义是可选的。 12345678├── charts/ 包含依赖charts的目录│ ├── Chart.yml helm chart信息文件│ ├── questions.yml !Rancher需要!： 包含在Rancher界面中显示的请求。│ ├── README.md 可选：在Rancher UI中显示的Helm说明文件。│ └── requirements.yml 可选：列出chart依赖关系的YAML文件。├── templates/ 模板目录，当与values.yml结合使用时，会生成Kubernetes YAML。│ └── values.yml chart的默认配置文件。└── app-readme.md Rancher需要：在Rancher页面中app描述信息。 6.3. Rancher Chart额外的文件在创建自己的定制化应用商店之前，需要对Rancher chart和原生helm chart有一个基本的了解。Rancher chart与helm chart在目录结构上有细微的差别，即Rancher chart比helm chart多两个文件。 app-readme.md：此文件提供chart的描述文本。下面两张图显示了Rancher chart(包含app-readme.md文件)和原生的Helm chart 之间的区别。左边为Rancher Chart(带有app-readme.md）右边的为Helm Chart。app-readme.md questions.yml：此文件包含表单的请求信息。这些表单请求用于简化chart的部署，当然，也可以使用键值对来配置部署，但使用questions.yml能够简化这个工作。下面显示了Rancher chart(包含app-readme.md文件)和原生的Helm chart 之间的区别。左边为Rancher Chart(带有app-readme.md）右边的为Helm Chart。questions.yml 此参考包含的变量可以在questions.yml中进行使用。 变量 类型 是否必需 描述 variable string true Define the variable name specified in the&nbsp;values.yml&nbsp;file, using&nbsp;foo.bar&nbsp;for nested objects. label string true 定义UI标签 description string false 指定变量的描述 type string false Default to&nbsp;string&nbsp;if not specified (current supported types are string, boolean, int, enum, password, storageclass and hostname). required bool false Define if the variable is required or not (true | false) default string false 指定默认值 group string false Group questions by input value. min_length int false Min character length. max_length int false Max character length. min int false Min integer length. max int false Max integer length. options []string false Specify the options when the variable type is&nbsp;enum, for example: options: – “ClusterIP” – “NodePort” – “LoadBalancer” valid_chars string false Regular expression for input chars validation. invalid_chars string false Regular expression for invalid input chars validation. subquestions []subquestion false Add an array of subquestions. show_if string false Show current variable if conditional variable is true. For example&nbsp;show_if: \"serviceType=Nodeport\" show_subquestion_if string false Show subquestions if is true or equal to one of the options. for example&nbsp;show_subquestion_if: \"true\" 6.4. 创建定制chart的实例可以使用Helm Charts或Rancher Charts填充您的自定义商店，建议使用Rancher Charts。 在gitlab仓库中，构建符合要求的chart目录结构。提示：可以通过拷贝一个来自于Helm Stable或Rancher Library中chart来定制自己的chart。 推荐：创建一个app-readme.md文件。在Rancher UI中，使用此文件为chart标题创建自定义文本。可以使用此文本告知用户如何使用该chart。示例： 12$ cat ./app-readme.md# WordPress ROCKS! 推荐： 创建一个questions.yml文件。此文件用于定义部署的参数，没有此文件的话，用户必须通过键值对手工指定参数。下面的例子创建了一个表单，提示用户设置持久化容量大小和存储类。 1234567891011121314151617181920212223categories:- Blog- CMSquestions:- variable: persistence.enableddefault: &quot;false&quot;description: &quot;Enable persistent volume for WordPress&quot;type: booleanrequired: truelabel: WordPress Persistent Volume Enabledshow_subquestion_if: truegroup: &quot;WordPress Settings&quot;subquestions:- variable: persistence.size default: &quot;10Gi&quot; description: &quot;WordPress Persistent Volume Size&quot; type: string label: WordPress Volume Size- variable: persistence.storageClass default: &quot;&quot; description: &quot;If undefined or null, uses the default StorageClass. Default to null&quot; type: storageclass label: Default StorageClass for WordPress 推送定制的chart到gitlab仓库。 7. 运用应用商店下面演示，如何运用自定义的应用商店： 添加自己的应用商店， 进入特定的项目查看应用商店的应用， 至此，你可以开始你的K8S商店之旅了！","link":"/2022/03/11/independent/helm/getting-started/"},{"title":".Net Minimal API 介绍","text":"Minimal APIs 是.Net 6 中新增的模板，借助 C# 10 的一些特性以最少的代码运行一个 Web 服务。本文脱离 VS 通过 VS Code，完成一个简单的 Minimal Api 项目的开发。 创建项目新建一个文件夹，用来管理我们的项目文件，文件夹内启动命令行，通过dotnet new web创建项目。 1234567Minimal├── obj├── Properties├── appsettings.Development.json├── appsettings.json├── Minimal.csproj└── Program.cs 运行项目项目目录下执行dotnet run，运行项目。 123456789101112PS C:\\Users\\User01\\Desktop\\Minimal&gt; dotnet run正在生成...info: Microsoft.Hosting.Lifetime[14] Now listening on: https://localhost:7221info: Microsoft.Hosting.Lifetime[14] Now listening on: http://localhost:5252info: Microsoft.Hosting.Lifetime[0] Application started. Press Ctrl+C to shut down.info: Microsoft.Hosting.Lifetime[0] Hosting environment: Developmentinfo: Microsoft.Hosting.Lifetime[0] Content root path: C:\\Users\\User01\\Desktop\\Minimal\\ 运行效果如下: Codingbuilder 实例提供了 Services 属性，可以完成原本 Startup 类 ConfigureServices 方法中注册服务的工作,Configure 方法的一些 Use 操作则通过 app 来完成。 12345678builder.Services.AddMemoryCache();app.UseStaticFiles();if (app.Environment.IsDevelopment()){ app.UseSwagger(); app.UseSwaggerUI(c =&gt; c.SwaggerEndpoint(&quot;/swagger/v1/swagger.json&quot;, $&quot;{builder.Environment.ApplicationName} v1&quot;));} Mapbuilder.Build()返回的 app 实例提供了 Map、Methods、MapXXX 方法实现 HttpMethod 路由的映射。这里只以 Get 请求为例。Map 和 MapMethods 方法提供不同的特性和参数可以代替 MapGet 方法。 1app.MapGet(&quot;/&quot;, () =&gt; &quot;Hello World!&quot;); 1app.Map(&quot;/&quot;, [HttpGet] () =&gt; &quot;Hello World!&quot;); HttpGet 特性限定请求为 Get 请求，如果不指定则不限制请求方法，Get、Post 等方式可以请求改路由地址 1app.MapMethods(&quot;/&quot;, new List&lt;string&gt;() { HttpMethod.Get.ToString() }, () =&gt; &quot;Hello World!&quot;); Application代码内直接修改应用程序配置，如修改监听端口 123app.Urls.Add(&quot;http://localhost:3000&quot;);//app.Run();app.Run(&quot;http://localhost:4000&quot;); 优先级 app.Run &gt; app.Urls.Add &gt; launchSettings Dependency InjectionMinimal APIs 中无法使用构造函数注入，但可以通过参数方式注入并忽略 FromServices 特性。 1234app.MapGet(&quot;/info&quot;, (IWebHostEnvironment env) =&gt; new { Time = DateTimeOffset.UtcNow, env.EnvironmentName}); Context一些 Http 请求的上下文信息也可以通过参数直接指定，方法体内直接使用，代替 MVC 中的 Request 等。如： HttpContext HttpRequest HttpResponse ClaimsPrincipal CancellationToken 1234app.MapGet(&quot;/context&quot;, (HttpContext httpContext) =&gt; new{ Data = httpContext.Connection.Id}); 更多类型参考：github Responses通过静态类 Results 返回标准的相应类型，实现和 ControllerBase 提供对应方法相同的效果。 1234app.MapGet(&quot;/ok/{id}&quot;, (int id) =&gt;{ return Results.Ok($&quot;ok:{id}&quot;);}); Link Generation通过扩展方法 WithXXX 等可以对路由进行一些配置，如通过 WithName 指定名称，再通过 LinkGenerator 生产对应 Uri，避免硬编码 1234567app.MapGet(&quot;/context&quot;, (HttpContext httpContext) =&gt; new{ Data = httpContext.Connection.Id}).WithName(&quot;hi&quot;);app.MapGet(&quot;hello&quot;, (LinkGenerator linker) =&gt; $&quot;The link to the hello route is {linker.GetPathByName(&quot;hi&quot;, values: null)}&quot;); 除了 WithXXX 等一些列 RoutingEndpointConvention 扩展方法外，还提供了 AuthorizationEndpointConvention 相关扩展方法 RequireAuthorization、AllowAnonymous 代替 MVC 模式中的相关特性（特性也还可以用只是多了一个支持方式）。 本文只列出 Minimal APIs 的一些简单用法，集成 Swagger 等用法内容参考：https://minimal-apis.github.io/hello-minimal/ 接口的返回状态码和类型等可以通过扩展方法 Produces 说明，如：Produces(contentType:”application/xml”); ，但是接口备注貌似还不支持，我尝试了很多方式都不能正确显示。 Code FormatMinimal APIs 上面示例存在的问题是 Program 文件中会有太多的编码，所有路由的映射和响应都在一起，虽然可以通过如下方式使用静态方法抽离响应方法，但所有的 Route Map 还是列在一起，不能像 Controller 一样分离。 1234567891011var handler = new HelloHandler();app.MapGet(&quot;/&quot;, handler.Hello);class HelloHandler{ public string Hello() { return &quot;Hello World&quot;; }} 可以借助开源框架 MASA.Contrib提供的 MASA.Contrib.Service.MinimalAPIs 完成代码封装。 详细用法参考 MASA.EShop Program.cs 123var builder = WebApplication.CreateBuilder(args);var app = builder.Services.AddServices(builder);app.Run(); HelloService.cs 123456public class HelloService : ServiceBase{ public HelloService(IServiceCollection services): base(services) =&gt; App.MapGet(&quot;/api/v1/helloworld&quot;, ()=&gt;&quot;Hello World&quot;));}","link":"/2021/11/06/independent/minimal-api/minimal-api/"},{"title":"Redis OM .NET Redis对象映射框架","text":"Redis OMRedis OM 是 Redis 官方推出的对象映射框架，即：Object Mapping。让开发人员更简单、方便的操作 Redis 数据。Redis 存储的数据抽象为对象映射，支持基于对象的 Redis 数据持久化、流式查询操作。 目前只支持 4 种开发语言: Redis OM for Spring Redis OM for .NET Redis OM for Node.js Redis OM for Python Redis OM .NETRedis OM .NET 是.Net 平台的 Redis OM，依赖 StackExchange.Redis 实现。借助 Redis OM .NET 可以实现对象操作的方式操作 Redis 数据，脱离 key/value 的操作方式。查询支持大部分.Neter 最爱的 LINQ。 快速开始安装对应包1dotnet add package Redis.OM Redis 环境准备直接使用 Docker 的方式安装 Redis 环境。 1docker run -p 6379:6379 redislabs/redismod:preview 标准的官方镜像是无法支持 Redis OM，需要 Redis Modules 支持，Redis OM 核心创建索引、查询数据依赖RediSearch这个 Module 实现。依赖的 Module 有:RediSearch、RedisJSON。RedisJSON 的依赖不是必须的，但是会缺少相应的功能，如:模型嵌套、复杂查询（只支持 key 查询） Coding增加抽象对象定义1234567891011121314[Document]public class Customer{ [RedisIdField] public string Id { get; set; } [Indexed(Sortable = true, Aggregatable = true)] public string FirstName { get; set; } [Indexed(Sortable = true, Aggregatable = true)] public string LastName { get; set; } [Indexed] public string Email { get; set; } [Indexed(Sortable = true)] public int Age { get; set; }} Document、Indexed、Searchable 等特性介绍，介绍参考 Github -&gt; document-attribute 获取抽象对象的操作集合、创建索引1234var provider = new RedisConnectionProvider(&quot;redis://localhost:6377&quot;);var connection = provider.Connection;var customers = provider.RedisCollection&lt;Customer&gt;();connection.CreateIndex(typeof(Customer)); 查询数据、聚合操作等需要依据索引，所以一定要先调用connection.CreateIndex创建索引,对应 RediSearch 的FT.CREATE命令。 connection.CreateIndex(typeof(Customer)) 创建索引重复执行会抛出异常Index already exists。虽然可以通过connection.Execute(&quot;FT.INFO&quot;, $&quot;customer-idx&quot;)获取索引信息，但是第一次索引不存在时会抛出Unknown Index name。所以实际使用中可能需要一个 try-catch 包住CreateIndex方法避免异常。 插入数据12var id = customers.Insert(new Customer { FirstName = &quot;Steve&quot;, Email = &quot;xxxx@masa.com&quot;, Age = 1 });var id2 = customers.Insert(new Customer { FirstName = &quot;FirstName&quot;, LastName = &quot;LastName&quot;, Email = &quot;xxxx@masa.com&quot; }); id,id2 为插入数据的 key，没有指定 Document 的 Prefixes 和 IdGenerationStrategy，则默认为 ULID 格式为{DocumentName}:{Ulid},如:`Cust 插入数据时需要注意的是，如果对没有明确指定字段的值，如 LastName 不明确赋值：customers.Insert(new Customer { FirstName = &quot;Steve&quot;, Email = &quot;xxxx@masa.com&quot;, Age = 1 });，查看 Redis 中存的数据可以发现当前 key 存储的 json 数据没有未指定的字段对应的 key（此时 Query 或 Aggregations 会有些奇怪的错误）。可以根据自己需要，显示的为字段赋个零值或者在定义实体时使用public string LastName { get; set; } = string.Empty;的方式。 查询数据12345var customer = customers.Where(x =&gt; x.Age == 0).OrderBy(a =&gt; a.FirstName).FirstOrDefault();var customerById = customers.FindById(id);//根据Id查找var emails = customers.Select(x =&gt; x.Email);//仅查询指定字段var takes = customers.Where(x =&gt; x.Age &gt; 0).Take(10);//获取指定条数var adults = customers.Where(x =&gt; x.Age &gt;= 0).Skip(5);//查询偏移 对于空值的判断，x.FirstName == “”【语法错误】 或 string.IsNullOrEmpty(x.FirstName)【不支持】。Redis 哈希中不能有空字符串，所以类似的查询应该通过聚合操作的Exists方法实现 1234foreach (var agg in customerAggregations.Apply(x =&gt; ApplyFunctions.Exists(x.RecordShell.LastName), &quot;LastNameExists&quot;)){ Console.WriteLine($&quot;{agg[&quot;LastNameExists&quot;]}&quot;);} 聚合操作流水线（Pipelining）同时发送多个请求，从而减轻延迟。结果的查询和转化都在 Redis 端完成。 RecordShell 是远端 Index 类型的结构，RecordShell 应该只在聚合操作流水线内部使用，运行时并没有真正的值。 拼凑 FirstName 和 LastName,返回 FullName 1234567var customerAggregations = provider.AggregationSet&lt;Customer&gt;();var age = customerAggregations.Average(x =&gt; x.RecordShell.Age);var sets = customerAggregations.Where(a =&gt; a.RecordShell.FirstName == &quot;Steve&quot;).Apply(x =&gt; string.Format(&quot;{0} {1}&quot;, x.RecordShell.FirstName, x.RecordShell.LastName), &quot;FullName&quot;);foreach (var item in sets){ Console.WriteLine(item[&quot;FullName&quot;].ToString());} 聚合分组通过 GroupBy 方法，依据不同属性进行分组聚合（支持单字段分组和多字段分组）。 123456var res = customerAggregations .GroupBy(x =&gt; x.RecordShell.FirstName) .GroupBy(x =&gt; x.RecordShell.LastName) .ToArray();var res1 = customerAggregations.GroupBy(x =&gt; x.RecordShell.FirstName).CloseGroup().ToArray(); CloseGroup 可以关闭分组，转换为正常的聚合操作，即 GroupedAggregationSet 到 RedisAggregationSet 的一个转换。 1234public static RedisAggregationSet&lt;T&gt; CloseGroup&lt;T&gt;(this GroupedAggregationSet&lt;T&gt; source){ return new RedisAggregationSet&lt;T&gt;(source, source.Expression);} 结尾本文只是对 Redis OM .NET 用法的简单梳理和可用性验证。更多用法以及用法更新参考Github","link":"/2021/12/02/independent/redis/redis_om_net/"},{"title":"Dotnet Templating 定制自己的项目模板","text":"本讲解，如何借助 [.NET Core Template Engine](dotnet templating 定制自己的项目模板) 创建一个简单的项目模板。 前言为了方便开发，.Net 提供了官方基本的项目模板如：ASP.NET Core Web、ASP.NET Core Web API 等，但是这只能帮助我们创建最基本的项目模板，所以很多第三方库为了方便开发者快速集成都提供了自己的项目模板，如：IdentityServer4.Templates。同样我们也可以根据自己的技术栈，创建出适用于自己或者公司的项目模板。 创建项目代码和配置文件首先创建一个 Minimal APIs 项目，基于这个项目定义自己的项目模板。Template Engine 脱离$safeprojectname$这种项目模板参数的方式，好处是模板项目本身始终是一个可以正常编译运行的项目，可以及时发现制作模板过程中的问题。 大致的目录结构如下所示，可以根据实际使用中是否需要一个 nupkg 文件中包含多个项目模板调整结构。 12345678src├── content│ ├── .template.config│ │ ├── template.png│ │ ├── template.json│ │ ├── dotnetcli.host.json│ │ └── ide.host.json│ ├── 项目文件 .template.config 介绍在项目根目录下创建.template.config 文件夹，存在项目相关配置文件。文件夹内创建三个 json 文件 template.json 必须的模板配置文件，定义一些模板配置信息以及模板生成的逻辑等 ide.host.json 非必须的 VS 界面配置文件，定义模板图标以及配置展示参数等 dotnetcli.host.json 非必须的 Cli 配置文件，定义命令中参数的短名称 [官方文档](dotnet new 自定义模板 - .NET CLI | Microsoft Docs)中给了 template.json 文件必须参数的说明。 除了这三个文件还可以增加多语言的支持，具体用法可以参考aspnetcore 的项目模板 修改.template.config 下的文件template.json对 symbols 字段做一些说明，其他必须参数上面的图片中有说明。这里我定义了四个参数：Framework，UseAuthorize，SeparateRouteHandler，IsLast。Framework 和 IsLast 只作演示，UseAuthorize，SeparateRouteHandler 两个参数是定制模板时需要用到的参数。 Framework 参数的 datatype 为 choice 类型，vs 中会展示一个下拉列表。replaces 的指定当前我们选择的值替换项目中的哪个值，类似 sourceName。其他字段均为字面意思。 UseAuthorize，SeparateRouteHandler 两个类型为 bool 类型，UseAuthorize 是否引入认证鉴权，演示代码中的判断。SeparateRouteHandler 演示模板的文件排除逻辑，生成项目时根据该值判断排除多余文件。 IsLast 参数则是简单的演示计算参数。 sources 参数用来自定义输出源，定义 modifiers 通过 condition 指定一个条件包含或者排除哪些文件，本文使用的是 exclude。 primaryOutputs 参数自定义输出，这里只定义了项目名。 postActions 则是定义模板生成后的动作，支持的 Action 参考文档。 更多介绍（如生成 Guid，随机数等）参考Wiki 示例文件内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576{ &quot;$schema&quot;: &quot;http://json.schemastore.org/template&quot;, &quot;author&quot;: &quot;Masa&quot;, &quot;classifications&quot;: [&quot;web&quot;, &quot;api&quot;], &quot;identity&quot;: &quot;Masa.web.tmpl&quot;, &quot;name&quot;: &quot;Masa Web Api&quot;, &quot;shortName&quot;: &quot;masa.tmpl&quot;, &quot;tags&quot;: { &quot;language&quot;: &quot;C#&quot;, &quot;type&quot;: &quot;project&quot; }, &quot;sourceName&quot;: &quot;Masa.Web&quot;, &quot;preferNameDirectory&quot;: true, &quot;sources&quot;: [ { &quot;modifiers&quot;: [ { &quot;condition&quot;: &quot;(!SeparateRouteHandler)&quot;, &quot;exclude&quot;: [&quot;DemoHandler.cs&quot;] } ] } ], &quot;symbols&quot;: { &quot;Framework&quot;: { &quot;type&quot;: &quot;parameter&quot;, &quot;description&quot;: &quot;The target .net framework for the project.&quot;, &quot;datatype&quot;: &quot;choice&quot;, &quot;choices&quot;: [ { &quot;choice&quot;: &quot;net6.0&quot;, &quot;description&quot;: &quot;Target net6.0&quot; }, { &quot;choice&quot;: &quot;net5.0&quot;, &quot;description&quot;: &quot;Target net5.0&quot; } ], &quot;replaces&quot;: &quot;net6.0&quot;, &quot;defaultValue&quot;: &quot;net6.0&quot; }, &quot;UseAuthorize&quot;: { &quot;type&quot;: &quot;parameter&quot;, &quot;datatype&quot;: &quot;bool&quot;, &quot;defaultValue&quot;: &quot;false&quot;, &quot;description&quot;: &quot;this application add authorize.&quot; }, &quot;SeparateRouteHandler&quot;: { &quot;type&quot;: &quot;parameter&quot;, &quot;datatype&quot;: &quot;bool&quot;, &quot;defaultValue&quot;: &quot;false&quot;, &quot;description&quot;: &quot;route handler use a separate file.&quot; }, &quot;IsLast&quot;: { &quot;type&quot;: &quot;computed&quot;, &quot;value&quot;: &quot;(Framework == \\&quot;net6.0\\&quot;)&quot; } }, &quot;primaryOutputs&quot;: [ { &quot;path&quot;: &quot;Masa.Web.csproj&quot; } ], &quot;postActions&quot;: [ { &quot;description&quot;: &quot;Restore NuGet packages required by this project.&quot;, &quot;manualInstructions&quot;: [ { &quot;text&quot;: &quot;Run 'dotnet restore'&quot; } ], &quot;actionId&quot;: &quot;210D431B-A78B-4D2F-B762-4ED3E3EA9025&quot;, &quot;continueOnError&quot;: true } ]} exclude 指定路径数组支持 Dic/** 以及 Dic/*.cs 的方式 ide.host.json该文件只有两个简单的定义，通过 icon 指定模板图标（相对路径），symbolInfo 定义参数信息，如 vs 上显示哪些参数以及参数说明和默认值等。 示例文件内容： 1234567891011121314151617181920212223242526272829303132{ &quot;$schema&quot;: &quot;http://json.schemastore.org/vs-2017.3.host&quot;, &quot;icon&quot;: &quot;WebAPI.png&quot;, &quot;symbolInfo&quot;: [ { &quot;id&quot;: &quot;Framework&quot;, &quot;name&quot;: { &quot;text&quot;: &quot;.net framework&quot; }, &quot;description&quot;: { &quot;text&quot;: &quot;.net framework for the project&quot; }, &quot;isVisible&quot;: true, &quot;defaultValue&quot;: &quot;net6.0&quot; }, { &quot;id&quot;: &quot;UseAuthorize&quot;, &quot;name&quot;: { &quot;text&quot;: &quot;the project use authorize&quot; }, &quot;isVisible&quot;: true }, { &quot;id&quot;: &quot;SeparateRouteHandler&quot;, &quot;name&quot;: { &quot;text&quot;: &quot;separate route handler file&quot; }, &quot;invertBoolean&quot;: false, &quot;isVisible&quot;: true } ]} invertBoolean 参数的值为 true 时会将 bool 类型参数的值反转，如 SeparateRouteHandler 的值在指定为 true 时，模板的判断逻辑代码中这个值会变为 false。 dotnetcli.host.jsoncli 的 json 文件中只定义了一个 symbolInfo 参数，定义命令行方式创建模板时参数的短名称。 示例文件内容： 12345678910111213141516{ &quot;$schema&quot;: &quot;http://json.schemastore.org/dotnetcli.host&quot;, &quot;symbolInfo&quot;: { &quot;Framework&quot;: { &quot;longName&quot;: &quot;framework&quot; }, &quot;UseAuthorize&quot;: { &quot;longName&quot;: &quot;use-authorize&quot;, &quot;shortName&quot;: &quot;au&quot; }, &quot;SeparateRouteHandler&quot;: { &quot;longName&quot;: &quot;separate-route-handler&quot;, &quot;shortName&quot;: &quot;separate&quot; } }} 自定义模板仅列出.Net 相关项目文件，其它类型文件可参考自定义语言操作符部分。 自定义 CS 文件cs 文件自定义使用类似预编译指令的方式 ,使用 #if ,#endif等命令自定义输出逻辑 123456#if (SeparateRouteHandler)using Masa.Web;#endif#if(UseAuthorize)using Microsoft.AspNetCore.Authentication.JwtBearer;#endif 如果判断流程复杂且模板文件变动较大可以参考 aspnetcore 官网模板实例，定义两个独立文件再通过 rename 和 exclude 控制模板输出内容。 1234567{ &quot;condition&quot;: &quot;(UseMinimalAPIs &amp;&amp; (IndividualAuth || OrganizationalAuth))&quot;, &quot;rename&quot;: { &quot;Program.MinimalAPIs.OrgOrIndividualB2CAuth.cs&quot;: &quot;Program.cs&quot; }, &quot;exclude&quot;: [&quot;Program.MinimalAPIs.WindowsOrNoAuth.cs&quot;]} 自定义 csproj 文件csproj 文件使用注释的方式，判断参数控制逻辑 123&lt;!--#if(UseAuthorize)--&gt;&lt;PackageReference Include=&quot;Microsoft.AspNetCore.Authentication.JwtBearer&quot; Version=&quot;6.0.0&quot; /&gt;&lt;!--#endif--&gt; 自定义 json 文件json 文件同样使用注释的方式 12345//#if(EnableOpenAPI)&quot;launchUrl&quot;: &quot;swagger&quot;,//#else&quot;launchUrl&quot;: &quot;weatherforecast&quot;,//#endif 自定义语言操作符语言操作符即模板引擎识别为流程控制的标记，通常为对应文件类型的注释标记，在Github列出了支持的文件类型和操作符。 可以在 template.json 中增加 SpecialCustomOperations 节点，扩展默认不支持的文件类型或者重写现有的操作符的定义。 如增加 md 文件的语言操作符： 1234567891011121314151617&quot;SpecialCustomOperations&quot;: { &quot;**/*.md&quot;: { &quot;operations&quot;: [ { &quot;type&quot;: &quot;conditional&quot;, &quot;configuration&quot;: { &quot;if&quot;: [&quot;---#if&quot;], &quot;else&quot;: [&quot;---#else&quot;], &quot;elseif&quot;: [&quot;---#elseif&quot;, &quot;---#elif&quot;], &quot;endif&quot;: [&quot;---#endif&quot;], &quot;trim&quot; : &quot;true&quot;, &quot;wholeLine&quot;: &quot;true&quot;, } } ] }} 然后 md 文件中定义模板输出： 123456789# This is an example Markdown---#if (FooBar)Foo bar---#elif (BarBaz)Bar baz---#elseBaz qux---#endif 安装、卸载模板在项目根目录下执行dotnet new -i ./ 命令安装自定义的模板。 卸载模板命令：dotnet new -u ./ 如果不是模板目录则需要指定模板全路径 模板发布到 nuget,参考官网模板定义一个templates.nuspec文件，执行 nuget.exe pack 命令即可。","link":"/2021/12/02/independent/template/dotnet_template/"},{"title":"Blazor是春天还是寒风里的挣扎","text":"官方解释 BlazorBlazor 允许您使用c#而不是 JavaScript构建交互式web UI。 Blazor 应用由可重用的 web UI 组件组成，这些组件使用 c#、HTML 和 CSS 实现。客户端和服务器代码都是用 c#编写的，允许您共享代码和库。 Blazor 是一个使用 .NET 生成交互式客户端 Web UI 的框架： 使用 C# 代替 JavaScript 来创建信息丰富的交互式 UI。 共享使用 .NET 编写的服务器端和客户端应用逻辑。 将 UI 呈现为 HTML 和 CSS，以支持众多浏览器，其中包括移动浏览器。 与新式托管平台（如 Docker）集成。 使用 .NET 进行客户端 Web 开发可提供以下优势： 使用 C# 代替 JavaScript 来编写代码。 利用现有的 .NET 库生态系统。 在服务器和客户端之间共享应用逻辑。 受益于 .NET 的性能、可靠性和安全性。 在 Windows、Linux 和 macOS 上使用 Visual Studio 保持高效工作。 以一组稳定、功能丰富且易用的通用语言、框架和工具为基础来进行生成。 看到这里有些小伙伴手中的瓜已经要丢出来了，的确有部分是夸大了的，起码 VS 在三个平台高效工作这事儿，嗯。。。其他的继续吃瓜吧 Blazor Vs MVC什么是 MVC官方解释：ASP.NET Core MVC 是使用“模型-视图-控制器”设计模式构建 Web 应用和 API 的丰富框架。 圈重点，Blazor 是交互式 Web UI，而 MVC 是 Web 应用和 API 什么是交互式 Web UI谷歌、百度转了一圈，没有这个解释，连 Wiki 也是一脸懵逼。 尝试理解一下吧，交互式 Web UI 重点在于交互，而 Blazor 的官方解释是用 C#代替 JavaScript，那我们看看 JavaScript 有什么功能，我百度找一段过来： 嵌入动态文本于 HTML 页面 对浏览器事件做出响应 读写 HTML 元素 在数据被提交到服务器之前验证数据 检测访客的浏览器信息。控制 cookies，包括创建和修改等 有这些基础功能，用户不需要在静态页面里跳来跳去了，的确体验会好很多 Blazor 有什么优势提供了一些交互能力，不再是纯粹的静态页，虽然 mvc 可以使用 JavaScript 达到同样的效果，但你需要掌握 JavaScript，甚至还要再学习 jQuery、Angular、Vue 等。而 Blazor 提供的交互能力则是使用 C#。 吹是吹完了，但你真的可以 100% C#吗？这很难，你会遇到各种问题，比如兼容性、性能等。好了，那我可以不用了吗？等等，下面还有瓜 Blazor Vs 现代前端(Angular、Vue 等)我们从几个方面来对比一下吧 调试 Blazor：Vistual Stuidio + F5，VS Code/命令行工具 + dotnet watch 比 WebPack 要快很多，跟 Vite 差不多 在非复杂场景下 Hot Reload 是可以的，但奇奇怪怪的问题太多了，前景很好，目前来看还是用 Ctrl + F5 启动或者用命令行吧 VS 2022 的 Ctrl + F5 已经支持 Hot Reload 了 现代前端：Webpack/Vite 全家桶以 Vue 为例，Vue 全家桶包括 Vue Cli、Vue Router、Vuex Blazor： Cli：dotnet cli Router：Microsoft.AspNetCore.Components.Routing.Router Vuex：Blazor 状态管理，区别在于 WASM 状态保存在浏览器内存中，而 Server 保存在服务器内存中。而且 Blazor 状态管理更强大的是借助.Net 的能力，原生支持持久化存储、跨线路保存（Server 下共享服务器内存）、ASP.NET Core 受保护的浏览器存储（Server 独享功能） 组件库主流的 Bootstrap, Ant Design, Material Design 等双方都有。但由于现代前端多年的积累，质量上的确有一定差距。 除了丰富程度上，Blazor 允许被 JavaScript 调用加载，并生成 Angualr、React 等组件。 虽然这看起来跟用 C#解决代替 JavaScript 有点冲突，但融入大环境也是不错的 下图演示的是 Blazor 提供的 inventory-grid Component 被 React 引用的例子(当然也可以给 Angular)： 更神奇的是，在 React 复用的 Blazor Component 居然也支持 Hot Reload。先不说 Hot Reload 到底如何，单是这个方向其实还是值得期待一下 Hot Reload 的未来吧。 不止可以给 React 提供复用的组件，还可以给 WPF 第三方库举几个前端常用库来比较。 网络：现代前端有 axios，Blazor 有 HttpClient 数据操作：现代前端有 Lodash，Blazor 有 Linq 时间：现代前端有 moment.js、Day.js，Blazor 有 DateTime 全家桶 响应式编程：现代前端有 rx.js，Blazor 有 Rx.Net（没有用过，理论上.Net 基本都能用，欢迎纠错） Mock：现代前端有 Mock.Js，Blazor 有 Moq，当然除了 mock 以外还有端到端的，双方也都有。 对比下来其实.Net 反而还有点优势，那就完美吗？当然不是，再说点劣势的部分吧。 Charts：现代前端有 ECharts 等，Blazor 不想说话 虽然目前 Blazor 的确没有成熟、免费的 Charts 组件库，但因为 Blazor 可以与 JS 交互的能力，调用 ECharts 也很简单，稍微考验一点点小伙伴的动手能力 富文本编辑器、拖拽。。。 Blazor 骂骂咧咧的退出了群聊。。。 包管理Blazor：NuGet 现代前端：NPM、Yarn 性能数据不直观，先从.Net Conf 2021 上的演示截图看一下： 有量化数据吗？有： 视频地址：https://sec.ch9.ms/ch9/daba/468d5211-982b-4c86-8b51-e1c8824edaba/dotNETConfNewBlazorWebAssembly_high.mp4 那 AOT 可以解千愁吗？也不是。起码应用大小上来说的确也大了不少，但这并不妨碍 AOT 可以解决特定场景的问题。技术总要选择在适合的场景使用它，而不是盲目的。 完了吗当然没有，其实这样比较对于 Blazor 是不公平的，因为 Blazor 站在.Net 的肩膀上有更多的亮点，比如原生支持的泛型、DI、面向对象设计（虽然 TS 也是）、数不过来的.Net 类库、跨平台应用（MAUI）等。 其实没有必要只看到 Blazor 的劣势，也可以看看站在.Net 上的前端能走多远，这不也是我们期待的吗？ 看到这里，有些.Net 古董级大佬要出来发话了，Silverlight！是的，但这次 WASM 没有再要求下载插件了。 Web Assembly Vs Server（服务器端渲染）Web Assembly：WebAssembly 是一种新的编码方式，可以在现代的网络浏览器中运行 － 它是一种低级的类汇编语言，具有紧凑的二进制格式，可以接近原生的性能运行，并为诸如 C / C ++等语言提供一个编译目标，以便它们可以在 Web 上运行。它也被设计为可以与 JavaScript 共存，允许两者一起工作。 Server（Server Side Render - SSR）：将组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。 为什么用 SSR服务器端渲染 (SSR) 的优势主要在于： 更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。 更快的内容到达时间 (time-to-content) 什么时候用 SSR使用服务器端渲染 (SSR) 时还需要有一些权衡之处： 开发条件所限。浏览器特定的代码，只能在某些生命周期钩子函数 (lifecycle hook) 中使用；一些外部扩展库 (external library) 可能需要特殊处理，才能在服务器渲染应用程序中运行。 涉及构建设置和部署的更多要求。与可以部署在任何静态文件服务器上的完全静态单页面应用程序 (SPA) 不同，服务器渲染应用程序，需要处于服务端运行环境。 更多的服务器端负载。 服务器端渲染 vs 预渲染 (SSR vs Prerendering)如果你调研服务器端渲染 (SSR) 只是用来改善少数营销页面（例如 /, /about, /contact 等）的 SEO，那么你可能需要预渲染。无需使用 web 服务器实时动态编译 HTML，而是使用预渲染方式，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点。 Blazor Server 支持 Prerendering Blazor 该选 Web Assembly 还是 Server看一下.Net Conf 2021 大会上的一张图： 总结一下： Server 要持久化长连接，有更高的 UI 延迟 Web Assembly 则是更大的下载大小，和更慢的运行时性能 我们在做什么又是一个老生常谈的问题，.Net 的覆盖面太广了也导致很难解决所有问题。我们在权衡利弊之后是不是可以为.Net 生态共建出自己小小的一份力呢？ 开源的组件库再回到组件库上，目前市面上的组件库其实不少了，何必要继续在这个泥潭里插一脚呢？ 开发过组件库的同学，或者贡献过源码的同学应该都体会到了，写一个组件是多么的复杂。而大家对于一个设计的审美角度也是不同的。当你喜欢的设计没有提供实现怎么办？从头写吗，那太累了，所以我们尝试了一件事情。 先看一下大概思路： 简单的剖析一下： 在 Blazor 的基础上，构建一个新的组件库叫 Blazor Component 那他有哪些特性呢？ 只提供交互，不提供样式 标准化 Dom 结构 开放几乎所有可以自定义的 Slots（插槽，概念引自 Vue），允许你替换 Slots 的 Dom 插槽与交互的统一单元测试（目前正在 38%，短期目标是 80%，长期目标是 90%+） 基于 Material Design（样式引自 Vuetify）的示例项目，可以达到生产可用（我们自己的公司在用，也是世界五百强企业在用） 快速实现新的组件库，只需要基于某个 Design + 样式控制属性 + 特殊交互即可 未来是值得憧憬的，我们希望未来是这样的： 惭愧，蹭了一波字节的热度 MASA Blazor基于 Blazor Component 和 Material Design 的 Blazor 组件库 截止目前共 68 个基础组件，后续会继续增加 预置组件，提供与.Net 功能深度集成且常用组合类组件，如 Url、面包屑、菜单三联动，高级搜索，i18n 等 MASA Blazor Pro 提供多种常见场景的预设布局 全职团队维护，Issue 快速响应 知名企业在用，未来 MASA Stack 产品线也将一直使用，持续增加新功能 免费、开源 我们还计划未来支持一键切换主题（代码切换已经提供）、预置布局、数据展示类组件、WorkFlow 类组件等。 MASA Blazor Pro基于 MASA Blazor 提供的 Admin 模板，先放几张设计稿吧，源码会跟 MASA Blazor 一起放出。 MASA EShop基于 MASA Framework 搭建的 EShopOnDapr，将会使用 MASA Blazor Pro 提供完整的前后端示例 开源地址：https://github.com/masalabs/MASA.EShop 总结说到底没有完美的技术，在你权衡利弊之后在正确的场景使用它就是最合适的。 是春天还是寒冬也不重要，重要的是当下这一刻，它是否解决了你的痛点。 最后，一个小小的广告 MASA Blazor 即将发布，敬请期待，如果你对我们的组件库感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们 参考 https://dotnet.microsoft.com/apps/aspnet/web-apps/blazor https://docs.microsoft.com/zh-cn/aspnet/core/blazor/state-management?view=aspnetcore-6.0&amp;pivots=server#persist-state-across-circuits https://sec.ch9.ms/ch9/daba/468d5211-982b-4c86-8b51-e1c8824edaba/dotNETConfNewBlazorWebAssembly_high.mp4 https://developer.mozilla.org/zh-CN/docs/WebAssembly https://ssr.vuejs.org/zh/","link":"/2021/10/25/masa/activities/NetConfChina/2021/"},{"title":"MASA Auth - 权限设计","text":"权限术语 Subject：用户，用户组 Action：对Object的操作，如增删改查等 Object：权限作用的对象，也可以理解为资源 Effect：规则的作用，如允许，拒绝 Condition：生效条件 Permission：允许（拒绝）用户（用户组）在条件允许下对对象（资源）的动作 Role：权限集合，权限数量&gt;=1 RBACRBAC (Role-Based Access Control，基于角色的访问控制)，引入了 Role（角色）的概念，并且将权限与角色进行关联。用户通过扮演某种角色，具有该角色的所有权限。 即权限，角色，用户之间的关系是多对多对多 RBAC0 用户 角色 权限 会话 用户和角色的关系是多对多 权限和角色的关系是多对多 RBAC1 角色继承 权限扩展 RBAC2 互斥约束 用户，角色，权限均可互斥。不允许存在任意冲突。 基数约束 角色分配次数受限，比如一个公司只有一个CEO 先决条件角色 权限赋予要从低到高。如：要先有XX副总权限才能获取XX总权限。 静态职责分离（目前先支持静态职责分离） 用户无法被赋予冲突的角色 动态职责分离 用户会话中无法激活冲突的角色 RBAC3RBAC0 + RBAC1 + RBAC2 ABACAttribute Based Access Control，基于属性的权限验证。允许更细粒度的控制X属性的Y资源在Z条件下进行A操作。相较于RBAC，会对开发人员提出更高的要求，目前我们先只介绍到RBAC。 举个例子我们通过预设博客文章场景来反推实现方式 用户角色 一篇文章要面对两种角色，即：读者，管理员 1234567[{ &quot;Subject&quot;: &quot;Avril&quot;, &quot;Roles&quot;:[&quot;ArticleReader&quot;]}, { &quot;Subject&quot;: &quot;Dodd&quot;, &quot;Roles&quot;:[&quot;ArticleManager&quot;]}] 角色 读者将获得读文章权限，管理员则获得管理文章权限 12345678910111213[ { &quot;Name&quot;: &quot;ArticleReader&quot;, &quot;Permissions&quot;: [ &quot;ReadArticle&quot; ] }, { &quot;Name&quot;: &quot;ArticleManager&quot;, &quot;Permissions&quot;: [ &quot;ManageArticle&quot; ] }] 权限 角色有了，依赖的权限也有了，接下来我们需要继续把权限明细确认一下 12345678910111213[ { &quot;Name&quot;: &quot;ReadArticle&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: [&quot;Read&quot;], &quot;Object&quot;: [&quot;Article&quot;] }, { &quot;Name&quot;: &quot;ManageArticle&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: [&quot;Create&quot;, &quot;Read&quot;, &quot;Update&quot;, &quot;Delete&quot;], &quot;Object&quot;: [&quot;Article&quot;] }] 依赖模型基于RBAC3的依赖模型 用户管理简单的引入一个RBAC无法满足一个工程化的项目，比如批量操作，前后端集成等 团队单个用户的管理已经出来了，但日常中我们很少会对单个用户进行授权。更多的是针对一组（批）人进行操作。 前端集成到目前为止，我们设计的都还在后端。而前端关心的是页面展示相关的，比如菜单，页面元素等 等一下！ 这里要设计什么？或许可以偷个懒，在Objects里增加一个ObjectType用来区分菜单还是页面元素即可？ ObjectType被修改的可能性很小，所以我们将在SDK中提供枚举来支持 总结至此，我们把RBAC与用户管理的部分已经设计完了。或许它缺少了传统意义上的组织架构树，但它带来了更加松散的，扁平化的团队管理。 （本文章不代表最终设计） 开源地址MASA.BuildingBlocks：https://github.com/masastack/MASA.BuildingBlocks MASA.Contrib：https://github.com/masastack/MASA.Contrib MASA.Utils：https://github.com/masastack/MASA.Utils MASA.EShop：https://github.com/masalabs/MASA.EShop MASA.Blazor：https://github.com/BlazorComponent/MASA.Blazor 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们","link":"/2022/02/10/masa/basic-ability/auth/1.%20MASA%20Auth%20%E6%9D%83%E9%99%90%E8%AE%BE%E8%AE%A1/"},{"title":"MASA Auth - SSO与Identity设计","text":"AAAAAAAA即认证、授权、审计、账号（Authentication、Authorization、Audit、Account）。在安全领域我们绕不开的两个问题： 授权过程可靠：让第三方程序能够访问所需资源又不泄露用户数据，常用的多方授权协议主要有 OAuth2 和 SAML 2.0 授权结果可控：授权结果用于功能或资源的访问控制。常见的权限控制模型：DAC、MAC、RBAC、ABAC 想了解权限控制模型的话可以参照上一篇的权限设计 OpenId（Authentication）OpenID 是一个以用户为中心的数字身份识别框架，它具有开放、分散性。OpenID 的创建基于这样一个概念：我们可以通过 URI （又叫 URL 或网站地址）来认证一个网站的唯一身份，同理，我们也可以通过这种方式来作为用户的身份认证 对于支持OpenID的网站，用户不需要记住像用户名和密码这样的传统验证标记。取而代之的是，他们只需要预先在一个作为OpenID身份提供者（Identity Provider, IDP）的网站上注册。 OAuth2（Authorization）举个例子：MASA.Contrib使用codecov来分析单元测试覆盖率，OAuth2帮我解决了几个安全问题： 密码泄露：不需要把账号密码告诉codecov 访问范围：只开放读取源码的能力 权限回收：在Github上撤回授权即可关闭codecov的访问能力 那OAuth2是如何解决的呢 我们来看一张图 OIDC（Authentication &amp; Authorization）OpenID Connect 1.0是OAuth 2.0协议之上的一个简单的身份层。 它允许客户端基于授权服务器执行的身份验证来验证终端用户的身份，并以一种可互操作的、类似rest的方式获取关于终端用户的基本概要信息。 OIDC常用术语 EU：End User：终端用户 RP：Relying Party，用来代指OAuth2中的受信任的客户端，身份认证和授权信息的消费方 OP：OpenID Provider，有能力提供EU认证的服务（比如OAuth2中的授权服务），用来为RP提供EU的身份认证信息 ID Token：JWT格式的数据，包含EU身份认证的信息 UserInfo Endpoint：用户信息接口（受OAuth2保护），当RP使用Access Token访问时，返回授权用户的信息，此接口必须使用HTTPS OIDC工作流 RP发送一个认证请求给OP OP对EU进行身份认证，然后提供授权 OP把ID Token和Access Token（需要的话）返回给RP RP使用Access Token发送一个请求UserInfo EndPoint UserInfo EndPoint返回EU的Claims JWTJWT（JSON Web token）是一个开放的、行业标准的RFC 7519方法，用于在双方之间安全地表示声明。 JWT由3部分组成：标头(Header)、有效载荷(Payload)和签名(Signature)。在传输的时候，会将JWT的3部分分别进行Base64编码后用.进行连接形成最终传输的字符串 JWT=Base64(Header).Base64(Payload).HMACSHA256(base64UrlEncode(header)+”.”+base64UrlEncode(payload),secret) HeaderJWT头是一个描述JWT元数据的JSON对象，alg属性表示签名使用的算法，默认为HMAC SHA256（写为HS256）；typ属性表示令牌的类型，JWT令牌统一写为JWT。最后，使用Base64 URL算法将上述JSON对象转换为字符串保存 1234{ &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot;} Payload有效载荷部分，是JWT的主体内容部分，也是一个JSON对象，包含需要传递的数据（允许自定义）。 12345{ &quot;sub&quot;: &quot;1234567890&quot;, &quot;name&quot;: &quot;John Doe&quot;, &quot;iat&quot;: 1516239022} Signature签名哈希部分是对上面两部分数据签名，需要使用base64编码后的header和payload数据，通过指定的算法生成哈希，以确保数据不会被篡改 12345HMACSHA256( base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), your-256-bit-secret) Identity Server 4常用术语 Client：一个从 IdentityServer 请求令牌的软件——用于验证用户（请求身份令牌）或访问资源（请求访问令牌）。客户端必须先向 IdentityServer 注册，然后才能请求令牌 Allowed Scopes：即可以是Identity Resource，也可以是Api Scopes和Api Resources Resource：您希望使用 IdentityServer 保护的东西，如用户的身份数据或 API。资源名称唯一 API Scope：API作用域 可以当做是Permission来用，示例见：https://docs.duendesoftware.com/identityserver/v6/fundamentals/resources/api_scopes/ Identity Resource：关于用户的身份信息（又名声明），例如姓名或电子邮件地址 User Claims：身份声明，例如sub，name，amr，auth_time等 Identity Properties：身份资源本身的一些属性，例如session_id，issued，expired等 Identity Grants：被授予的身份信息 API Resource：一组API Scope User Claims：需要包含在Access Token中的用户声明列表 API Resource Scope：API资源包含的作用域 API Properties：API本身的一些属性，例如name, display name, description等 API Grants：被授权的API列表 Identity Token：身份令牌代表身份验证过程的结果。它至少包含用户的标识符以及有关用户如何以及何时进行身份验证的信息。它可以包含额外的身份数据 Access Token：访问令牌允许访问 API 资源。客户端请求访问令牌并将其转发到 API。访问令牌包含有关客户端和用户（如果存在）的信息。 API 使用该信息来授权访问其数据 Grant Types：授权类型（其实还有Resource owner password，不推荐使用，就不过多介绍了） 参考自：https://docs.duendesoftware.com/identityserver/v6/overview/terminology/ Machine/Robot：Client Credentials Web Applications：Authorization Code With PKCE（Proof Key for Code Exchange） 通常我们会选择id_token token作为response type 还有一个选择，就是Implicit。但在隐式流程中，所有令牌都通过浏览器传输，因此不允许刷新令牌等高级功能。作用范围就是仅用于用户身份验证（服务器端和 JavaScript 应用程序），或身份验证和访问令牌请求（JavaScript 应用程序） SPA：Authorization Code With PKCE Native/Mobile Apps：Authorization Code With PKCE TV/Limited Input Device：Device Flow RFC 8628 ASP.Net Core Identity常用术语 User：用户 Action：操作，包括增删改查 User Role：用户角色 User Claim：用户声明 Role：角色 Action：操作，包括增删改查 Role Claim：角色声明 Claim： 声明是一个名称值对，表示使用者是什么，而不是使用者可以做什么。 基于声明的授权检查声明的值并允许基于该值的资源访问 Policy：策略 Require Role：要求角色 Require Claim：要求声明 Require Assertion：更复杂的可以通过要求断言来解决，它支持两个重载的Func（实际是一个，因为有一个是Task） Requirements：基于IAuthorizationRequirement接口定义一个要求，判断要求要基于AuthorizationHandler&lt;T&gt;来实现对应的逻辑 默认策略 回退策略 自定义授权属性 Resource：资源 Imperative：官方翻译是命令式，可以对特定的资源进行授权策略处理 依赖模型 集成RBAC通过.Net Core Identity的User Claimns将User Role与Api Resource、Api Scope、Identity Resource相关联，可以在不同业务维度下获取到用户的角色 再配合ASP.Net Core Identity的Role或Policy进行资源授权判断来达到SSO与RBAC的业务落地 总结本章节涉及到OIDC、ASP.Net Core Identity和RBAC三部分内容。首先OIDC的知识体系就比较庞大，需要根据比较完善的文档把概念都搞清楚以及为什么这么设计的原因，其次还要进行一些微调把OIDC、RBAC与ASP.Net Core Identity三者结合。可以看出依赖模型其实是个很粗的把各个环节串了起来，但实际落地过程中还免不了对依赖模型进行二次调整来满足不同业务的需求。后续等MASA Auth落地后会再出第三篇文章来回顾和还原实际落地过程。 （本文章不代表最终设计） 开源地址MASA.BuildingBlocks：https://github.com/masastack/MASA.BuildingBlocks MASA.Contrib：https://github.com/masastack/MASA.Contrib MASA.Utils：https://github.com/masastack/MASA.Utils MASA.EShop：https://github.com/masalabs/MASA.EShop MASA.Blazor：https://github.com/BlazorComponent/MASA.Blazor 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们","link":"/2022/02/10/masa/basic-ability/auth/2.%20MASA%20Auth%20SSO%E4%B8%8EIdentity%E8%AE%BE%E8%AE%A1/"},{"title":"MASA Auth - 从用户的角度看整体设计","text":"用户在系统里，用户是一个核心概念。它代表了一个人的唯一身份标识，除了与角色、团队、组织架构等有关，甚至还会影响到在同一个界面不同的用户操作流程与显示内容都会发生变化，再复杂一点的话，或许在同一个系统内的一个用户进入到不同产品后的身份也会变化 用户与角色用户可以拥有一个或多个角色，让角色作为权限组，将一组或多组权限间接的分配给用户 用户与团队用户可以在多个团队中，每个团队可以拥有一个或多个角色，将一组或多组权限通过角色与团队关联，并赋予团队内的成员 团队内成员可以是内部的，也可以是外部的。通过统一的用户表作为人的唯一身份标识。再通过Employee和ThirdPartyUser区分用户身份属性。 用户与组织架构用户可以被指定在组织架构的某一个节点中 但组织架构是一个虚拟的树形结构，它归属于业务，所以没有与权限直接关联 除此之外，组织架构有时候很难表示角色继承关系。在同一个组织架构节点中的不同成员常常会具有不同的角色，且上下级关系也未必会作为上下级节点紧贴在一起。有部分公司上下级之间可能隔了几个层级 组织架构在我们早期定义中是与权限关联且没有团队这个概念的。但实际上项目制在很多公司内部都存在，以项目制运行时，人员的权限和虚拟组织关系会频繁变化。导致常常要在组织架构调整和大量个人权限微调上做抉择，为了彻底解决这种割裂的行为。我们把组织架构看作虚拟的树形结构来描述每个人的部门归属权，同时采用团队的方式解决项目制下人员频繁进出和四处作战而引发的权限变更问题 用户与权限用户除了拥有角色以外，可能还存在个别特殊业务下需要临时性授予或禁用部分权限 虽然与RBAC2有一点冲突，但事实上这样的场景的确存在，比如即将离职的财务需要临时收回付款功能，这里明显要违背互斥原则，在设计上我们的选择是扩展权限的优先级高于角色内包含的权限。这样可以通过对冲达到收回部分敏感权限的功能 用户类型用户有三种类型：终端用户，员工，驻场员工 举个例子： A是公司员工，拥有内部权限。同时也是公司产品的终端用户 B是驻场员工，拥有部分内部权限。同时也是公司产品的终端用户 用户权限优先级用户的权限应该具有一定的优先级，来解决同一个业务下多个权限同时生效时系统该选择激活哪一个 我们将采用以下规则： 超级管理员/管理员 超级管理员为系统管理员，管理员为指定项目的管理员 用户的扩展配置权限 用户的角色权限 用户的角色权限冲突时，拒绝优先级高于允许，低于用户的扩展配置权限 团队的默认角色权限 团队中的父级角色权限 将来在团队支持上下级关系后，当前用户没有被分配到权限，且当前团队存在父级时将向上递归查找距离最近的默认角色来获得权限列表 用户权限类型用户的权限类型大概分为四类 菜单：是否可以通过菜单访问某个页面 页面元素：是否可以对页面内的元素进行操作，如按钮。页面元素需要挂在菜单下 数据：是否显示指定字段。数据需要挂在菜单下 数据与页面元素类似，但与页面元素之间相互独立 API：是否可以访问指定API。API一般需要挂在菜单或页面元素下，如有需要也可以挂在数据下 权限层级 总结至此，我们从一个用户的角度将角色和权限，前端与后端都串联了起来。但到目前为止还是概念的梳理阶段，做好一个权限中心很难。每个团队有自己的管理方式，如何在不同的团队需求中摘取到共同点把主线串联起来，既能满足绝大部分场景需求又留有扩展余地仍然需要时间去验证。 （本文章不代表最终设计） 参考： https://uxdesign.cc/design-permissions-for-a-saas-app-db6c1825f20e 开源地址MASA.BuildingBlocks：https://github.com/masastack/MASA.BuildingBlocks MASA.Contrib：https://github.com/masastack/MASA.Contrib MASA.Utils：https://github.com/masastack/MASA.Utils MASA.EShop：https://github.com/masalabs/MASA.EShop MASA.Blazor：https://github.com/BlazorComponent/MASA.Blazor 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们","link":"/2022/02/10/masa/basic-ability/auth/3.%20MASA%20Auth%20%E4%BB%8E%E7%94%A8%E6%88%B7%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8B%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1/"},{"title":"MASA Framework - 整体设计思路","text":"源起年初我们在找一款框架，希望它有如下几个特点： 学习成本低 只需要学.Net 每年主推的技术栈和业务特性必须支持的中间件，给开发同学减负，只需要专注业务就好 个人见解：一款好用的框架应该是补充，而不是颠覆或过度创新 对扩展开放 可以按照业务需求任意调整依赖实现，而不被捆绑在一个架构思路上 功能强大却不限制架构，从单体到 SOA 再到微服务都可以适应 因为一个系统中总有复杂的也有简单的，最好能全面覆盖我们的业务场景 行业不限 既能支持传统行业的业务特殊性，又可以支持互联网行业的高并发特性 稳定性 有严格的测试标准，用起来更安心 契机在我们做技术选型的时候，对 Dapr 的研究越深入，对我们想要做的事情就越清晰 站在 Dapr 的设计上我们找到了一个平衡点，Mecha 可以看下这篇文章（Mecha：将 Mesh 进行到底）：https://skyao.io/talk/202004-mecha-mesh-through-to-the-end/ Mecha 的特性 Mecha 是通用的，高度可配置的，可重用的组件，提供分布式原语作为现成的能力 Mecha 可以与单个 Micrologic 组件一起部署(Sidecar 模式)，也可以部署为多个共享(注：我称之为 Node 模式) Mecha 不对 Micrologic 运行时做任何假设。它与使用开放协议和格式（例如 HTTP/gRPC，JSON，Protobuf，CloudEvents）的多语言微服务甚至单体一起使用 Mecha 以简单的文本格式（例如 YAML，JSON）声明式地配置，指示要启用的功能以及如何将其绑定到 Micrologic 端点 与其依靠多个代理来实现不同的目的（例如网络代理，缓存代理，绑定代理），不如使用一个 Mecha 提供所有这些能力 换个角度看 Mecha Mecha 提供的是能力，不论是单体还是分布式 Mecha 与服务之间交互是有开放 API 标准的 Mecha 可以通过文本格式（Yaml 或 Json）声明式地配置 对于.Net 开发来说，更习惯用 Json 应用需要多种多样的能力，Mecha 提供了一整套解决方案却不强绑定你所有都要用到，按需即可 每个能力有不同的实现版本，可以根据自身业务情况替换其中某一部分的能力 为什么是 MechaMecha 的好处是业务逻辑和越来越多的分布式系统问题之间的松耦合，除了可以解决分布式以外，我们是否也可以延展成业务逻辑和架构之间的松耦合？ 当然，说到底就是 dll 而已 在分布式架构中，它以 Sidecar 的形式守护在应用身旁。 如果在.Net 项目中，它是否可以类似.Net Framework 作为基建/适配器/中间件/总线等身份驻留在.Net 进程中提供基础能力？ 设计思路一个完整的设计要先从概念开始，为了降低学习成本我们直接复用 Dapr 的概念定义 概念构建块提供接口标准，并为了达到某个基础能力的串接不同组件（也通过接口），松耦合但不脱钩 组件基于接口标准的实现，比如服务间通讯提供 HttpClient 和 Dapr Service Invocation 等不同组件的实现 工具库提供更抽象的底层能力，供业务和组件完成自身功能，如缓存/配置/数据操作/安全等 Roadmap - v1.0 基于.Net 主推技术栈，不魔改，降低学习成本 提供项目模板，根据业务需求自由组合功能集合 支持单体架构，也支持分布式架构 支持 DDD 方法论，也支持 CQRS 尽量小的依赖集合，但不为了小而小 约定优于配置 有创新，且要经过生产验证 目前进展我们首先完成了用于指导架构相关的部分，如 DDD、CQRS、Minimal APIs 扩展等，并保持单元测试覆盖率在 90%以上，目前 93%。 以 Contrib 的目录结构为例： 12345678910111213141516171819202122232425262728293031323334353637MASA.Contrib├── solution items│ ├── nuget.config├── src│ ├── BasicAbility│ │ ├── MASA.Contrib.BasicAbility.Dcc Configuration API│ ├── Configuration│ │ ├── MASA.Contrib.Configuration│ ├── Data│ │ ├── MASA.Contrib.Data.UoW.EF Unit of work│ │ └── MASA.Contrib.Data.Contracts.EF Protocol EF version│ ├── DDD│ │ ├── MASA.Contrib.DDD.Domain In-process and cross-process support│ │ └── MASA.Contrib.DDD.Domain.Repository.EF│ ├── Dispatcher│ │ ├── MASA.Contrib.Dispatcher.Events In-process event│ │ ├── MASA.Contrib.Dispatcher.IntegrationEvents.Dapr│ │ └── MASA.Contrib.Dispatcher.IntegrationEvents.EventLogs.EF Cross-process event│ ├── ReadWriteSpliting│ │ └── CQRS│ │ │ └── MASA.Contrib.ReadWriteSpliting.CQRS CQRS│ ├── Service│ │ └── MASA.Contrib.Service.MinimalAPIs Best practices for [MinimalAPI]├── test│ ├── MASA.Contrib.Dispatcher.Events│ │ ├── MASA.Contrib.Dispatcher.Events.BenchmarkDotnetTest│ │ ├── MASA.Contrib.Dispatcher.Events.CheckMethodsParameter.Tests│ │ ├── MASA.Contrib.Dispatcher.Events.CheckMethodsParameterNotNull.Tests│ │ ├── MASA.Contrib.Dispatcher.Events.CheckMethodsParameterType.Tests│ │ ├── MASA.Contrib.Dispatcher.Events.CheckMethodsType.Tests│ │ ├── MASA.Contrib.Dispatcher.Events.OnlyCancelHandler.Tests│ │ ├── MASA.Contrib.Dispatcher.Events.CheckMethodsType.Tests│ │ ├── MASA.Contrib.Dispatcher.Events.Tests│ ├── MASA.Contrib.Data.UoW.EF.Tests│ ├── MASA.Contrib.Dispatcher.IntegrationEvents.EventLogs.EF.Tests│ ├── MASA.Contrib.DDD.Domain.Tests│ ├── MASA.Contrib.DDD.Domain.Repository.EF.Tests 有什么新功能 Minimal APIs 支持类似 Controller 的 API 分类聚合 Event Bus 支持 Hanlder 编排、SAGA、Middleware、事务控制、Event 和 Hanlder 解耦模式。相较于 MediatR 性能仅有 0.x%的差距但功能更加强大，可以面对更复杂的业务场景，并且已规划性能优化路线 Integration Event Bus 是 Event Bus 的增强版，支持分布式事务（最终一致性），与 Dapr 集成 Domain Event Bus 是 Event Bus 和 Integration Event Bus 的集成版，支持在领域内自动控制进程内与进程外的事件，支持实时发送也支持入栈后统一发送 更多功能等你来体验，也欢迎提意见 什么是 MASAMASA = Mesh Application Service Architecture，即网格应用服务架构 除了 MASA Framework，我们马上将开源 Blazor 组件库（MASA Blazor），包括管理后台模板（MASA Blazor Pro） 后续还有 MASA Stack 开源产品，基于 MASA Framework 打造的一站式 PaaS 平台，具备 DevOps、微服务观测治理、数据治理等平台级能力 示例 - MASA.EShopMASA.EShop 是使用 MASA.Framework 复刻了 eShopOnDapr 的功能，并提供了多种架构方式的示例。 支持 Docker Compose dapr component 配置 Blazor 版 EShop 网站（正在筹备更换为 MASA Blazor Pro 的 UI） 共享 Contracts 所有服务都使用 Minimal APIs 和 Dapr Pub/Sub 进行通信 MASA.EShop.Services.Basket 演示单体架构，使用 Dapr State Management MASA.EShop.Services.Catalog 演示 CQRS，使用 CQRS、贫血模型 MASA.EShop.Services.Ordering 演示 CQRS 与 Actor，使用 CQRS、贫血模型、Dapr Actor MASA.EShop.Service.Payment 演示 CQRS 与 DDD，使用 CQRS、DDD、充血模型 开源地址MASA.BuildingBlocks：https://github.com/masastack/MASA.BuildingBlocks MASA.Contrib：https://github.com/masastack/MASA.Contrib MASA.Utils：https://github.com/masastack/MASA.Utils MASA.EShop：https://github.com/masalabs/MASA.EShop 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们 参考 https://skyao.io/talk/202004-mecha-mesh-through-to-the-end/","link":"/2021/12/22/masa/framework/design/0.MASA%20Framework%20-%20%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/"},{"title":"MASA Framework - EventBus设计","text":"概述利用发布订阅模式来解耦不同架构层级，亦可用于解决隔离业务之间的交互 优点： 松耦合 横切关注点 可测试性 事件驱动 发布订阅模式发布者通过调度中心将消息发送给订阅者。调度中心解决发布与订阅者之间的关系，保证消息可以送达订阅者手中。 发布者与订阅者互不相识，发布者只管向调度中心发布消息，而订阅者只关心自己订阅的消息类型 多订阅者保序执行在常见的发布订阅模式中，的确很少见到类似的说法。但在实际业务中我们会有类似的需求，一个消息由调度中心协调多个订阅者按照顺序执行消息，同时还可以将上一个订阅者处理过的消息传递给下一个订阅者。这样既可以保留发布订阅模式的特性，又有了顺序执行逻辑的特性。 一个小思考：如果 EventBus 的配置支持动态调整的话，是否业务的执行顺序也可以被动态排列组合？ 换句话说它或许可以为进程内工作流提供了一个可能性 Event Sourcing（事件溯源）一种事件驱动的架构模式，可以用于审计和溯源 基于事件驱动架构 以事件为事实 业务数据由事件计算产生的视图，可以持久化也可以不持久化 CQRS（命令查询的责任分离）CQRS 是一种架构模式，能够使改变模型与查询模型的实现分离 Event Sourcing &amp; CQRS事件溯源可以与 CQRS 很好的配合 在 Command Handler 中持久化事件到 Event Store 的同时实时计算一个最终视图给 View DB 用于查询展示 在 Query 中既可以通过 View DB 获取最新状态，也可以通过 Event Store 来重放事件来校验 View 或用于更严谨的业务 SagaSaga 是一个长活事务被分解成可以交错运行的子事务集合。其中每个子事务都是一个保持数据库一致性的真实事务 每个 Saga 由一系列 sub-transaction Ti 组成 每个 Ti 都有对应的补偿动作 Ci，补偿动作用于撤销 Ti 造成的结果 两种执行顺序 T1, T2, T3…[Tx retry]…,Tn T1, T2, …, Tj, Cj,…, C2, C1 两种恢复策略 backward recovery，向后恢复，补偿所有已完成的事务，如果任一子事务失败。即上面提到的第二种执行顺序，其中 j 是发生错误的 sub-transaction，这种做法的效果是撤销掉之前所有成功的 sub-transation，使得整个 Saga 的执行结果撤销 forward recovery，向前恢复，重试失败的事务，假设每个子事务最终都会成功。适用于必须要成功的场景，执行顺序是类似于这样的：T1, T2, …, Tj(失败), Tj(重试),…, Tn，其中 j 是发生错误的 sub-transaction。该情况下不需要 Ci BuildingBlocks 的类视图作为接口标准，BuildingBlocks 中并没有过多的干涉实现方式，它只保留了最基础的功能流程限制，以达到最小 EventBus 的功能集合。至于最终是基于接口还是特性来实现订阅关系的，交还给 Contrib 自行决定。 事件用于本地事件的发布/订阅 IEvent：事件接口，IEvent&lt;TResult&gt;为带返回值的基础事件接口 IEventHanldler&lt;TEvent&gt;：事件处理器接口，ISagaEventHandler&lt;TEvent&gt;为 Saga 的实现提供了基础接口要求 IMiddleware&lt;TEvent&gt;：中间件接口，允许在事件执行前挂载预处理动作和时间执行后的收尾动作 IEventBus：事件总线接口，用于发送事件，并提供订阅关系维护和附加功能执行 集成事件用于跨进程事件的发布/订阅 IntegrationEventLog：集成事件日志，用于实现本地消息表的消息模型 IIntegrationEventLogService：集成事件日志服务接口 ITopic：发布/订阅的主题 IIntegrationEvent：集成事件接口 IIntegrationEventBus：集成事件总线，用于跨进程调用的事件总线 CQRS用于使改变模型与查询模型的实现分离 IQuery&lt;TResult&gt;：查询的接口 IQueryHandler&lt;TCommand,TResult&gt;：查询处理器接口 ICommand：可用于增删改等指令的接口 ICommandHandler&lt;TCommand&gt;：指令处理器接口 Event Bus要完成上述的这些功能，我们需要借助于 EventBus，它需要有以下基础功能 接收事件 维护订阅关系 转发事件 接收与转发事件这两个功能其实可以合并为一个接口，由发布者调用 Publish，再由 Event Bus 根据订阅关系转发即可 维护订阅关系在.Net 项目中，我们常见的用于扫描自动注册的方式是接口和特性 MediatR 支持接口的方式去扫描事件订阅关系，举个例子：IRequestHandler&lt;,&gt; 1234567public class PingHandler : IRequestHandler&lt;Ping, string&gt;{ public Task&lt;string&gt; Handle(Ping request, CancellationToken cancellationToken) { return Task.FromResult(&quot;Pong&quot;); }} 如果你的代码洁癖程度没有高的离谱，或许你希望是这样 123456789101112public class NetHandler : IRequestHandler&lt;Ping, string&gt;, IRequestHandler&lt;Telnet, string&gt;{ public Task&lt;string&gt; Handle(Ping request, CancellationToken cancellationToken) { return Task.FromResult(&quot;Pong&quot;); } public Task&lt;string&gt; Handle(Telnet request, CancellationToken cancellationToken) { return Task.FromResult(&quot;Success&quot;); }} 看着好像还行？如果很多呢？ 那有没有办法解决这个问题？ 特性！我们来看个例子 1234567891011121314public class NetHandler{ [EventHandler] public Task PingAsync(PingEvent @event) { //TODO } [EventHandler] public Task TelnetAsync(TelnetEvent @event) { //TODO }} 似乎我们找到了一个出路 多订阅者保序执行通过事件层层推进确实可以满足顺序执行的场景，但如果你被大量无限套娃的事件包围的时候或许你需要另外一个出路，看下例子： 1234567891011121314public class NetHandler{ [EventHandler(0)] public Task PingAsync(PingEvent @event) { //TODO } [EventHandler(1)] public Task LogAsync(PingEvent @event) { //TODO }} 只要参数是同一个 Event 就会按照 EventHandler 的 Order 顺序执行。 Saga那执行失败了怎么办，如果两个方法因为其中一个需要调用远程服务而无法跟本地事务结合，能帮我回滚吗？ 来吧，SAGA 走起，帮你再做个取消动作，同时还支持重试机制，以及是否忽略当前步骤的取消动作。 我们先来预设一下场景： 调用 CheckBalanceAsync 来检查余额 调用 WithdrawAsync, 抛出 exception 重试 WithdrawAsync 3 次 调用 CancelWithdrawAsync 代码如下： 123456789101112131415161718192021public class TransferHandler{ [EventHandler(1)] public Task CheckBalanceAsync(TransferEvent @event) { //TODO } [EventHandler(2, FailureLevels.ThrowAndCancel, enableRetry: true, retryTimes: 3)] public Task WithdrawAsync(TransferEvent @event) { //TODO throw new Exception(); } [EventHandler(2, FailureLevels.Ignore, enableRetry: false, isCancel: true)] public Task CancelWithdrawAsync(TransferEvent @event) { //TODO }} AOP举个业务场景，给所有 Command 在执行前增加一个参数验证 我们提供了 Middleware，允许像俄罗斯套娃一样（.Net Middleware）做横切关注点的相关的事情 12345678910111213public class LoggingMiddleware&lt;TEvent&gt; : IMiddleware&lt;TEvent&gt; where TEvent : notnull, IEvent{ private readonly ILogger&lt;LoggingMiddleware&lt;TEvent&gt;&gt; _logger; public LoggingMiddleware(ILogger&lt;LoggingMiddleware&lt;TEvent&gt;&gt; logger) =&gt; _logger = logger; public async Task HandleAsync(TEvent @event, EventHandlerDelegate next) { _logger.LogInformation(&quot;----- Handling command {EventName} ({@Event})&quot;, typeof(TEvent).FullName, @event); await next(); }} 注册 DI 1builder.Services.AddTransient(typeof(IMiddleware&lt;&gt;), typeof(LoggingMiddleware&lt;&gt;)) MASA EventBus 完整功能列表 接收事件 维护订阅关系 - 接口 维护订阅关系 - 特性 多订阅者顺序执行 转发事件 Saga AOP UoW 自动开启和关闭事务 Integration Event Bus用于跨服务的 Event Bus，支持最终一致性，本地消息表 Pub/Sub 提供了 Pub Sub 接口，并基于 Dapr Pub/Sub 提供默认实现 本地消息表 提供了本地消息保存和 UoW 联动接口，并基于 EF Core 提供默认实现 使用方法启用 Dapr Event Bus 1234567builder.Services .AddDaprEventBus&lt;IntegrationEventLogService&gt;(options=&gt; { options.UseUoW&lt;CatalogDbContext&gt;(dbOptions =&gt; dbOptions.UseSqlServer(&quot;server=localhost;uid=sa;pwd=Password;database=test&quot;)) .UseEventLog&lt;CatalogDbContext&gt;(); ) }); 定义 Integration Event 123456public class DemoIntegrationEvent : IntegrationEvent{ public override string Topic { get; set; } = nameof(DemoIntegrationEvent);//dapr topic name //todo other properties} 定义 DbContext（非必须，定义 DbContext 可以将本地消息表与业务事务联动） 123456789public class CustomDbContext : IntegrationEventLogContext{ public DbSet&lt;User&gt; Users { get; set; } = null!; public CustomDbContext(MasaDbContextOptions&lt;CustomDbContext&gt; options) : base(options) { }} 发送 Event 12IIntegrationEventBus eventBus; // from DIawait eventBus.PublishAsync(new DemoIntegrationEvent()); 订阅 Event（基于 Dapr Pub/Sub 的版本） 12345[Topic(&quot;pubsub&quot;, nameof(DomeIntegrationEvent))]public async Task DomeIntegrationEventHandleAsync(DomeIntegrationEvent @event){ //todo} Domain Event Bus在领域中同时提供 Event Bus 和 Integration Event Bus 的能力，允许实时发送事件或在 Save 时一次性触发 Domain Event Bus 是最完整的能力，所以使用 Domain Event Bus 相当于已经开启了 Event Bus 和 Integration Event Bus，在 Domain Event Bus 内部会自动协调事件分类往 Event Bus 和 Integration Event Bus 分流 启用 Domain Event Bus 123456789builder.Services.AddDomainEventBus(options =&gt;{ options.UseEventBus()//Use in-process events .UseUoW&lt;CustomDbContext&gt;(dbOptions =&gt; dbOptions.UseSqlServer(&quot;server=localhost;uid=sa;pwd=P@ssw0rd;database=idientity&quot;)) .UseDaprEventBus&lt;IntegrationEventLogService&gt;()///Use cross-process events .UseEventLog&lt;LocalMessageDbContext&gt;() .UseRepository&lt;CustomDbContext&gt;();}) 添加 DomainCommand Domain Event 是进程内事件，IntegrationDomainEvent 是跨进程事件 1234567891011public class RegisterUserSucceededIntegrationEvent : IntegrationDomainEvent{ public override string Topic { get; set; } = nameof(RegisterUserSucceededIntegrationEvent); public string Account { get; set; } = default!;}public class RegisterUserSucceededEvent : DomainEvent{ public string Account { get; set; } = default!;} 进程内事件订阅 12345[EventHandler]public Task RegisterUserHandlerAsync(RegisterUserDomainCommand command){ //TODO} 跨进程事件订阅 12345[Topic(&quot;pubsub&quot;, nameof(RegisterUserSucceededIntegrationEvent))]public async Task RegisterUserSucceededHandlerAsync(RegisterUserSucceededIntegrationEvent @event){ //todo} 发送 DomainCommand 12IDomainEventBus eventBus;//from DIawait eventBus.PublishAsync(new RegisterUserDomainCommand()); 使用场景 兼顾遗留系统对接 游走在云与非云中 流计算 微服务解耦和跨集群通信（需要将 Dapr Pub/Sub 改为 Dapr Binding，不难） 部分 AOP 类场景 总结事件驱动可以解决一些特定场景的问题，凡事都有两面性，在本来就很简单的业务场景中使用如此复杂的模式会带来不小的负担。 学以致用，学无止境。 开源地址MASA.BuildingBlocks：https://github.com/masastack/MASA.BuildingBlocks MASA.Contrib：https://github.com/masastack/MASA.Contrib MASA.Utils：https://github.com/masastack/MASA.Utils MASA.EShop：https://github.com/masalabs/MASA.EShop 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们","link":"/2021/12/22/masa/framework/design/1.MASA%20Framework%20-%20EventBus%E8%AE%BE%E8%AE%A1/"},{"title":"MASA Framework - DDD设计（1）","text":"DDD领域驱动设计是一个有关软件开发的方法论，它提出基于领域开发的开发模式，基于DDD理论，我们可以设计出高质量的软件模型。 它围绕业务概念构建领域模型来控制业务的复杂度，解决软件难以理解和演化的问题。 微服务微服务是一种架构风格，通过进程间通讯、容错和故障隔离等方式，实现去中心化的服务治理。 DDD与微服务它们都是高内聚、低耦合，从业务视角分离复杂度，提高响应能力。 高内聚：把相关的业务聚集在一起 低耦合：把关联性较低的拆分为独立的服务 使用DDD搭建微服务我们将获得以下优势： 设计清晰，规范 基于领域模型，有利于领域知识的传递和传承 帮助团队建立良好的沟通 协助系统架构的演进 提高团队的设计能力（面向对象，架构） 设计领域设计涉及技术与业务，如何让它们协作起来呢？ 战略设计（业务）领域、子域、限界上下文 将领域拆分成子域，并划分核心子域、支撑子域和通用子域 以子域展开事件风暴，根据上下文语义划分限界上下文，建立通用语言，完成领域建模 领域建模将作为能力中心规划的重要依据 完成能力中心地图和优先级后，作为微服务设计的输入完成战术设计 战术设计(技术)聚合、聚合根、实体、值对象、领域服务等 按照领域模型完成微服务设计和落地 建立聚合、聚合根、实体、值对象、领域服务等对象之间的依赖关系，以代码对象的形式映射到服务中，采用分层架构完成微服务设计和落地 分层架构可以采用Clean Architecture DDD实践过程我们将通过DDD + Clean Architecture完成业务与技术的完整落地 统一语言（战略设计）统一： 领域模型术语 DDD模式名称 技术： 技术设计术语 技术术语 技术设计模式 业务： 领域模型术语 DDD模式名称 业务术语 设计无关的业务术语 事件风暴（战略设计）Event Storming是一种领域建模的实践，可以让领域相关人员快速理解业务模型 完整流程包括如统一语言、提出领域事件、规则、命令、读模型、角色、划分子域、票选、补充商机与价值等， 接下来我们先精简一点步骤 活动准备人：业务人员，领域专家，技术人员，架构师，测试等 看板：可以将事件流可视化的白板或者画图工具等 彩色贴纸：填写事件，命令等 业务场景规定业务场景，下面我以一个电商项目为例 事件风暴结果 命令风暴结果 寻找聚合聚合：一组相关领域模型的集合，尽量保证封装业务的不变性，确保关联关系紧密的领域模型内聚 按事件顺序依次分析三个问题 事件改变的领域模型是什么 领域模型是否可以独立访问，是就是聚合 不能独立访问，需要通过哪个领域模型（聚合）来访问，将其放到对应聚合内 命令贴在聚合左边代表输入，事件贴到聚合右边代表输出 检验是否符合聚合规则，不匹配的重新调整聚合 聚合结果寻找聚合过程中可能会因为业务衔接产生新的输入命令，以虚线表示 划分限界上下文限界上下文：某个场景或环境下的业务边界 基于聚合和领域模型，判断它们要解决的业务问题，如果是同一个问题则放到一个限界上下文中，否则就拆分 如果一个聚合同时解决多个问题，则需要对聚合进行拆分，将拆分后的聚合划分到不同的限界上下文 解决的业务问题大小（变化原因，内在逻辑等）需与领域专家共同完成 限界上下文结果 界限上下文映射当上下文很多的时候，不同的团队负责不同的上下文，为了保证有效的工作可以定义不同的上下文之间的关系来创建一个所有模型上下文的全局视图。两个上下文之间是有方向的，上游(U或Upstream)，下游(D或Downstream) 界限上下文映射结果 子域一个业务领域或子域是一个业务范围。一个业务领域或子域可以包括多个业务能力，一个业务能力对应一个服务。 核心子域指业务成功的主要促成因素，是企业的核心竞争力。 通用子域被整个业务系统使用。 支撑子域是完成业务的必要能力，但不是成功的因素。 除了上面限界上下文结果中标注的子域外，还可以扩展出财务，市场，采购等子域 领域对象关系（战术设计）分解聚合，提取该聚合包含的领域对象 领域对象的业务不变性 领域对象具有一致的生命周期 定义实体与值对象（战术设计）实体：存在唯一性标识，实体间是否相等的判断依据也是唯一标识 值对象：表示属性的不变值 以订单聚合为例： 订单聚合包含订单实体，订单行实体 订单实体包含收货地址值对象 架构设计我们简单的把架构设计看作是三个层面： 业务架构：根据业务需求设计业务模块及其关系 DDD的领域建模其实就已经协助我们做了业务架构和系统架构 系统架构：设计系统与子系统的模块及其关系 在DDD中业务架构是可以直接映射到系统架构上的 业务变化会演变为系统架构变化，影响到技术架构变化 技术架构：设计技术和框架细节 技术架构（微服务）则解决子系统之间的解耦，去中心化的服务治理和数据治理 Clean Architecture寻找聚合时我们提到过输入和输出。而Clean Architecture与DDD集合后就非常适合作为采用DDD方法论的架构落地指导 为了更好的落地读模型设计（查询业务比较往往占八成以上），搭配CQRS可能是个不错的选择。 CQRS优势在于职责分离，提高系统性能、可扩展性、安全性等。也可以从数据驱动转为事件驱动。 要了解CQRS可以看第二篇 MASA Framework - EventBus设计 示例可以参考MASA EShop源码：https://github.com/masalabs/MASA.EShop 除了DDD以外，我们还提供了EventBus、Dapr、CQRS等多种实现方式 老系统演进绞杀者模式在现有系统外围将新功能用新的方式构建为新的服务的策略，通过将新功能做成微服务方式，而不是直接修改原有系统，逐步的实现对老系统替换。采用这种策略，随着时间的推移，新的服务就会逐渐“绞杀”老的系统。对于那些规模很大而又难以对现有架构进行修改的遗留系统，推荐采用绞杀者模式。 缺点：可能需要一段时间同时维护两个或以上的项目 修缮模式修缮者模式就如修房或修路一样，将老旧待修缮的部分进行隔离，用新的方式对其进行单独修复。修复的同时，需保证与其他部分仍能协同功能。从这种思路出发，修缮者模式更多表现为一种重构技术。 DDD实践流程 总结DDD虽然需要一定的学习成本，但掌握后既可以设计复杂的工程，也可以适当的缩减流程，在小型项目中直接以领域和聚合快速抽象领域模型，配合自己习惯的技术手段（如论是DB First还是Code First）来加强对系统设计的掌控力。 第一篇主要讲解DDD在团队中如何落地，而第二篇则是站在开发的角度如何落地。 学以致用，学无止境。 参考： AWS领域驱动设计最佳实践 领域驱动设计在互联网业务开发中的实践：https://tech.meituan.com/2017/12/22/ddd-in-practice.html 开源地址MASA.BuildingBlocks：https://github.com/masastack/MASA.BuildingBlocks MASA.Contrib：https://github.com/masastack/MASA.Contrib MASA.Utils：https://github.com/masastack/MASA.Utils MASA.EShop：https://github.com/masalabs/MASA.EShop MASA.Blazor：https://github.com/BlazorComponent/MASA.Blazor 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们","link":"/2022/02/11/masa/framework/design/2.MASA%20Framework%20-%20DDD%E8%AE%BE%E8%AE%A1%EF%BC%881%EF%BC%89/"},{"title":"MASA Framework - DDD设计（2）","text":"Clean Architecture国内对于Clean Architecture的翻译很多，干净/整洁/清晰。但无论哪一种都说明了它简洁、清晰的特性。 早期它长这样 看到这张图的同学可能会对另外一张图有印象 洋葱架构(Onion) 现在长这样 看起来好像是亲戚，它们的确也有着千丝万缕的关系 分析Clean Architecture 这部分主要是根据explicit architecture文章的理解整理的，有翻译也有自己理解消化的。如有错漏欢迎指正，谢谢 三大构建块 用户界面 基础设施 应用核心 控制流 用户界面 应用核心 基础设施 应用核心 用户界面 工具左右两侧形成鲜明对比，动机不同 HTTP/CLI：告诉应用要做什么 SMS/Mailing Server/Search Engine…：应用告诉它们要做什么 链接工具和交付机制到应用核心将工具连接到应用程序核心的代码单元称为适配器（端口和适配器架构）。 告诉我们的应用程序做某事的适配器称为主适配器或主动适配器，而我们的应用程序告诉我们做某事的适配器称为从适配器或被动适配器。 端口这些适配器为了适应应用核心的一个非常特定的入口点，即端口。端口只不过是工具如何使用应用程序核心或应用核心如何使用它的规范。 你可以看作是接口和DTO 主适配器或主动适配器主适配器或主动适配器围绕一个端口并使用它来告诉应用核心该做什么。 我们的主动适配器是Controller或Console Commands，它们在其构造函数中注入了一些对象，该对象的类实现了Controller或Console Commands所需的接口（端口）。 端口可以是控制器需要的服务接口或存储库接口，然后将 Service、Repository 或 Query 的具体实现注入并在 Controller 中使用。 或者，端口可以是Command Bus或Query Bus的接口。在这种情况下，将Command Bus或Query Bus的具体实现注入到Controller中，然后Controller构造Command或Query并将其传递给相关Bus。 注：这里其实提到了CQRS 从适配器或被动适配器与围绕在端口周围的主动适配器不同，从适配器实现一个端口、一个接口，然后在需要端口的任何地方注入应用核心。 可以理解为是右侧是符合应用核心的需要的接口或者对象，而左侧则是包装用例的传达机制，如HTTP/CLI等 假设我们有一个需要持久化数据的需求： 我们创建一个持久化接口，有一个保存数据的方法和一个通过ID删除数据的方法 基础设施中提供一个实现类，通过IoC注入这个接口和对应的实现类 在需要持久化数据的类的构造函数中注入一个持久化接口 如果有一天我们需要从SQL Server换到MongoDb，只需要替换步骤2中的实现类和注入新的实现类即可 IoC与上图相比，仅仅是多了一个蓝色的箭头从外部直插入应用核心内部。在上面例子中有提到通过IoC的作用这里就不再重复了。 至此，我们一致在讲解应用核心的外围，而应用核心是我们架构设计的重点。 应用核心组织洋葱架构采用 DDD 分层并将它们合并到端口和适配器架构中。这些层旨在为业务逻辑带来一些组织，即端口和适配器“六边形”的内部，就像在端口和适配器中一样，依赖方向是朝向中心的。 应用层用例(Use Case)是我们的应用中的一个或多个用户界面触发的流程（业务逻辑）。用户界面可以是终端用户界面也可以是管理界面，或者控制台界面和API。 用例在应用层定义，由DDD和洋葱架构提供，它可以包含端口，ORM接口，搜索引擎接口，消息接口等，也可以是CQRS处理Handlers的地方，发送邮件，调用第三方API等。 应用服务/Command Handler包含用例的业务逻辑，作用是： 使用Repository查找一个或多个实体 告诉这些实体做一些领域逻辑 使用Repository持久化这些实体，保存数据更改 Command Handler可以有两种不同的使用方式： 包含执行用例的真实业务逻辑 作为架构中的中间件，接收Command并触发应用服务中的逻辑 领域层领域内的对象除了有对象本身的属性外，还可以操作该对象内部的属性，这是特定于域本身的，并且独立于触发该逻辑的业务流程，它们是独立的，完全不知道应用层。 领域服务有时我们会遇到一些涉及不同实体的领域逻辑，无论是否相同，该领域逻辑不属于实体本身，它没有直接责任。 那我们可以使用领域服务来承载这部分逻辑，可能有人会觉得那可以放应用层，但领域逻辑在其他用例中就不能重用了。领域逻辑应该在领域内部，不要上升到应用层。 领域服务可以使用其他领域服务，或者其他领域对象 领域模型在最中心，依赖于它之外的任何东西，是领域模型，它包含代表领域中某些事物的业务对象。至于如何定义领域模型可以参考第一篇。 组件组件与应用核心内所有的层交叉，从外贯穿到内部。例如身份验证、授权、计费、用户、评论或账户，但它们依然与领域有关。 像授权和身份验证这样的限界上下文应该被视为隐藏在某种端口后面的外部工具。 解耦组件具有完全解耦的组件意味着一个组件不直接了解任何另一个组件。换句话说，它可能没有接口，所以我们需要一些新的架构结构。 比如事件、最终一致性、服务发现等。当你往这条路上走的时候，你就开始脱离单体了。 这里Dapr或许是个不错的选择，它包含了这些功能，对Dapr感兴趣的可以看之前的手把手教你学Dapr系列 MASA Framework解决方案结合DDD和Clean Architecture以及MASA Framework的特性，我们将在MASA.BuildingBlocks中以接口的形式定义规范，在MASA.Contrib中对接口进行实现。 这意味着你可以只关心BuildingBlocks中的接口定义来编写你的代码，也可以基于接口重新实现在DDD落地中你自己的业务特性来调整或扩展我们提供的默认行为。比如，你有自己的UoW、仓储层等都可以随意换掉。 应用层应用服务： 实现应用程序的用例，衔接表示层（接口层）与领域层 除此之外，基于MASA EShop的示例中的MASA.EShop.Services.Catalog的CQRS架构演示，应用层也可以承载CQRS的Command Hanlder。除了可以继续使用领域层来解决Command业务外，你也可以选择在此中止，在Command Handler里简化架构直接对Command进行处理。 示例代码：https://github.com/masalabs/MASA.EShop/tree/develop/src/Services/MASA.EShop.Services.Catalog/Application/CatalogBrands 工作单元： 默认事件是在应用服务中首次开启，所以UoW也会在应用层被激活（实际上底层会根据仓储的操作，只有首次增删改才会自动激活，这个功能可以关闭，改为手动控制） 中间件： 对于使用Event Bus开发来说，应用层还可以作为统一的AOP出入口。 例如统一的事件参数验证： 首先需要启用统一验证中间件 https://github.com/masalabs/MASA.EShop/blob/develop/src/Services/MASA.EShop.Services.Catalog/Application/Middleware/ValidatorMiddleware.cs 然后为对应的Event/Command编写验证逻辑 https://github.com/masalabs/MASA.EShop/blob/develop/src/Services/MASA.EShop.Services.Catalog/Application/Catalogs/Commands/DeleteProductCommandValidator.cs 领域层对于实体、聚合、值对象等概念就不再介绍了，可以参考上一章的内容。 贫血模型VS充血模型 领域中需要限定领域内的业务逻辑，加上EF Core对充血模型的支持，充血模型更适合用作领域模型的开发。 将数据与行为封装，表现出现实业务对象完整行为，每个领域具备明确的职责划分，将逻辑分散到领域对象中。这也是应用层与领域层的一个比较明显的区别。 对于实体相关对象，我们提供了对应的类，当然也包括审计和值对象可能需要用到的枚举类。 枚举类：我们提供了Enumeration，参考自：https://docs.microsoft.com/zh-cn/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/enumeration-classes-over-enum-types 领域服务： 领域服务中可以调用其他的领域服务（包括进程内或跨进程），所以我们提供了IDomainService，它的功能包括： 自动协调进程内和跨进程的事件传递 支持被调用方是CQRS 默认支持事件压栈，在UoW Commit后统一触发。也支持实时发送事件（如后续业务可被降级，但跨进程的事件为主业务逻辑不可被降级） 跨进程事件支持最终一致性和Saga 仓储： 领域中定义的仓储为接口，代表在当前领域内关心的业务。比如用户，在用户管理和名片两种业务中，对于IRepository的定义是不同的。但在基础设施中BaseRepository可以是同一个，因为BaseRepository可以是最完整的实现，但领域内仓储服务只认其中一部分 基础设施层给接口提供实现，如仓储接口的实现、Event Bus中MQ或中介者的实现（MASA Framework已实现，所以我们的示例中目前只有仓储接口的实现）等。 MASA Framework模板架构在MASA Framework模板中提供了自由组合的方式，你可以根据你的需求随意调整如是否包含Blazor、Dapr、DDD、CQRS等。 我们的MASA.EShop推荐采用了4种架构方式，从简到繁，本篇介绍最复杂的一个 Minimal APIS + CQRS + Dapr actor MASA.EShop中的Ordering服务就是采用这种架构分层，其实分层解释上面也有，只是之前解释的是站在MASA BuildingBlocks的角度，而接下来将是站在开发者角度。 User Interface Layer：它负责提供用户接口，完整前端逻辑。用户也可以是计算机系统，不特指是人。所以这里既可以是API，也可以是Blazor、MVC等。 Application Layer：它可以很薄也可以很厚（在当前分层下推荐薄）。负责协调User Interface和Domain，包括服务的编排和转发，AOP，发送事件等。 如果你有Domain Layer可以把Command做的很薄调用Domaiin。如果你要精简CQRS，也可以不用Domain，在这一层直接做应用服务。当然Query也一样，但Query即便使用Domain也推荐把查询放在应用服务里，这样可以把Query和Command分离来获得CQRS的优势。 Domain Layer：业务核心，包括了领域对象和领域服务以及适配器的接口。建议采用充血模型将行为留在领域内，跨领域且需要被复用的可以使用领域服务。仓储接口则限定领域内的仓储行为，与物理仓储不同的是更聚焦业务本身，而不是实体的完整仓储能力。 Infrastructure Layer：给接口提供实现，如仓储接口的实现、Event Bus中MQ或中介者的实现（MASA Framework已实现，所以我们的示例中目前只有仓储接口的实现）等。 总结至此，我们不仅实现了对单体架构的支持，还通过Event Bus对微服务架构提供了支持。 如果你对DDD或者MASA Framework感兴趣，不妨把MASA.EShop跑起来看一下，它提供了4种架构方式参考，可以满足大部分业务场景对架构的要求。 学以致用，学无止境。 参考： DDD, Hexagonal, Onion, Clean, CQRS, … How I put it all together：https://herbertograca.com/2017/11/16/explicit-architecture-01-ddd-hexagonal-onion-clean-cqrs-how-i-put-it-all-together/ 开源地址MASA.BuildingBlocks：https://github.com/masastack/MASA.BuildingBlocks MASA.Contrib：https://github.com/masastack/MASA.Contrib MASA.Utils：https://github.com/masastack/MASA.Utils MASA.EShop：https://github.com/masalabs/MASA.EShop MASA.Blazor：https://github.com/BlazorComponent/MASA.Blazor 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们","link":"/2022/02/12/masa/framework/design/3.MASA%20Framework%20-%20DDD%E8%AE%BE%E8%AE%A1%EF%BC%882%EF%BC%89/"},{"title":"Blazor是春天还是寒风里的挣扎","text":"官方解释 BlazorBlazor 允许您使用c#而不是 JavaScript构建交互式web UI。 Blazor 应用由可重用的 web UI 组件组成，这些组件使用 c#、HTML 和 CSS 实现。客户端和服务器代码都是用 c#编写的，允许您共享代码和库。 Blazor 是一个使用 .NET 生成交互式客户端 Web UI 的框架： 使用 C# 代替 JavaScript 来创建信息丰富的交互式 UI。 共享使用 .NET 编写的服务器端和客户端应用逻辑。 将 UI 呈现为 HTML 和 CSS，以支持众多浏览器，其中包括移动浏览器。 与新式托管平台（如 Docker）集成。 使用 .NET 进行客户端 Web 开发可提供以下优势： 使用 C# 代替 JavaScript 来编写代码。 利用现有的 .NET 库生态系统。 在服务器和客户端之间共享应用逻辑。 受益于 .NET 的性能、可靠性和安全性。 在 Windows、Linux 和 macOS 上使用 Visual Studio 保持高效工作。 以一组稳定、功能丰富且易用的通用语言、框架和工具为基础来进行生成。 看到这里有些小伙伴手中的瓜已经要丢出来了，的确有部分是夸大了的，起码 VS 在三个平台高效工作这事儿，嗯。。。其他的继续吃瓜吧 Blazor Vs MVC什么是 MVC官方解释：ASP.NET Core MVC 是使用“模型-视图-控制器”设计模式构建 Web 应用和 API 的丰富框架。 圈重点，Blazor 是交互式 Web UI，而 MVC 是 Web 应用和 API 什么是交互式 Web UI谷歌、百度转了一圈，没有这个解释，连 Wiki 也是一脸懵逼。 尝试理解一下吧，交互式 Web UI 重点在于交互，而 Blazor 的官方解释是用 C#代替 JavaScript，那我们看看 JavaScript 有什么功能，我百度找一段过来： 嵌入动态文本于 HTML 页面 对浏览器事件做出响应 读写 HTML 元素 在数据被提交到服务器之前验证数据 检测访客的浏览器信息。控制 cookies，包括创建和修改等 有这些基础功能，用户不需要在静态页面里跳来跳去了，的确体验会好很多 Blazor 有什么优势提供了一些交互能力，不再是纯粹的静态页，虽然 mvc 可以使用 JavaScript 达到同样的效果，但你需要掌握 JavaScript，甚至还要再学习 jQuery、Angular、Vue 等。而 Blazor 提供的交互能力则是使用 C#。 吹是吹完了，但你真的可以 100% C#吗？这很难，你会遇到各种问题，比如兼容性、性能等。好了，那我可以不用了吗？等等，下面还有瓜 Blazor Vs 现代前端(Angular、Vue 等)我们从几个方面来对比一下吧 调试 Blazor：Vistual Stuidio + F5，VS Code/命令行工具 + dotnet watch 比 WebPack 要快很多，跟 Vite 差不多 在非复杂场景下 Hot Reload 是可以的，但奇奇怪怪的问题太多了，前景很好，目前来看还是用 Ctrl + F5 启动或者用命令行吧 VS 2022 的 Ctrl + F5 已经支持 Hot Reload 了 现代前端：Webpack/Vite 全家桶以 Vue 为例，Vue 全家桶包括 Vue Cli、Vue Router、Vuex Blazor： Cli：dotnet cli Router：Microsoft.AspNetCore.Components.Routing.Router Vuex：Blazor 状态管理，区别在于 WASM 状态保存在浏览器内存中，而 Server 保存在服务器内存中。而且 Blazor 状态管理更强大的是借助.Net 的能力，原生支持持久化存储、跨线路保存（Server 下共享服务器内存）、ASP.NET Core 受保护的浏览器存储（Server 独享功能） 组件库主流的 Bootstrap, Ant Design, Material Design 等双方都有。但由于现代前端多年的积累，质量上的确有一定差距。 除了丰富程度上，Blazor 允许被 JavaScript 调用加载，并生成 Angualr、React 等组件。 虽然这看起来跟用 C#解决代替 JavaScript 有点冲突，但融入大环境也是不错的 下图演示的是 Blazor 提供的 inventory-grid Component 被 React 引用的例子(当然也可以给 Angular)： 更神奇的是，在 React 复用的 Blazor Component 居然也支持 Hot Reload。先不说 Hot Reload 到底如何，单是这个方向其实还是值得期待一下 Hot Reload 的未来吧。 不止可以给 React 提供复用的组件，还可以给 WPF 第三方库举几个前端常用库来比较。 网络：现代前端有 axios，Blazor 有 HttpClient 数据操作：现代前端有 Lodash，Blazor 有 Linq 时间：现代前端有 moment.js、Day.js，Blazor 有 DateTime 全家桶 响应式编程：现代前端有 rx.js，Blazor 有 Rx.Net（没有用过，理论上.Net 基本都能用，欢迎纠错） Mock：现代前端有 Mock.Js，Blazor 有 Moq，当然除了 mock 以外还有端到端的，双方也都有。 对比下来其实.Net 反而还有点优势，那就完美吗？当然不是，再说点劣势的部分吧。 Charts：现代前端有 ECharts 等，Blazor 不想说话 虽然目前 Blazor 的确没有成熟、免费的 Charts 组件库，但因为 Blazor 可以与 JS 交互的能力，调用 ECharts 也很简单，稍微考验一点点小伙伴的动手能力 富文本编辑器、拖拽。。。 Blazor 骂骂咧咧的退出了群聊。。。 包管理Blazor：NuGet 现代前端：NPM、Yarn 性能数据不直观，先从.Net Conf 2021 上的演示截图看一下： 有量化数据吗？有： 视频地址：https://sec.ch9.ms/ch9/daba/468d5211-982b-4c86-8b51-e1c8824edaba/dotNETConfNewBlazorWebAssembly_high.mp4 那 AOT 可以解千愁吗？也不是。起码应用大小上来说的确也大了不少，但这并不妨碍 AOT 可以解决特定场景的问题。技术总要选择在适合的场景使用它，而不是盲目的。 完了吗当然没有，其实这样比较对于 Blazor 是不公平的，因为 Blazor 站在.Net 的肩膀上有更多的亮点，比如原生支持的泛型、DI、面向对象设计（虽然 TS 也是）、数不过来的.Net 类库、跨平台应用（MAUI）等。 其实没有必要只看到 Blazor 的劣势，也可以看看站在.Net 上的前端能走多远，这不也是我们期待的吗？ 看到这里，有些.Net 古董级大佬要出来发话了，Silverlight！是的，但这次 WASM 没有再要求下载插件了。 Web Assembly Vs Server（服务器端渲染）Web Assembly：WebAssembly 是一种新的编码方式，可以在现代的网络浏览器中运行 － 它是一种低级的类汇编语言，具有紧凑的二进制格式，可以接近原生的性能运行，并为诸如 C / C ++等语言提供一个编译目标，以便它们可以在 Web 上运行。它也被设计为可以与 JavaScript 共存，允许两者一起工作。 Server（Server Side Render - SSR）：将组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。 为什么用 SSR服务器端渲染 (SSR) 的优势主要在于： 更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。 更快的内容到达时间 (time-to-content) 什么时候用 SSR使用服务器端渲染 (SSR) 时还需要有一些权衡之处： 开发条件所限。浏览器特定的代码，只能在某些生命周期钩子函数 (lifecycle hook) 中使用；一些外部扩展库 (external library) 可能需要特殊处理，才能在服务器渲染应用程序中运行。 涉及构建设置和部署的更多要求。与可以部署在任何静态文件服务器上的完全静态单页面应用程序 (SPA) 不同，服务器渲染应用程序，需要处于服务端运行环境。 更多的服务器端负载。 服务器端渲染 vs 预渲染 (SSR vs Prerendering)如果你调研服务器端渲染 (SSR) 只是用来改善少数营销页面（例如 /, /about, /contact 等）的 SEO，那么你可能需要预渲染。无需使用 web 服务器实时动态编译 HTML，而是使用预渲染方式，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点。 Blazor Server 支持 Prerendering Blazor 该选 Web Assembly 还是 Server看一下.Net Conf 2021 大会上的一张图： 总结一下： Server 要持久化长连接，有更高的 UI 延迟 Web Assembly 则是更大的下载大小，和更慢的运行时性能 我们在做什么又是一个老生常谈的问题，.Net 的覆盖面太广了也导致很难解决所有问题。我们在权衡利弊之后是不是可以为.Net 生态共建出自己小小的一份力呢？ 开源的组件库再回到组件库上，目前市面上的组件库其实不少了，何必要继续在这个泥潭里插一脚呢？ 开发过组件库的同学，或者贡献过源码的同学应该都体会到了，写一个组件是多么的复杂。而大家对于一个设计的审美角度也是不同的。当你喜欢的设计没有提供实现怎么办？从头写吗，那太累了，所以我们尝试了一件事情。 先看一下大概思路： 简单的剖析一下： 在 Blazor 的基础上，构建一个新的组件库叫 Blazor Component 那他有哪些特性呢？ 只提供交互，不提供样式 标准化 Dom 结构 开放几乎所有可以自定义的 Slots（插槽，概念引自 Vue），允许你替换 Slots 的 Dom 插槽与交互的统一单元测试（目前正在 38%，短期目标是 80%，长期目标是 90%+） 基于 Material Design（样式引自 Vuetify）的示例项目，可以达到生产可用（我们自己的公司在用，也是世界五百强企业在用） 快速实现新的组件库，只需要基于某个 Design + 样式控制属性 + 特殊交互即可 未来是值得憧憬的，我们希望未来是这样的： 惭愧，蹭了一波字节的热度 MASA Blazor基于 Blazor Component 和 Material Design 的 Blazor 组件库 截止目前共 68 个基础组件，后续会继续增加 预置组件，提供与.Net 功能深度集成且常用组合类组件，如 Url、面包屑、菜单三联动，高级搜索，i18n 等 MASA Blazor Pro 提供多种常见场景的预设布局 全职团队维护，Issue 快速响应 知名企业在用，未来 MASA Stack 产品线也将一直使用，持续增加新功能 免费、开源 我们还计划未来支持一键切换主题（代码切换已经提供）、预置布局、数据展示类组件、WorkFlow 类组件等。 MASA Blazor Pro基于 MASA Blazor 提供的 Admin 模板，先放几张设计稿吧，源码会跟 MASA Blazor 一起放出。 MASA EShop基于 MASA Framework 搭建的 EShopOnDapr，将会使用 MASA Blazor Pro 提供完整的前后端示例 开源地址：https://github.com/masalabs/MASA.EShop 总结说到底没有完美的技术，在你权衡利弊之后在正确的场景使用它就是最合适的。 是春天还是寒冬也不重要，重要的是当下这一刻，它是否解决了你的痛点。 最后，一个小小的广告 MASA Blazor 即将发布，敬请期待，如果你对我们的组件库感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们 参考 https://dotnet.microsoft.com/apps/aspnet/web-apps/blazor https://docs.microsoft.com/zh-cn/aspnet/core/blazor/state-management?view=aspnetcore-6.0&amp;pivots=server#persist-state-across-circuits https://sec.ch9.ms/ch9/daba/468d5211-982b-4c86-8b51-e1c8824edaba/dotNETConfNewBlazorWebAssembly_high.mp4 https://developer.mozilla.org/zh-CN/docs/WebAssembly https://ssr.vuejs.org/zh/","link":"/2021/10/25/masa/framework/masa-blazor/0/"},{"title":"初识MASA Blazor","text":"MASA Blazor是一个Blazor的 UI 组件库。就像大家写前端熟知的 Bootstrap, Ant Design 一样。 MASA Blazor 官网地址：https://blazor.masastack.comMASA Blazor Github 地址：https://github.com/BlazorComponent/MASA.BlazorMASA Blazor Gitee 地址：https://gitee.com/blazorcomponent/MASA.BlazorMASA Blazor Pro 演示地址：https://blazor-pro.masastack.com/dashboards/ecommerceMASA Blazor Pro Github 地址：https://github.com/BlazorComponent/MASA.Blazor.Pro 什么是 Blazor在介绍MASA Blazor之前，有必要知道一下什么是Blazor，如果已经了解Blazor是什么的小伙伴可以直接跳过，往下面继续看。 Blazor 是一个使用 .NET 生成交互式客户端 Web UI 的框架，使用Blazor，开发人员可以使用 C#语言在服务器和客户端进行编码，构建丰富 Web 应用程序。听起来是不是很不错，不熟悉前端开发语言的后端小伙伴，也可以使用Blazor进行 Web 应用开发了。简单看一下官方的描述。 如果想深入了解Blazor的小伙伴可以翻一下这篇文章，里面非常详细的介绍了什么是 Blazor 和 Blazor 与其他前端技术的对比。或者可以直接去翻官方文档，这里我就不过多的阐述了。 Material Design了解完Blazor再来简单了解一下Material Design，为什么是Material Design，因为MASA Blazor就是基于Material Design设计的。 简介：Material Design，中文名：材料设计语言，有人也叫它质感设计，是由 Google 推出的跨平台设计语言，其旨在为手机、平板电脑、台式机和“其他平台”提供高度一致使用体验和视觉效果。 优点：Material Design包含了在设计时如何使用阴影、如何使用动画、甚至使用多少像素的边框都给出了建议，它可以帮助我们搭建更加合理的页面结构，如何排版、字体大小和间距，它定义了优雅流畅的交互效果引导用户在页面中的视觉焦点和交互操作。 Material Design的核心就是简洁。大而简、简而精。它把物理世界的体验带进屏幕。去掉现实中的杂质和随机性，保留其最原始纯净的形态、空间关系、变化与过渡，配合虚拟世界的灵活特性，还原最贴近真实的体验，达到简洁与直观的效果。它的优点当然不止这些。海外的很多应用包括大量 web 网站都是基于 MD 的设计。在国外还是非常火的。想了解更多关于 MD 的小伙伴可以去翻一下它的官方网站，这里就先介绍到这。 VuetifyVuetify 是一个在世界范围内广受欢迎的 VueUI 框架，它是建立在 Vue.js 之上的完备的界面框架。与其他框架不同。 Vuetify从一开始就设计为易于学习的并且拥有来自 Material 设计规范 的数百个精心设计组件。Vuetify采用移动优先的设计，这意味着无论是在手机、平板电脑还是台式电脑上，你的应用程序都可以开箱即用。 所以使用vue的小伙伴可以使用Vuetify很轻松的就构建出一套基于Material Design设计风格的应用。 是不是很爽呢？说了这么多都是人家前端的东西，那我们Blazor有这样的 UI 组件库吗？答案是当然有，那就是MASA Blazor。终于轮到了我们的主角。 MASA BlazorMASA Blazor开篇已经说过了，他是Blazor的一个 UI 组件库，Blazor使你脱离了JavaScript进行 web 应用开发，而MASA Blazor可以让你不必写，或者写很少的 Css 就能构建出一个非常漂亮的 web 应用。MASA Blazor就是严格按照Material Design的设计规范精心设计的 UI 组件库。接下来说一下他的优点。 基于Material Design的设计风格，拥有Material Design的所有设计优点，多端体验、交互、操作优秀 与Blazor深度集成，让后端开发人员能非常轻松的上手。 天生具备响应式，除Vuetify有的组件外，还有许多预置组件如 Url、面包屑、导航三联动，高级搜索，i18n 等 社区活跃、简易上手，全职团队维护 MASA Blazor深度还原了Vuetify的所有组件，做到了 1:1 还原之外还增加了非常实用的预置组件，对常用的一些组件或一组组件进行封装，更贴合开发者的日常使用，大大缩减了开发时间，增加了开发的效率。他同时也解决了大部分后端人调样式的烦恼。几句代码就能快速构建出来一个漂亮的页面。那么接下来我们就看一看如何在Blazor项目中引入它。 使用 MASA Blazor 环境：.NET 6.0.0 + Visual Studio 2022 创建Blazor Server应用 1dotnet new blazorserver -o BlazorServerApp 添加 MASA.Blazor 包 可以使用 Nuget 包管理工具搜索MASA.Blazor添加，也可以直接 1dotnet add package MASA.Blazor 在 Program.cs 里添加Masa Blazor相关服务。 1builder.Services.AddMasaBlazor(); 这里使用的是.net 6.0 Minimal Api 没有了 Startup 类。代码看起来也比较简洁。如果是之前的.net 版本就在Startup.ConfigureServices里添加services.AddMasaBlazor();就好了。 Pages/_Layout.cshtml 中引入样式、字体、脚本 在 head 里添加样式和字体 123456&lt;link href=&quot;_content/MASA.Blazor/css/masa-blazor.css&quot; rel=&quot;stylesheet&quot; /&gt;&lt;link href=&quot;_content/MASA.Blazor/css/masa-extend-blazor.css&quot; rel=&quot;stylesheet&quot; /&gt;&lt;link href=&quot;https://cdn.jsdelivr.net/npm/@(&quot;@mdi&quot;)/font@5.x/css/materialdesignicons.min.css&quot;rel=&quot;stylesheet&quot;&gt;&lt;link href=&quot;https://fonts.googleapis.com/css?family=Material+Icons&quot; rel=&quot;stylesheet&quot; /&gt;&lt;link href=&quot;https://use.fontawesome.com/releases/v5.0.13/css/all.css&quot; rel=&quot;stylesheet&quot; /&gt; 在 body 的底部添加 js 脚本 1&lt;script src=&quot;_content/BlazorComponent/js/blazor-component.js&quot;&gt;&lt;/script&gt; 如果是.net6.0 之前的版本，这些代码是在 Pages/_Host.cshtml(Server) 中 在_Imports.razor 文件中引用MASA.Blazor，BlazorComponent明明空间，这样我们就不用每个文件都去引用一边了 12@using MASA.Blazor@using BlazorComponent 替换 Shared/MainLayout.razor 里面的内容 123&lt;MApp&gt; @Body&lt;/MApp&gt; 使用模板快速创建 Blazor 项目经过上述的步骤你就可以基于MASA Blazor进行开发了。但是步骤是不是有一点点多，些许繁杂？当然这些MASA Blazor也替我们考虑到了，所以它提供了更简单的安装方式，通过模板进行安装。 通过 dotnet 命令安装模板 1dotnet new --install MASA.Template 创建基于 MASA Blazor 组件库的 Blazor Server 项目 1dotnet new masab -o BlazorServerApp 简单两步就搞定了。这样创建完的项目就帮你完成了上述的几个步骤。 效果展示接下来我们就用 MASA Blazor 的侧边栏和顶部工具栏替换掉原来 demo 的组件。部分代码截图： 使用到了MNavigationDrawer和MAppBar两个组件。 效果图如下： 还有很多漂亮有趣的组件官网上都有示例和代码，比如这个AppBar： 点击查看源代码，然后把代码复制过来，一个组件就完成了。 看下效果： 就是这么简单。 我们再来看一下官方给的 Admin 模板（MASA Blazor Pro）效果如何： MASA Blazor Pro 演示了大多数 MASA Blazor 组件的使用。而且是一个开箱即用的后台前端管理模板。都是开源免费的。 感兴趣的小伙伴可以去解一下。 MASA Blazor 官网地址：https://blazor.masastack.comMASA Blazor Github 地址：https://github.com/BlazorComponent/MASA.BlazorMASA Blazor Gitee 地址：https://gitee.com/blazorcomponent/MASA.BlazorMASA Blazor Pro 演示地址：https://blazor-pro.masastack.com/dashboards/ecommerceMASA Blazor Pro Github 地址：https://github.com/BlazorComponent/MASA.Blazor.Pro","link":"/2021/12/12/masa/framework/masa-blazor/1.%E5%88%9D%E8%AF%86MASA%20Blazor/"},{"title":"使用MASA.Blazor写一个标准的查询表格页","text":"前言大家好，我是开源项目 MASA Blazor 主要开发者之一，如果你还不了解MASA Blazor，可以访问我们的 官网 和博客 《初识MASA Blazor》 一探究竟。简单来说，MASA Blazor 是一个基于 Material Design 设计语言的 Blazor 组件库，dotNET开发者只需或者甚至不需要懂得 javascript 就能开发一个企业级中后台系统。 我这次分享的主题是《使用MASA Blazor开发一个标准的查询表格页》，我会先从创建项目开始手撸一个没有任何技巧的查询表格页，然后我会分享一些技巧和封装的组件，实现快速开发。 手撸查询表格页创建应用程序关于如何安装MASA Blazor模板，请移步 MASA.Blazor快速入门。 首先通过MASA Blazor模板默认的Server项目，项目命名为 MasaBlazorStandardTablePage。 12dotnet new --install MASA.Templatedotnet new masab -o MasaBlazorStandardTablePage 通过CLI运行应用程序，或直接通过vs启动项目。 12cd MasaBlazorStandardTablePagedotnet run 启动成功后切换到 Fetch data 页面，此页面展示了一个简单的使用了 MDataTable 的表格。 支持单个查询条件和搜索让我们从最简单的单个条件查询开始。 将随机数据替换成模拟数据 修改 WeatherForecastService，将随机数据替换成死数据以便支持查询功能。下面的代码更新了数据来源和 GetForecastAsync 查询方法。 1234567891011121314151617181920212223public class WeatherForecastService{ private readonly List&lt;WeatherForecast&gt; _data = new() { new() { Date = DateTime.Now.AddDays(-1), TemperatureC = 23, Summary = &quot;Freezing&quot; }, new() { Date = DateTime.Now.AddDays(-1), TemperatureC = -10, Summary = &quot;Bracing&quot; }, new() { Date = DateTime.Now.AddDays(-1), TemperatureC = 37, Summary = &quot;Chilly&quot; }, new() { Date = DateTime.Now.AddDays(-2), TemperatureC = 29, Summary = &quot;Cool&quot; }, new() { Date = DateTime.Now.AddDays(-3), TemperatureC = 11, Summary = &quot;Mild&quot; }, new() { Date = DateTime.Now.AddDays(-4), TemperatureC = 35, Summary = &quot;Warm&quot; }, new() { Date = DateTime.Now.AddDays(-5), TemperatureC = 41, Summary = &quot;Balmy&quot; }, new() { Date = DateTime.Now.AddDays(-5), TemperatureC = -13, Summary = &quot;Hot&quot; }, new() { Date = DateTime.Now.AddDays(-6), TemperatureC = 23, Summary = &quot;Sweltering&quot; }, new() { Date = DateTime.Now.AddDays(-7), TemperatureC = 2, Summary = &quot;Scorching&quot; }, }; public Task&lt;WeatherForecast[]&gt; GetForecastAsync() { IEnumerable&lt;WeatherForecast&gt; res = _data.AsQueryable(); return Task.FromResult(res.ToArray()); }} 同时修改 FetchData.razor，因为 WeatherForecastService.GetForecastAsync() 删除了 startDate 入参。 12345protected override async Task OnInitializedAsync(){ await Task.Delay(1000); // 模拟真实环境，触发Loading效果 forecasts = await ForecastService.GetForecastAsync(); // here} 添加查询输入框和搜索按钮 在 FetchData.razor 页面中的 &lt;p&gt; 标签下添加以下代码 1234567891011121314151617181920212223&lt;MRow Class=&quot;pb-3&quot;&gt; &lt;MCol Cols=&quot;12&quot;&gt; &lt;MTextField @bind-Value=&quot;summary&quot; Dense HideDetails=&quot;@(&quot;auto&quot;)&quot; Label=&quot;Summary&quot; Outlined&gt; &lt;/MTextField&gt; &lt;/MCol&gt; &lt;MCol Cols=&quot;12&quot; Class=&quot;d-flex py-0 pb-3&quot;&gt; &lt;MSpacer&gt;&lt;/MSpacer&gt; &lt;MButton Color=&quot;primary&quot; OnClick=&quot;OnSearch&quot;&gt;搜索&lt;/MButton&gt; &lt;/MCol&gt;&lt;/MRow&gt;@code { private string summary; private async Task OnSearch() { forecasts = await ForecastService.GetForecastAsync(summary); }} Line 3,17 定义了一个 string 类型的名为 summary 的变量，双向绑定给了 MTextField 组件。MTextFiled 除了 @bind-Value 属性用于设置双向绑定，其他属性的含义请阅读 文档。 Line 12 定义了一个搜索按钮，用于触发查询。 修改 WeatherForecastService.GetForecastAsync 方法，增加 summary 入参，并支持查询。 1234567891011public Task&lt;WeatherForecast[]&gt; GetForecastAsync(string? summary = null){ IEnumerable&lt;WeatherForecast&gt; res = _data.AsQueryable(); if (!string.IsNullOrEmpty(summary)) { res = res.Where(item =&gt; item.Summary.Contains(summary)); } return Task.FromResult(res.ToArray());} 支持多个查询条件和重置现在让我们再添加一个高温预警的选择框来查询不同高温预警状态的数据。 更新 WeatherForecastService 以支持根据高温预警筛选数据12345678910111213141516171819202122public Task&lt;WeatherForecast[]&gt; GetForecastAsync(string? summary = null, WarningSigns? warningSigns = null){ IEnumerable&lt;WeatherForecast&gt; res = _data.AsQueryable(); if (!string.IsNullOrEmpty(summary)) { res = res.Where(item =&gt; item.Summary.Contains(summary)); } if (warningSigns.HasValue) { res = warningSigns switch { WarningSigns.Yellow =&gt; res.Where(item =&gt; item.TemperatureC &gt;= 35 &amp;&amp; item.TemperatureC &lt; 37), WarningSigns.Orange =&gt; res.Where(item =&gt; item.TemperatureC &gt;= 37 &amp;&amp; item.TemperatureC &lt; 39), WarningSigns.Red =&gt; res.Where(item =&gt; item.TemperatureC &gt;= 39), _ =&gt; res }; } return Task.FromResult(res.ToArray());} 增加高温预警选择框 在 Data 目录下添加名为 WarningSigns 的枚举。 123456789public enum WarningSigns{ [Description(&quot;高温黄色预警 35℃&quot;)] Yellow = 1, [Description(&quot;高温橙色预警 37℃&quot;)] Orange, [Description(&quot;高温红色预警 39℃&quot;)] Red} 引入 Masa.Utils.Enums 包，此包提供的 GetEnumObjectList 方法能轻松的将枚举的 Description 和枚举值用于 MSelect 组件的 Items。 1dotnet add package Masa.Utils.Enums 更新 FetchData.razor。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;MRow Class=&quot;pb-3&quot;&gt; &lt;MCol Cols=&quot;12&quot; Sm=&quot;6&quot;&gt; &lt;MTextField @bind-Value=&quot;@summary&quot; Label=&quot;Summary&quot; Dense HideDetails=&quot;@(&quot;auto&quot;)&quot; Outlined&gt; &lt;/MTextField&gt; &lt;/MCol&gt; &lt;MCol Cols=&quot;12&quot; Sm=&quot;6&quot;&gt; &lt;MSelect @bind-Value=&quot;warningSigns&quot; Items=&quot;@(Enum&lt;WarningSigns&gt;.GetEnumObjectList&lt;WarningSigns&gt;())&quot; ItemText=&quot;item =&gt; item.Name&quot; ItemValue=&quot;item =&gt; item.Value&quot; TValue=&quot;WarningSigns?&quot; TItem=&quot;EnumObject&lt;WarningSigns&gt;&quot; TItemValue=&quot;WarningSigns&quot; Label=&quot;高温警告&quot; Clearable Dense HideDetails=&quot;@(&quot;auto&quot;)&quot; Outlined&gt; &lt;/MSelect&gt; &lt;/MCol&gt; &lt;MCol Cols=&quot;12&quot; Class=&quot;d-flex py-0 pb-3&quot;&gt; &lt;MSpacer&gt;&lt;/MSpacer&gt; &lt;MButton Class=&quot;mr-2&quot; OnClick=&quot;OnReset&quot;&gt;重置&lt;/MButton&gt; &lt;MButton Color=&quot;primary&quot; OnClick=&quot;OnSearch&quot;&gt;搜索&lt;/MButton&gt; &lt;/MCol&gt;&lt;/MRow&gt; @code { private WarningSigns? warningSigns; private Task OnReset() { summary = null; warningSigns = null; return OnSearch(); } private async Task OnSearch() { forecasts = await ForecastService.GetForecastAsync(summary, warningSigns); }} Line 2,10 通过设置 Sm=&quot;6&quot; 可以让屏幕尺寸大于768px时一行占两个 MCol ，实现 MTextField 和 MSelect 并排显示。 Line 11-23,33,44 第33行定义 warningSigns 变量用于接收 MSelect 选中的值，当然也可以通过设置值更新 MSelect 选中的值，只要设置了 @bind-Value 双向绑定就行，就像第11行那样。第12行使用了 Masa.Utils.Enums 提供的方法，返回了一个包含Name(Description)和Value(枚举值)的列表，赋值给了 MSelect.Items 。第44行将 warningSigns 的传给查询接口。 Line 27,35-40 此处定义了一个重置按钮，用于清空所有查询输入框的内容并刷新表格。 支持键入回车或选择后触发查询后来测试小姐姐说你这太难用了，回车不能触发搜索，选择完也不能触发搜索。好吧好吧，我们现在加上。 键入回车后触发原理即捕捉 OnKeyDown 事件是否点击了 Enter 键。 1234567891011121314151617181920&lt;MTextField @bind-Value=&quot;@summary&quot; OnKeyDown=&quot;HandleOnKeyDown&quot; Label=&quot;Summary&quot; Dense HideDetails=&quot;@(&quot;auto&quot;)&quot; Outlined&gt;&lt;/MTextField&gt;@code { private async Task HandleOnKeyDown(KeyboardEventArgs args) { if (args.Code == &quot;Enter&quot;) { // 等待156毫秒，预防输入的值在更新到变量之前按下Enter键 await Task.Delay(156); await OnSearch(); } }} Line 2 将 HandleOnKeyDown 绑定到 MTextField 的 OnKeyDown 事件。 Line 10-17 通过判断 KeyboardEventArgs 的 Code 值是否为 Enter 来触发搜索。第14行等待156毫秒是为了等待 summary 的值已经是输入过后的值。 选择后触发查询1234567891011121314&lt;MSelect @bind-Value=&quot;warningSigns&quot; Items=&quot;@(Enum&lt;WarningSigns&gt;.GetEnumObjectList&lt;WarningSigns&gt;())&quot; ItemText=&quot;item =&gt; item.Name&quot; ItemValue=&quot;item =&gt; item.Value&quot; TValue=&quot;WarningSigns?&quot; TItem=&quot;EnumObject&lt;WarningSigns&gt;&quot; TItemValue=&quot;WarningSigns&quot; Label=&quot;高温警告&quot; OnSelectedItemUpdate=&quot;OnSearch&quot; Clearable Dense HideDetails=&quot;@(&quot;auto&quot;)&quot; Outlined&gt;&lt;/MSelect&gt; Line 9 当选择项更新时(OnSelectedItemUpdate)直接调用 OnSearch 方法，触发查询。此处不用像上面处理 OnKeyDown 那样等待156毫秒，因为 OnSelectedItemUpdate 是在 warningSigns 更新后触发的。 点击清空图标触发查询很简单，只要给 MTextField 和 MSelect 组件添加以下属性： 12ClearableOnClearClick=&quot;OnSearch&quot; 加点Loading动画可好？好！ 1234567891011121314151617181920212223242526272829303132333435&lt;MButton Color=&quot;primary&quot; Loading=&quot;searching&quot; OnClick=&quot;HandleOnSearch&quot;&gt; 搜索&lt;/MButton&gt;...&lt;MDataTable Headers=&quot;_headers&quot; Items=&quot;forecasts&quot; Loading=&quot;loading&quot; ItemsPerPage=&quot;5&quot; Class=&quot;elevation-1&quot;&gt;... @code { private bool loading; private bool searching; private async Task HandleOnSearch() { searching = true; await OnSearch(); searching = false; } private async Task OnSearch() { loading = true; await Task.Delay(1000); forecasts = await ForecastService.GetForecastAsync(summary, warningSigns); loading = false; }} Line 2-3,15,17-24 新增 searching 变量用于控制搜索按钮的 Loading 状态，同时新增了 HandleOnSearch 代替原来的 OnSearch 是为了单独控制点击搜索按钮的动画。 Line 9,14,28,33 新增 loading 变量用于控制 MDataTable 的 Loading 状态。OnSearch 方法块中在接口请求前后设置 loading 的值。 表的行操作和自定义列样式因为篇幅限制，我就不一一把代码贴出来了，具体代码请查阅 源码 接下来我将针对Table写一些常见的代码，如行操作和自定义列样式。 封装组件和技巧我本应该用这节分享的内容将上面的例子重构的过程写出来，但感觉会使得本文太冗长。重构后的代码我也会上传到 Github 上。 封装组件试想一下，当你被分配到好几个模块，每个模块都有至少一个查询表格页，你会如何开发？你大概会说复制最合适的代码文件，然后重命名文件名，重命名相应的变量，修修改改就完行了。当然这是一个方法，但不优雅。那优雅的方式是什么，是封装。我有段时间在全职开发 MASA.Blazor 组件库，后面因为业务需求分配到了IoT项目帮助Blazor后台系统的研发和 MASA.Blazor 的实践。在开发IoT项目时，经常会看见相同的代码分布在相同的类中，我试着优化重构这些代码，并从查询表格页中抽离封装了以下几个组件： Filters：接收OnSearch参数代理查询，通过context提供onEnter和onSearch方法供单个查询组件使用。 PageHeader：一个标准的页头，包括了标题、副标题、搜索按钮，并提供Filters组件的能力。 Actions：提供一组操作按钮，默认展示前两个，后面的按钮会移动到MMenu中显示。 BlockText：将相同类型的两个数据并列显示。 ColorChip：提供有限的颜色列表生成带浅色字体的MChip。 CopyableText：在文本后提供可以复制内容的图标按钮。 DateTimePicker：提高带时分秒选择器的弹出层时间选择器。 EllipsisText：根据父级盒子的宽度自动截断文本。 GenericColumnRender：渲染DateTime、枚举、bool和其他类型值。可以用于MDataTable的ItemColContent和Definitions的DetailContent。 PageHeader组件作为 MASA.Blazor 预置组件的一部分已经发布，其他提及的组件还没有并入 MASA.Blazor 主库。如果你想要使用或参考，可以访问 MASA.Blazor.Experimental.Components。关于预置组件和实验性组件的详细介绍和使用的文章，后面会由其他同事编写和发布，请大家带多多关注！ MASA.Blazor.Experimental.Components 是一个实验性组件库，这意味着该库的API和功能可能会被重新设计。不过随着实验性组件的功能不断完善和稳定，会随便 MASA.Blazor 版本的更新而并入主库。 技巧善用基类Blazor的组件其实也是一个类，它默认继承自 ComponentBase 并提供了许多虚拟方法，我们可以重写它们来影响应用程序的行为。而这些方法通过继承机制给所有Blazor组件使用。 在实际开发中，我会发现几乎每个页面都会注入 NavigationManager、IJsRunTime 和其他可能存在的业务服务，或者会使用某些共同使用的组件，那我们可以在继承 ComponentBase 的基础上再写一个已经使用了这些服务和组件的基类。 按架构可以创建专门给 @page 组件用的 PageComponentBase 和单纯封装功能的 PureComponentBase。按业务分类就得看情况了，因为业务更加具体，基类里通常会有注入 HttpClient 或者同类型业务服务，以及任何共同使用的代码。 SetParametersAsync SetParametersAsync sets parameters supplied by the component’s parent in the render tree or from route parameters. 只需知道每当父级呈现时，都会执行此方法。这意味着它是指定默认参数值的正确位置。拿前面的例子来说，在使用 MTextField 和 MSelect 时都会设置以下代码来维持相同的外观和行为： 1234ClearableDenseHideDetails=&quot;@(&quot;auto&quot;)&quot;Outlined 那么与其每次都要写一遍，不如利用 SetParametersAsync 的特性把这些默认参数提前设置： 12345678910111213141516171819202122232425public class DefaultTextField&lt;TValue&gt; : MTextField&lt;TValue&gt;{ public override async Task SetParametersAsync(ParameterView parameters) { Clearable = true; Dense = true; HideDetails = &quot;auto&quot;; Outlined = true; await base.SetParametersAsync(parameters); }}public class DefaultSelect&lt;TItem, TItemValue, TValue&gt; : MSelect&lt;TItem, TItemValue, TValue&gt;{ public override async Task SetParametersAsync(ParameterView parameters) { Clearable = true; Dense = true; HideDetails = &quot;auto&quot;; Outlined = true; await base.SetParametersAsync(parameters); }} 1234567891011121314151617&lt;DefaultTextField @bind-Value=&quot;@summary&quot; OnKeyDown=&quot;@context.onEnter&quot; OnClearClick=&quot;@context.onSearch&quot; Label=&quot;Summary&quot;&gt;&lt;/DefaultTextField&gt;&lt;DefaultSelect @bind-Value=&quot;warningSigns&quot; Items=&quot;@(Enum&lt;WarningSigns&gt;.GetEnumObjectList&lt;WarningSigns&gt;())&quot; ItemText=&quot;item =&gt; item.Name&quot; ItemValue=&quot;item =&gt; item.Value&quot; TValue=&quot;WarningSigns?&quot; TItem=&quot;EnumObject&lt;WarningSigns&gt;&quot; TItemValue=&quot;WarningSigns&quot; Label=&quot;高温警告&quot; OnSelectedItemUpdate=&quot;@context.onSearch&quot; OnClearClick=&quot;@context.onSearch&quot;&gt;&lt;/DefaultSelect&gt; 未来的计划未来我们团队将继续优化各个组件的性能，完成缺失的组件，解决BUG问题，完善文档等。另外，我们也计划出Blazor相关的教程和分享文章，敬请期待。 感谢阅读！ 资源 源码 https://github.com/capdiem/MasaBlazorStandardTablePage 参考 https://blazor.masastack.com/ https://github.com/BlazorComponent/Masa.Blazor https://github.com/capdiem/MASA.Blazor.Experimental.Components 开源地址MASA.BuildingBlocks：https://github.com/masastack/MASA.BuildingBlocks MASA.Contrib：https://github.com/masastack/MASA.Contrib MASA.Utils：https://github.com/masastack/MASA.Utils MASA.EShop：https://github.com/masalabs/MASA.EShop MASA.Blazor：https://github.com/BlazorComponent/MASA.Blazor 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们","link":"/2022/03/04/masa/framework/masa-blazor/2.%E4%BD%BF%E7%94%A8MASA.Blazor%E5%86%99%E4%B8%80%E4%B8%AA%E6%A0%87%E5%87%86%E7%9A%84%E6%9F%A5%E8%AF%A2%E8%A1%A8%E6%A0%BC%E9%A1%B5/"},{"title":"MASA Blazor入门这一篇就够了","text":"1.什么是Blazor? 有什么优势？ASP.NET Core Blazor 简介 Blazor 是一个使用 Blazor 生成交互式客户端 Web UI 的框架： 使用 C# 代替 JavaScript 来创建信息丰富的交互式 UI。 共享使用 .NET 编写的服务器端和客户端应用逻辑。 将 UI 呈现为 HTML 和 CSS，以支持众多浏览器，其中包括移动浏览器。 与新式托管平台（如 Docker）集成。 Blazor 优势： 1. 使用 C# 代替 JavaScript 来编写代码。 2. 利用现有的 .NET 库生态系统。 3. 在服务器和客户端之间共享应用逻辑。 4. 受益于 .NET 的性能、可靠性和安全性。 5. 在 Windows、Linux 和 macOS 上使用 Visual Studio 保持高效工作。 6. 以一组稳定、功能丰富且易用的通用语言、框架和工具为基础来进行生成。 2.为什么选择MASA Blazor？能用来干什么？ MASA Blazor是一个基于 Blazor Component 和 Material Design 的 UI 组件库。 dotNET开发者不需要懂得javascript就能开发一个企业级中后台系统。 MASA Blazor优势： 丰富组件：包含Vuetify 1:1还原的基础组件，以及很多实用的预置组件和.Net深度集成功能，包括Url、面包 屑、导航三联动，高级搜索，i18n等。 UI设计语言：设计风格现代，UI 多端体验设计优秀。 简易上手：丰富详细的上手文档，免费的视频教程（制作中）。 社区活跃鼓励：用户参与实时互动，做出贡献加入我们，构建最开放的开源社区。 长期支持：全职团队维护，并提供企业级支持。 专业示例：MASA Blazor Pro提供多种常见场景的预设布局。 MASA Blazor Pro预设布局示例： 看到这里是不是有同学对此感兴趣起来了呢！那么这样的布局页面是怎么构建出来的呢？我们自己能不能也搭建一个这样的布局呢！嘿嘿！不要着急、我们接着往下看。 3.使用MASA Blazor模板创建第一个Blazor程序1.首先安装Masa.Template模板（1）检查本机.Net SDK版本，请确保已安装.NET6.0 （2）安装 Masa.Template模板,包含 MASA 系列所有项目模板dotnet new –install Masa.Template 2.创建项目dotnet new masab -o MasaBlazorApp默认为Server模式 可通过参数–Mode WebAssembly 创建 WebAssembly 模式项目 3.配置 MASA Blazor（由于我这里使用了模板，以下配置在模板中都已经帮我们配好了，安装模板后直接dotnet run 即可；未安装模板的同学，按下面步骤配置即可）（1）安装NuGet包 dotnet add package Masa.Blazor （2）引入资源文件（我这里为Blazor Server） 在 Pages/_Layout.cshtml 中引入资源文件 （3）注入相关服务 在 Program.cs 中添加 Masa.Blazor 相关服务 builder.Services.AddMasaBlazor(); （4）修改 _Imports.razor 文件,添加以下内容: @using Masa.Blazor （5）运行项目 到这里一个简单的MASA Blazor项目就搭建完成啦。当然这只是最基础的，接下来我们将一步一步使用MASA Blazor项目组件来丰富我们的项目。 3.使用MASA Blazor组件配置项目示例： （1）Blazor应用结构介绍首先我们先来看看Blazor项目结构，分析主要几个文件的作用。（概念定义比较枯燥，想直接体验的同学可以直接跳过此部分，直接上手实践即可，但不推荐这么做，有句话说得好“磨刀不误砍柴工” Program.cs Blazor服务器应用的入口点在Program.cs文件中定义，与控制台应用一样。当应用执行时，它会使用特定于 Web 应用的默认值创建并运行 Web 主机实例。 Web 主机会管理 Blazor 服务器应用的生命周期，并设置主机级别服务。 在 Blazor 服务器应用中，显示的 Program.cs 文件用于为 Blazor 在客户端浏览器与服务器之间使用的实时连接设置终结点。在 BlazorWebAssembly 应用中，Program.cs 文件定义应用的根组件及其呈现位置： 在Program.cs文件中我们先主要关注几个点： 1.在依赖注入中，因为我们利用了Razor来实现C#和html的混合编码以及我们使用的是ServerSide的Blazor，注入代码如下：中间件如下： _Host.cshtml 在Blazor服务器应用中，根组件的主机页面在_Host.cshtml文件中定义。这个文件定义一个Razor页面，而不是一个组件。Razor Pages 使用 Razor 语法定义服务器可寻址页面。 在Program.cs文件中会自动去我们配置的_Host.cshtml文件中寻找根组件这是默认使用App组件作为根组件（这是启动Blazor应用的必要条件之一） 那么render-mode 特性是用来干什么的呢?让我们来看看官方文档解释： App.razorBlazor应用的根组件，里面通常包含Router组件用来处理Blazor中的路由 那么Router组件中的这些参数比如AppAssembly、Found、NotFound都有什么作用呢？ 通过阅读官方文档我们可以发现： Router 组件会在指定的 AppAssembly 和 AdditionalAssemblies（可选）中发现可路由组件。 浏览器进行导航时，如果有路由与地址匹配，Router 会拦截导航并呈现其 Found 参数的内容和提取的 RouteData，否则 Router 会呈现其 NotFound 参数。 RouteView 组件负责呈现由 RouteData 指定的匹配组件及其布局（如果有）。 如果匹配组件没有布局，则使用可选择指定的 DefaultLayout。 LayoutView 组件在指定布局内呈现其子内容 也就是说我们在配置完.razor页面的路由后，Router组件会在浏览器进行导航时将路由与地址匹配，能够匹配到的，Router就会拦截导航并呈现其Found参数指定的匹配组件和布局（我们这里指定MainLayout布局页面），反之，则呈现NotFound参数。 _Layout.cshtml 在之前的_Host.cshtml文件中我们默认指定启用了_Layout.cshtml布局页_Layout.cshtml是Blazor应用的主机页（相当于一个根页面布局文件），里面包含应用的初始化HTML 及其组件，它使得我们所有页面布局保持的外观变得更加的容易。 MainLayout.razor 在Blazor中，使用布局组件处理页面布局。布局组件继承自LayoutComponentBase,后者定义类型RenderFragment 的单个 Body 属性，该属性可用于呈现页面的内容。 _Imports.razor全局导入配置，在这里使用using引入后，相当于在所有razor文件中都进行了引入。 好了，废话有点多, 到这里Blazor应用部分主要结构概念差不多已经介绍完了，感兴趣的同学可自行移步官网进行阅读 面向 Web Forms ASP.NET Web Forms 开发人员的 Blazor接下来我们直接开始撸代码 （2）使用App bars（应用栏）与Navigation drawers（导航抽屉）配置导航栏与菜单栏上述页面展示中我们看到了三个菜单页面，这几个页面都分别配置了对应路由Home对应页面为Index.razor、路由为”/“ Counter对应页面为Counter.razor、路由为”/counter” Fetch Data页面对应FetchData.razor页面路由，路由为”/fetchdata”在Shared/MainLayout.razor页面中我们可以看到配置。 接下来我们直接移步MASA Blazor 官网地址找到我们需要的组件示例： 我们直接将示例代码拷贝至Shared/MainLayout.razor页面中的MAppBar组件中即可 dotnet run 看下效果 接下来我们MASA Blazor组件库中找到Navigation drawers组件，将razor页面代码与C#代码拷贝至组件中即可 我们对代码稍作修改 dotnet run 看下效果 下一步我们来实现动态菜单栏伸缩功能 找到Navigation drawers组件的迷你模式 接下来我们来改造我们的代码 dotnet run 看下效果 是不是感觉超级简单呢！当然这只是入门写法，抛砖引玉，感兴趣的同学可以动手试试，举一反三解锁更多组件的用法与写法 （3）使用DataTable、Dialog等组件实现一个基础的数据交互页首先我们先初始化Fetch.razor，只留一个最简单组件 DataTable组件需要至少绑定一个Headers（表头）和数据源所以下一步我们先定义Headers与Items（实际调用API获取数据即可，这里默认死数据仅作参考）我们先建一个Fetch.razor页的分部类，定义部分代码 dotnet run 看看效果 在上述代码截图中会发现我们用到了OnInitializedAsync()方法，那么这个方法是用来干什么的呢？说到这个问题，我们需要先了解了解Razor组件的生命周期ASP.NET Core Razor 组件生命周期 先来看个 Component lifecycle diagram（组件生命周期图） SetParametersAsync - 设置参数时 每当父级呈现时，都会执行此方法。传入组件的参数包含在ParameterView中。这是根据传入组件的状态对服务器进行异步调用(例如)的好时机。在重写中调用base.SetParametersAsync(Parameters)时，会为组件的[Parameter]属性赋值。它也是指定默认参数值的正确位置。 OnInitialized / OnInitializedAsync - 组件初始化 将ParameterCollection中的状态分配给组件的[Parameter]属性后，将执行这些方法。这与SetParametersAsync的用法相同，不同之处在于可以使用组件的状态。 该方法仅在组件首次创建时执行一次。如果父级稍后更改组件的参数，则跳过此方法。 注意：当组件是@page，并且Blazor应用程序导航到呈现同一页面的新URL时，Blazor将为该页面重用当前对象实例。因为该对象是同一实例，所以Blazor不会对该对象调用IDisposable.Dispose，也不会再次执行其OnInitialized方法。 OnParametersSet / OnParametersSetAsync - 参数设置后 如果这是组件的新实例，则此方法将在OnInitializedAsync之后立即执行。如果它是因为其父组件正在重新呈现而正在重新呈现的现有组件，则不会执行OnInitialized*方法，而是在SetParametersAsync之后立即执行此方法。 OnAfterRender / OnAfterRenderAsync - 组件渲染后 这两个方法在Blazor每次重新生成组件的RenderTree时执行。这可能是因为组件的父级重新呈现、用户与组件交互(例如，鼠标单击)，或者如果组件执行其StateHasChanged方法来调用重新呈现。 了解Razor组件的生命周期后，我们来继续撸代码 我们给数据表格增加操作列 看下效果：接下来我们给增加一个MDialog 对话框 用来做增加修改操作直接将官网的示例拿过来即可 在这过程中我们需要给Dialog组件以及组件中的其他组件使用Bind-Value（双向绑定）绑上值。 接下来我们给数据表格的Action操作列增加OnClick点击事件 对应绑定分部类中EditItem方法 我们先运行看下效果： 这两个按钮分别对应两个Button Close直接绑定后台关闭Dialog方法 Save方法则是用来做最终修改数据等操作DB的方法这里就不做演示，感兴趣的同学可自行结合业务做相应的操作。 （4）使用预置组件应对常用业务的场景在我们实际项目中，难免会碰到需要你开发多个模块或者多个管理页面，这样一来每个页面不可避免的会有一些需要你重复编码的地方，那么你是选择每个页面copy一份相同的代码还是选择封装一个业务组件呢？毫无疑问，聪明的同学肯定会选择后者，当然新入门的同学可以先来看看MASA Blazor提供预置组件，拿来即用，后期同学们登堂入室后可自行根据当前业务封装业务组件。 我们先来看看通用页头预置组件：直接copy代码看看效果： 当我们数据表格中数据内容长度过长时可以使用封装好的预置组件：看看效果： 使用方法很简单且支持复制效果：当然还有其他常用的预置组件，由于本文篇幅有限，只做个别组件使用介绍，使用方法都大差不差，感兴趣的同学可自行去官网查阅。 结尾本文介绍内容只针对刚入门的同学，抛砖引玉，对于封装组件技巧以及组件高深用法感兴趣的同学可以关注我们同系列其他同学的文章或者直接去官网查看源码： 使用MASA Blazor开发一个标准的查询表格页以及封装技巧介绍 参考资源 https://blazor.masastack.com/ https://github.com/BlazorComponent/MASA.Blazor https://gitee.com/blazorcomponent/MASA.Blazor https://blazor-pro.masastack.com/dashboards/ecommerce https://github.com/BlazorComponent/MASA.Blazor.Pro https://blazor-university.com/ https://github.com/capdiem/MASA.Blazor.Experimental.Components 开源地址MASA.BuildingBlocks：https://github.com/masastack/MASA.BuildingBlocks MASA.Contrib：https://github.com/masastack/MASA.Contrib MASA.Utils：https://github.com/masastack/MASA.Utils MASA.EShop：https://github.com/masalabs/MASA.EShop MASA.Blazor：https://github.com/BlazorComponent/MASA.Blazor 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们","link":"/2022/03/14/masa/framework/masa-blazor/3.MASA%20Blazor%E5%85%A5%E9%97%A8%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/"},{"title":"体验了一把最近很火的开源项目-MASA Blazor","text":"前言 很惭愧直到去年底才接触到Blazor。那什么是Blazor呢？相信大家都看过官方文档的详细说明，另外MASA团队也有不错的说明介绍 。用官方的话说Blazor是一个交互式客户端Web UI的框架，并且使用C#开发而不是JavaScript。好了言归正传，事情的起因是这样的，公司组织内部竞赛需要用Blazor做一个简单的网页。为了可以更好的做出效果就简单的尝试了几个开源组件。 开源组件选择 遇事不决先找官方Blazor 教程，跟着微软的教程会得到下面这个样子的页面。 嗯，还是挺清新的…估计会被领导喷死吧。既然官方提供的样式太清新。那就要想一下怎么弯道超车了。 于是乎开始网上冲浪，首先想到的是Bootstrap Blazor组件库，也没有什么特别的原因可能只是因为以前经常用它写后台页面吧。打开它的文档站点是下面这样的 无惊无喜吧，组件库看起来还是蛮丰富的。接着在比较下Ant Design Blazor。 颜值党感觉拉不开差距，接着就看到了前几天发布的MASA Blazor。跟上面两个大名鼎鼎相比这个名气相对小了一些。不过人不可貌相海水不可瓢崴，这个官网首页高大上了不少啊。希望组件库别翻车。 虽然说组件库是列表展示没有平铺那么直观吧，但是这几个示例做的也好看太多了。 既然好看就赶紧趁热再多了解一下，打开源码他们也是有快速创建项目模板的。这里我就直接把官方的使用介绍拿来用了。 按照模板生成出来的是这个样子的，我个人是非常喜欢这种设计风格的，感觉可以省不少事。 使用MASA Blazor做个后台管理页面1.输入框1&lt;MTextField @bind-Value=&quot;_options.Title&quot; Label=&quot;标题&quot;&gt;&lt;/MTextField&gt; 这样就完成了一个输入框并且绑定了_options.Title这个对象。查看了官网文档并且进入了官方的交流区，发现了还有更实用的技巧。使用onEnter及onSearch就可以实现回车触发检索条件了，相当于JS的onkeydown事件。 1234567891011121314151617&lt;PPageHeader Title=&quot;搜索&quot; ShowFiltersByDefault OnSearch=&quot;() =&gt; FetchList()&quot;&gt; &lt;Filters Context=&quot;filter&quot;&gt; &lt;MRow Dense&gt; &lt;MCol Cols=&quot;12&quot; Sm=&quot;6&quot; Md=&quot;4&quot;&gt; &lt;MTextFieldLabel=&quot;标题&quot; @bind-Value=&quot;_options.Title&quot; Dense HideDetails=&quot;auto&quot; Outlined Clearable OnKeyDown=&quot;filter.onEnter&quot; OnClearClick=&quot;filter.onSearch&quot;&gt; &lt;/MTextField&gt; &lt;/MCol&gt; &lt;/MRow&gt; &lt;/Filters&gt;&lt;/PPageHeader&gt; 2.下拉框12345678910111213141516&lt;MSelect Label=&quot;状态&quot; Dense HideDetails=&quot;auto&quot; Outlined Clearable MenuProps=&quot;(props) =&gt; props.OffsetY = true&quot; Items=&quot;Enum&lt;StateTypes&gt;.GetEnumObjectList&lt;StateTypes&gt;()&quot; ItemText=&quot;item =&gt; item.Name&quot; ItemValue=&quot;item =&gt; item.Value&quot; @bind-Value=&quot;_options.State&quot; TItem=&quot;EnumObject&lt;StateTypes&gt;&quot; TValue=&quot;StateTypes?&quot; TItemValue=&quot;StateTypes&quot; OnSelectedItemUpdate=&quot;filter.onSearch&quot; OnClearClick=&quot;filter.onSearch&quot;&gt;&lt;/MSelect&gt; 这样就可以实现把枚举StateTypes直接转成下拉菜单展示了。 3.日期选择器1234567891011&lt;PDateTimePicker Label=&quot;发布开始时间&quot; Clearable Dense DefaultSelectedValue=&quot;DateTime.UtcNow&quot; HideDetails=&quot;auto&quot; Outlined Format=&quot;yyyy-MM-dd HH:mm:ss&quot; @bind-Value=&quot;_options.ReleaseStartTime&quot; OnOk=&quot;filter.onSearch&quot; OnClearClick=&quot;filter.onSearch&quot;&gt;&lt;/PDateTimePicker&gt; 4.数据表格 数据表格这里使用的时候遇到了一个小问题。就是分页的数量。从官网的示例中可以看到这里是支持全部获取的，但真实的场景这种情况肯定是要规避的。看了官方博客使用MASA.Blazor写一个标准的查询表格页 - MASA Blogs也没有找到好的答案。 还好开发者很积极的告诉了我为什么要这样设计并且展示，也告诉了我自定义的方法。只需要对FooterProps赋值并设置ItemsPerPageOptions属性就可以了。因为后台有很多列表页面，每一个都设置一次就太麻烦了所以重写了一下MDataTable设置了默认值为每页取5，10，15条数据分别。下面是组件的使用及相关参数配置。 1234567891011121314public partial class DefaultDataTable&lt;TItem&gt; : MDataTable&lt;TItem&gt;{ public override async Task SetParametersAsync(ParameterView parameters) { FooterProps = new Dictionary&lt;string, object&gt;() { { &quot;ItemsPerPageOptions&quot;, new List&lt;OneOf&lt;int, DataItemsPerPageOption&gt;&gt;() { 5, 10, 15 } } }; await base.SetParametersAsync(parameters); }} 下面是Headers属性的设置，这里我加了一个actions用于对数据做也写额外的操作。比如编辑，删除这些。 123456789101112private readonly List&lt;DataTableHeader&lt;BlogInfoListViewModel&gt;&gt; _headers = new(){ new DataTableHeader&lt;BlogInfoListViewModel&gt;() { Text = &quot;标题&quot;, Value = nameof(BlogInfoListViewModel.Title), Sortable = false }, //这里还有很多字段...... new DataTableHeader&lt;BlogInfoListViewModel&gt;() { Text = &quot;操作&quot;, Value = &quot;actions&quot;, Sortable = false }}; 下面是组件的使用及效果。 12345678910111213141516171819202122232425&lt;DefaultDataTable Headers=&quot;_headers&quot; Items=&quot;_tableData&quot; Loading=&quot;_loading&quot; OnOptionsUpdate=&quot;HandleOnOptionsUpdate&quot; Page=&quot;_options.PageIndex&quot; ItemsPerPage=&quot;_options.PageSize&quot; ServerItemsLength=&quot;_totalCount&quot; TItem=&quot;BlogInfoListViewModel&quot;&gt; &lt;ItemColContent&gt; @if (context.Header.Value == &quot;actions&quot;) { &lt;Actions&gt; &lt;Action Color=&quot;primary&quot; Icon=&quot;mdi-eye-outline&quot; Label=&quot;查看&quot; OnClick=&quot;() =&gt; HrefDetailPage(context.Item.Id)&quot;&gt; &lt;/Action&gt; &lt;/Actions&gt; } else { @context.Value } &lt;/ItemColContent&gt;&lt;/DefaultDataTable&gt; 分页改掉了，并且一个后台的管理页面也差不多出来了。虽然没有官方模板做的那么优雅，但是看起来整体还是挺舒服的。 5.表单对话框 这里使用弹窗做了个审核下架的功能。使用了预置组件里面的FormModal。很简单的可以写一个对话框。 123456789&lt;FormModal Visible=&quot;_withdrawModalVisible&quot; Title=&quot;@($&quot;下架文章（{CurrentModel?.Title}）&quot;)&quot; Width=&quot;800&quot; OnCancel=&quot;() =&gt; _withdrawModalVisible = false&quot; OnOk=@HandleOnOk&gt; &lt;MRow&gt; //这里就可以画具体的内容了 &lt;/MRow&gt;&lt;/FormModal&gt; 6.单选按钮 单选按钮是用在表单对话框里根据枚举做单选。放在FormModal的插槽里使用的。 1234567891011&lt;MRadioGroup @bind-Value=&quot;Data.ReasonType&quot; TValue=ReasonTypes&gt; &lt;LabelContent&gt; 下架原因 &lt;/LabelContent&gt; &lt;ChildContent&gt; @foreach (var item in Enum&lt;ReasonTypes&gt;.GetEnumObjectList&lt;ReasonTypes&gt;()) { &lt;MRadio Value=&quot;@item.Value&quot; Label=@item.Name TValue=&quot;ReasonTypes&quot;&gt;&lt;/MRadio&gt; } &lt;/ChildContent&gt;&lt;/MRadioGroup&gt; 7.多行文本框 该组件我依然是在FormModal使用的，很简单直接贴代码。 1234567&lt;MTextarea Label=&quot;原因详情&quot; Clearable Dense HideDetails=&quot;auto&quot; Outlined @bind-Value=&quot;Data.ReasonDetail&quot;&gt;&lt;/MTextarea&gt; 完整的对话框展示 个人感触 首先很感谢开发者可以提供一个好用美观且免费的组件库。感谢对开源做出的贡献，让我做页面的时候多了一个选择。当然也是全程跟着官方的文章一步步来的，传送门MASA Blazor入门这一篇就够了 - MASA Blogs。分享的初衷可能相比于官方更想说明，怎样可以简单优雅的做出来一个实际的页面。当然也参考了很多的文章，咨询了开发者。这里很喜欢官网上的一句话希望与大家共勉。“MASA Blazor 不是 一个个人秀。 是一群非常活跃和投入的技术人员组成的团队，想要通过不断努力为开发人员带来更好的体验。","link":"/2022/03/28/masa/framework/masa-blazor/4.%E4%BD%93%E9%AA%8C%E4%BA%86%E4%B8%80%E6%8A%8A%E6%9C%80%E8%BF%91%E5%BE%88%E7%81%AB%E7%9A%84%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE-MASA%20Blazor/"},{"title":"在MAUI中使用Masa Blazor","text":"Masa Blazor是什么在此之前我们已经介绍过什么是Masa Blazor，以及如何使用Masa Balzor，如果还有不了解Masa Blazor的同学可以看我上篇文章【初识Masa Blazor】。那么今天就带大家探索一下如何在MAUI中使用Masa Blazor,那么我们先来了解一下什么是MAUI？ MAUI是什么.NET MAUI全称为 .NET Multi-platform App UI ，顾名思义就是.NET多平台应用 UI，是一个跨平台的框架，是 Xamarin.Forms 的演变，其使用C#和XAML创建本机移动和桌面应用，这里的XAML可以替换成RazorView。 使用 .NET MAUI，可以开发可在 Android、iOS、macOS 和 Windows从单个共享代码库运行的应用，一套代码多端运行。 MAUI优点： 从 XAML 和 C# 中的单个共享代码库编写跨平台Visual Studio。 跨平台共享 UI 布局和设计。 跨平台共享代码、测试和业务逻辑。 另一个优点是跨框架重用 Razor 组件，它可以实现为 Razor 类库 (RCL) 并与 Blazor Server 和 WebAssembly 共享。这允许最大限度地重用代码并从单个代码库生成移动、桌面和 Web 解决方案。 今天我们重点在实操，就不介绍那么多概念性的东西了。想了解更多关于MAUI的同学可以移步官方文档介绍 什么是 .NET MAUI？，本篇文章会带大家使用MAUI+Masa Blazor做一个移动端常见的时间轴页面，并加一点切换主题色的小功能，效果图如下： 接下来让我们一步步去实现它。首先我们先准备好必备的环境。 注：文章示例演示环境为（Maui 6.0.200-preview.14.5 + Masa.Blazor 0.3.0） MAUI环境准备 首先要确保安装了最新版的 Visual Studio，并且安装了Mobile development with .NET工作负载。 启用硬件加速才能最大化 Android 模拟器性能，我们可以启用Hyper-V或HAXM加速，这里只介绍第一种 在 Windows 搜索框中输入“Windows 功能”，然后在搜索结果中选择“打开或关闭 Windows 功能” 。 在“Windows 功能”对话框中，启用“Hyper-V”和“Windows 虚拟机监控程序平台” ： 进行这些更改后，重新启动计算机。 请确保 在 Android Device Manager 中创建 的虚拟设备是 x86 64 或基于 x86的系统映像。 如果使用基于 Arm 的系统映像，则不会加速虚拟设备，并且运行速度会缓慢。启用 Hyper-v 后，可以运行加速 Android 仿真器。HAXM加速和详细设置可参考：如何使用 Android 仿真程序 &amp; 启用硬件加速 创建MAUI应用并引入Masa Blazor 创建项目选择.NET MAUI Blazor App。这样的话我们就能使用Blazor View来写UI界面了 在nuget中安装Masa.Blazor，并在MauiProgram.cs文件中注册相关服务 1builder.Services.AddMasaBlazor(); CreateMauiApp()方法简单理解：在启动方法中，调用了RegisterBlazorMauiWebView()构建器对象的扩展方法，然后将 BlazorWebView 本身添加到具有该builder.Services属性的 DI 容器的 Services 集合中。这将执行依赖注入加载特定于平台的视图以呈现输出 HTML，因为每个平台都有自己的 Web 引擎，BlazorWebView（从View继承）控件，它能够在运行时处理 Razor 组件并生成其等效的 HTML。该 HTML 将使用平台的本机 Web 引擎呈现，而无需任何 Web 服务器的参与。 wwwroot/index.html 中引入样式、字体、脚本 12345678&lt;link href=&quot;_content/Masa.Blazor/css/masa-blazor.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;link href=&quot;_content/Masa.Blazor/css/masa-extend-blazor.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;link href=&quot;https://cdn.masastack.com/npm/@mdi/font@5.x/css/materialdesignicons.min.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;link href=&quot;https://cdn.masastack.com/npm/materialicons/materialicons.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;link href=&quot;https://cdn.masastack.com/npm/fontawesome/v5.0.13/css/all.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;script src=&quot;_content/BlazorComponent/js/blazor-component.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.masastack.com/npm/echarts/5.1.1/echarts.min.js&quot;&gt;&lt;/script&gt;&lt;!-- echarts脚本文件不需要可以不引入 --&gt; 注意：1.MAUI项目中需要在index.html中引入这些文件，而不是像Blazor那样是在Pages/_Layout.cshtml中。 2.从Masa Blazor0.3.0开始采用和微软相同的命名规范（大驼峰），MASA改成了Masa所以升级了0.3.0和之后的版本要注意别写错了，不然会找不到样式文件和js文件 在_Imports.razor文件中引用Masa.Blazor，BlazorComponent命名空间，这样我们就不用每个文件都去引用一遍了 时间轴功能实现我们先在布局页MainLayout.razor中搞出我们页面的大概布局，顶部需要一个Toolbar工具条，底部是底部导航，中间是我们的子页面 这样一种常规的布局页面，点击工具条上面的菜单我们可以切换主题颜色，我们来用Masa Blazor简单实现下。 顶部工具条我们主要用到了MToolbar组件和MMenu组件，底部因为BottomNavigation组件官网暂时暂时还没有，后面版本才会出来，影响不大，我们先用MFooter组件代替。这样我们布局模板页已经搞好了，全局的颜色我们通过变量存起来，通过MMenu选中的值来进行控制 Mainlayout.razor完整代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273@inherits LayoutComponentBase&lt;MApp&gt; &lt;MToolbar MaxHeight=&quot;64&quot; Color=&quot;@_color&quot; Dark&gt; &lt;MAppBarNavIcon&gt;&lt;/MAppBarNavIcon&gt; &lt;MSpacer&gt;&lt;/MSpacer&gt; Timeline &lt;MSpacer&gt;&lt;/MSpacer&gt; &lt;MMenu Left OffsetY Transition=&quot;slide-x-transition&quot; Bottom&gt; &lt;ActivatorContent&gt; &lt;MButton Icon @attributes=&quot;@context.Attrs&quot;&gt; &lt;MIcon&gt;mdi-dots-vertical&lt;/MIcon&gt; &lt;/MButton&gt; &lt;/ActivatorContent&gt; &lt;ChildContent&gt; &lt;MList&gt; @foreach (var item in _colors) { &lt;MListItem OnClick=&quot;()=&gt;{_color = item.Value;}&quot;&gt; &lt;MListItemTitle&gt;@item.Text&lt;/MListItemTitle&gt; &lt;/MListItem&gt; } &lt;/MList&gt; &lt;/ChildContent&gt; &lt;/MMenu&gt; &lt;/MToolbar&gt; &lt;div style=&quot;width:100%; height:100%&quot;&gt; &lt;CascadingValue Value=&quot;_color&quot;&gt; @Body &lt;/CascadingValue&gt; &lt;/div&gt; &lt;MFooter Color=&quot;#FAFAFA&quot; Elevation=&quot;2&quot;&gt; &lt;MRow NoGutters Justify=&quot;JustifyTypes.SpaceBetween&quot;&gt; &lt;MCol Style=&quot;display:flex; justify-content:center;&quot;&gt; &lt;MButton Color=&quot;@_color&quot; Icon Class=&quot;my-2 white--text&quot;&gt; &lt;MBadge OverLap Color=&quot;error&quot; Content=&quot;6&quot;&gt; &lt;ChildContent&gt; &lt;MIcon&gt;mdi-chat&lt;/MIcon&gt; &lt;/ChildContent&gt; &lt;/MBadge&gt; &lt;/MButton&gt; &lt;/MCol&gt; &lt;MCol Style=&quot;display:flex; justify-content:center;&quot;&gt; &lt;MButton Color=&quot;@_color&quot; Icon Class=&quot;my-2 white--text&quot;&gt; &lt;MIcon&gt;mdi-account-details&lt;/MIcon&gt; &lt;/MButton&gt; &lt;/MCol&gt; &lt;MCol Style=&quot;display:flex; justify-content:center;&quot;&gt; &lt;MButton Color=&quot;@_color&quot; Icon Class=&quot;my-2 white--text&quot;&gt; &lt;MIcon&gt;mdi-compass&lt;/MIcon&gt; &lt;/MButton&gt; &lt;/MCol&gt; &lt;/MRow&gt; &lt;/MFooter&gt;&lt;/MApp&gt;@code{ private string _color = &quot;purple darken-3&quot;; private List&lt;(string Text, string Value)&gt; _colors = new() { new(&quot;pink&quot;, &quot;purple darken-1&quot;), new(&quot;indigo&quot;, &quot;indigo&quot;), new(&quot;teal&quot;, &quot;teal&quot;), new(&quot;deep-purple&quot;, &quot;deep-purple darken-1&quot;), new(&quot;yellow&quot;, &quot;yellow darken-4&quot;), };} 接下来我们再来实现Body页面，Body页面就是我们的主要内容了。这里我们可以去Masa Blazor官网找一下Timelines组件直接使用，刚好官网有移动端Timeline的示例demo，只是示例没有改变颜色的功能，没关系我们拿过来改一改。 我们把代码Copy过来，去掉他顶部的工具条，因为我们顶部已经在布局页面里写过了，而且是应用在每个子页面的，所以这里就不用在写了。但是这里要考虑怎么把_color参数传到Timeline页面里面，这里我们用到了级联参数，通过 CascadingValue 来把参数传递给子页面，子页面通过CascadingParameter来接收，这样我们在子页面里就可以拿到颜色变量了。 Timeline.razor完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106@page &quot;/&quot;&lt;MCard Elevation=&quot;0&quot; Class=&quot;mx-auto&quot;&gt; &lt;MCard Dark Flat&gt; &lt;MButton Absolute Bottom Color=&quot;@Color&quot; Right Fab&gt; &lt;MIcon&gt;mdi-plus&lt;/MIcon&gt; &lt;/MButton&gt; &lt;MImage Src=&quot;https://cdn.masastack.com/stack/images/website/masa-blazor/cards/forest.jpg&quot; Gradient=&quot;to top, rgba(0,0,0,.44), rgba(0,0,0,.44)&quot; Dark&gt; &lt;MContainer Class=&quot;fill-height&quot;&gt; &lt;MRow Align=&quot;@AlignTypes.Center&quot;&gt; &lt;strong class=&quot;text-h1 font-weight-regular mr-6&quot;&gt;8&lt;/strong&gt; &lt;MRow Justify=&quot;@JustifyTypes.End&quot;&gt; &lt;div class=&quot;text-h5 font-weight-light&quot;&gt; Monday &lt;/div&gt; &lt;div class=&quot;text-uppercase font-weight-light&quot;&gt; February 2015 &lt;/div&gt; &lt;/MRow&gt; &lt;/MRow&gt; &lt;/MContainer&gt; &lt;/MImage&gt; &lt;/MCard&gt; &lt;MCardText Class=&quot;py-0&quot;&gt; &lt;MTimeline AlignTop Dense&gt; &lt;MTimelineItem Color=&quot;pink&quot; Small&gt; &lt;MRow Class=&quot;pt-1&quot;&gt; &lt;MCol Cols=&quot;3&quot;&gt; &lt;strong&gt;5pm&lt;/strong&gt; &lt;/MCol&gt; &lt;MCol&gt; &lt;strong&gt;New Icon&lt;/strong&gt; &lt;div class=&quot;text-caption&quot;&gt; Mobile App &lt;/div&gt; &lt;/MCol&gt; &lt;/MRow&gt; &lt;/MTimelineItem&gt; &lt;MTimelineItem Color=&quot;@Color&quot; Small&gt; &lt;MRow Class=&quot;pt-1&quot;&gt; &lt;MCol Cols=&quot;3&quot;&gt; &lt;strong&gt;3-4pm&lt;/strong&gt; &lt;/MCol&gt; &lt;MCol&gt; &lt;strong&gt;Design Stand Up&lt;/strong&gt; &lt;div class=&quot;text-caption mb-2&quot;&gt; Hangouts &lt;/div&gt; &lt;MAvatar&gt; &lt;MImage Src=&quot;https://avataaars.io/?avatarStyle=Circle&amp;topType=LongHairFrida&amp;accessoriesType=Kurt&amp;hairColor=Red&amp;facialHairType=BeardLight&amp;facialHairColor=BrownDark&amp;clotheType=GraphicShirt&amp;clotheColor=Gray01&amp;graphicType=Skull&amp;eyeType=Wink&amp;eyebrowType=RaisedExcitedNatural&amp;mouthType=Disbelief&amp;skinColor=Brown&quot;&gt;&lt;/MImage&gt; &lt;/MAvatar&gt; &lt;MAvatar&gt; &lt;MImage Src=&quot;https://avataaars.io/?avatarStyle=Circle&amp;topType=ShortHairFrizzle&amp;accessoriesType=Prescription02&amp;hairColor=Black&amp;facialHairType=MoustacheMagnum&amp;facialHairColor=BrownDark&amp;clotheType=BlazerSweater&amp;clotheColor=Black&amp;eyeType=Default&amp;eyebrowType=FlatNatural&amp;mouthType=Default&amp;skinColor=Tanned&quot;&gt;&lt;/MImage&gt; &lt;/MAvatar&gt; &lt;MAvatar&gt; &lt;MImage Src=&quot;https://avataaars.io/?avatarStyle=Circle&amp;topType=LongHairMiaWallace&amp;accessoriesType=Sunglasses&amp;hairColor=BlondeGolden&amp;facialHairType=Blank&amp;clotheType=BlazerSweater&amp;eyeType=Surprised&amp;eyebrowType=RaisedExcited&amp;mouthType=Smile&amp;skinColor=Pale&quot;&gt;&lt;/MImage&gt; &lt;/MAvatar&gt; &lt;/MCol&gt; &lt;/MRow&gt; &lt;/MTimelineItem&gt; &lt;MTimelineItem Color=&quot;pink&quot; Small&gt; &lt;MRow Class=&quot;pt-1&quot;&gt; &lt;MCol Cols=&quot;3&quot;&gt; &lt;strong&gt;12pm&lt;/strong&gt; &lt;/MCol&gt; &lt;MCol&gt; &lt;strong&gt;Lunch break&lt;/strong&gt; &lt;/MCol&gt; &lt;/MRow&gt; &lt;/MTimelineItem&gt; &lt;MTimelineItem Color=&quot;@Color&quot; Small&gt; &lt;MRow Class=&quot;pt-1&quot;&gt; &lt;MCol Cols=&quot;3&quot;&gt; &lt;strong&gt;9-11am&lt;/strong&gt; &lt;/MCol&gt; &lt;MCol&gt; &lt;strong&gt;Finish Home Screen&lt;/strong&gt; &lt;div class=&quot;text-caption&quot;&gt; Web App &lt;/div&gt; &lt;/MCol&gt; &lt;/MRow&gt; &lt;/MTimelineItem&gt; &lt;/MTimeline&gt; &lt;/MCardText&gt;&lt;/MCard&gt;@code{ [CascadingParameter] public string Color { get; set; }} 然后我们把这个页面想要随着主题色变动的颜色改成通过Color变量控制就好了。 这样我们就完成了一个时间轴页面并且可以切换主题色，这里我们还可以基于这个示例加一些功能，比如点击这个＋号按钮去弹窗再去添加一个时间任务去渲染到页面上，也是挺简单的，就不做演示了。本篇文章主要介绍了在MAUI中如何使用Masa Blazor，并做了一个小demo。抛砖引玉，大家也可以尝试用MAUI + Blazor去做一些应用体验一下。 完整示例代码：codding-y/Maui.MasaBlazor (github.com)","link":"/2022/03/28/masa/framework/masa-blazor/5.%E5%9C%A8MAUI%E4%B8%AD%E4%BD%BF%E7%94%A8Masa%20Blazor/"},{"title":"Masa Blazor自定义组件封装","text":"前言实际项目中总能遇到一个”组件”不是基础组件但是又会频繁复用的情况,在开发MASA Auth时也封装了几个组件。既有简单定义CSS样式和界面封装的组件（GroupBox），也有带一定组件内部逻辑的组件(ColorGroup)。本文将一步步演示如何封装出一个如下图所示的ColorGroup组件,将MItemGroup改造为ColorGroup,点击选择预设的颜色值。 MASA Blazor介绍组件展示MASA Blazor 提供丰富的组件（还在增加中）,篇幅限制下面展示一些我常用到的组件 Material Design + BlazorComponentBlazorComponent是一个底层组件框架，只提供功能逻辑没有样式定义，MASA Blazor就是BlazorComponent基础实现了Material Design样式标准。如下图所示，你可以基于Ant Design样式标准实现一套Ant Design Blazor(虽然已经有了，如果你想这么做完全可以实现)。 项目创建首先确保已安装Masa Template（避免手动引用MASA Blazor）,如没有安装执行如下命令: 1dotnet new --install Masa.Template 创建一个简单的Masa Blazor Server App项目： 1dotnet new masab -o MasaBlazorApp 组件封装Blazor组件封装很简单，不需要和vue一样进行注册，新建一个XXX.razor组件就是实现了XXX组件的封装，稍微复杂些的是需要自定义组件内部逻辑以及定义开放给用户（不同的使用场景）的接口（参数），即根据需求增加XXX.razor.cs和XXX.razor.css文件。 界面封装在熟悉各种组件功能的前提下找出需要的组件组装起来简单实现想要的效果。这里我使用MItemGroup、MCard及MButton实现ColorGroup的效果。MItemGroup做颜色分组，且本身提供每一项激活的功能。MCard 作为颜色未选择之前的遮罩层，实现模糊效果。MButton作为颜色展示载体及激活MItem。通过MCard的style设置透明度区分选中、未选中两种状态。 也可通过增加一个对比色的圆形边框标记选中状态，相关CSS参考：https://www.dailytoolz.com/css-border-radius-generator/ 新建ColorGroup.Razor文件，代码如下： 12345678910111213141516171819202122232425&lt;MItemGroup Mandatory Class=&quot;m-color-group d-flex mx-n1&quot;&gt; &lt;MItem&gt; &lt;MCard Class=&quot;elevation-0&quot; Style=&quot;@($&quot;transition: opacity .4s ease-in-out; {(context.Active ? &quot;&quot; : &quot;opacity: 0.5;&quot;)}&quot;)&quot;&gt; &lt;MButton Fab class=&quot;mx-1 rounded-circle&quot; OnClick=&quot;context.Toggle&quot; Width=20 Height=20 MinWidth=20 MinHeight=20 Color=&quot;red&quot;&gt; &lt;/MButton&gt; &lt;/MCard&gt; &lt;/MItem&gt; &lt;MItem&gt; &lt;MCard Class=&quot;elevation-0&quot; Style=&quot;@($&quot;transition: opacity .4s ease-in-out; {(context.Active ? &quot;&quot; : &quot;opacity: 0.5;&quot;)}&quot;)&quot;&gt; &lt;MButton Fab class=&quot;mx-1 rounded-circle&quot; OnClick=&quot;context.Toggle&quot; Width=20 Height=20 MinWidth=20 MinHeight=20 Color=&quot;blue&quot;&gt; &lt;/MButton&gt; &lt;/MCard&gt; &lt;/MItem&gt; &lt;MItem&gt; &lt;MCard Class=&quot;elevation-0&quot; Style=&quot;@($&quot;transition: opacity .4s ease-in-out; {(context.Active ? &quot;&quot; : &quot;opacity: 0.5;&quot;)}&quot;)&quot;&gt; &lt;MButton Fab class=&quot;mx-1 rounded-circle&quot; OnClick=&quot;context.Toggle&quot; Width=20 Height=20 MinWidth=20 MinHeight=20 Color=&quot;green&quot;&gt; &lt;/MButton&gt; &lt;/MCard&gt; &lt;/MItem&gt;&lt;/MItemGroup&gt; 修改Index.Blazor 文件 增加ColorGroup使用代码,Masa.Blazor.Custom.Shared.Presets为自定义组件路径，即命名空间： 12&lt;Masa.Blazor.Custom.Shared.Presets.ColorGroup&gt;&lt;/Masa.Blazor.Custom.Shared.Presets.ColorGroup&gt; 运行代码，看到多出三个不同颜色的圆型： Masa Blazor是Vuetify的Blazor实现，所有的Class除了m-color-group都是Vuetify提供的class样式。 自定义参数通过第一部分可以看到封装的组件面子（界面）有了，但是这个面子是“死”的，不能根据不同的使用场景展示不同的效果，对于ColorGroup而言，最基本的需求就是使用时可以自定义显示的颜色值。Blazor中通过[Parameter]特性来声明参数，通过参数的方式将上叙代码中写死的值改为通过参数传入。如按钮的大小、颜色以及MItemGroup的class和style属性等。同时增加组件的里子（组件逻辑），点击不同颜色按钮更新Value。 新建ColorGroup.Razor.cs文件，添加如下代码： 1234567891011121314151617181920212223242526272829303132public partial class ColorGroup{ [Parameter] public List&lt;string&gt; Colors { get; set; } = new(); [Parameter] public string Value { get; set; } = string.Empty; [Parameter] public EventCallback&lt;string&gt; ValueChanged { get; set; } [Parameter] public string? Class { get; set; } [Parameter] public string? Style { get; set; } [Parameter] public int Size { get; set; } = 24; protected override async Task OnAfterRenderAsync(bool firstRender) { if (firstRender) { if (Colors.Any()) { await ValueChanged.InvokeAsync(Colors.First()); } } await base.OnAfterRenderAsync(firstRender); }} 上面的代码可以看到Value参数有个与之对应的ValueChanged参数，目的是为了能在组件外部接收Value值的变更，通过调用ValueChanged.InvokeAsync通知组件外部Value值更新。 需要注意的是应尽量减少参数定义，太多的参数会增加组件呈现的开销。减少参数传递，可以自定义参数类（本文示例为单独定义多个参数）。如： 1234567@code { [Parameter] public TItem? Data { get; set; } [Parameter] public GridOptions? Options { get; set; }} 同时更新ColorGroup.Razor文件中代码，循环Colors 属性显示子元素以及增加MButton的点击事件，更新Value值： 123456789101112&lt;MItemGroup Mandatory Class=&quot;@($&quot;m-color-group d-flex mx-n1 {@Class}&quot;)&quot; style=&quot;@Style&quot;&gt; @foreach (var color in Colors) { &lt;MItem&gt; &lt;MCard Class=&quot;elevation-0&quot; Style=&quot;@($&quot;transition: opacity .4s ease-in-out; {(context.Active ? &quot;&quot; : &quot;opacity: 0.5;&quot;)}&quot;)&quot;&gt; &lt;MButton Fab class=&quot;mx-1 rounded-circle&quot; OnClick=&quot;()=&gt;{ context.Toggle();ValueChanged.InvokeAsync(color); }&quot; Width=Size Height=Size MinWidth=Size MinHeight=Size Color=&quot;@color&quot;&gt; &lt;/MButton&gt; &lt;/MCard&gt; &lt;/MItem&gt; }&lt;/MItemGroup&gt; 此时使用ColorGroup的代码变为如下代码，可以灵活的指定颜色组数据以及ColorGroup的Class和Style等： 12&lt;Masa.Blazor.Custom.Shared.Presets.ColorGroup Colors='new List&lt;string&gt;{&quot;blue&quot;,&quot;green&quot;,&quot;yellow&quot;,&quot;red&quot;}'&gt;&lt;/Masa.Blazor.Custom.Shared.Presets.ColorGroup&gt; 启用隔离样式第一部分末尾提到了所有的Class除了m-color-group都是Vuetify提供的class样式,那么m-color-group是哪来的？新增ColorGroup.Razor.css 文件，ColorGroup.Razor.css 文件内的css将被限定在ColorGroup.Razor组件内不会影响其它组件。最终会ColorGroup.Razor.css输出到一个名为{ASSEMBLY NAME}.styles.css的捆绑文件中，{ASSEMBLY NAME} 是项目的程序集名称。本文示例并没有增加ColorGroup.Razor.css，只是觉得作为封装组件现有样式够看了，增加m-color-group class 只是为了外部使用时方便css样式重写，并没有做任何定义。 更多隔离样式内容参考官方文档. 自定义插槽目前为止，自定义的ColorGroup组件可以说已经够看了，但是不够打。因为形式单一，如果要在颜色选择按钮后增加文本或者图片怎么办？这就又引入另外一个概念：插槽。插槽（Slot）为vue中的叫法，Vuetify组件提供了大量的插槽如文本输入框内的前后插槽和输入框外的前后插槽（默认为Icon），MASA Blazor 同样实现了插槽的功能，这也使得我们更容易定义和扩展自己的组件。 Blazor面向C#开发者更愿意称之为Template或者Content，通过RenderFragment实现插槽的效果。若你的组件需要定义子元素，为了捕获子内容，需要定义一个名为ChildContent类型为RenderFragment 的组件参数。 ColorGroup.Razor.cs文件中增加RenderFragment属性来定义每项末尾追加的插槽，并定义string参数，接收当前的颜色值。 12[Parameter]public RenderFragment&lt;string&gt;? ItemAppendContent { get; set; } RenderFragment定义带参数组件，使用时默认通过context获取参数值。更多内容参考官方文档 ColorGroup.Razor文件中定义插槽位置 123456789101112&lt;MItem&gt; &lt;MCard Class=&quot;elevation-0&quot; Style=&quot;@($&quot;transition: opacity .4s ease-in-out; {(context.Active ? &quot;&quot; : &quot;opacity: 0.5;&quot;)}&quot;)&quot;&gt; &lt;MButton Fab class=&quot;mx-1 rounded-circle&quot; OnClick=&quot;()=&gt;{ context.Toggle();ValueChanged.InvokeAsync(color); }&quot; Width=Size Height=Size MinWidth=Size MinHeight=Size Color=&quot;@color&quot;&gt; &lt;/MButton&gt; &lt;/MCard&gt; @if (ItemAppendContent is not null) { &lt;div class=&quot;m-color-item-append d-flex align-center mr-1&quot;&gt; @ItemAppendContent(color) &lt;/div&gt; }&lt;/MItem&gt; 最终的效果如下： 组件优化最后为组件在保证功能和美观的同时也要保证性能,以下只是列举了一些笔者认为比较常规的优化方式。 减少组件重新渲染合理重写ShouldRender方法，避免成本高昂的重新呈现。贴一下官网代码自行体会，即一定条件都符合时才重新渲染： 12345678910111213141516171819202122@code { private int prevInboundFlightId = 0; private int prevOutboundFlightId = 0; private bool shouldRender; [Parameter] public FlightInfo? InboundFlight { get; set; } [Parameter] public FlightInfo? OutboundFlight { get; set; } protected override void OnParametersSet() { shouldRender = InboundFlight?.FlightId != prevInboundFlightId || OutboundFlight?.FlightId != prevOutboundFlightId; prevInboundFlightId = InboundFlight?.FlightId ?? 0; prevOutboundFlightId = OutboundFlight?.FlightId ?? 0; } protected override bool ShouldRender() =&gt; shouldRender;} 减少不必要的StateHasChanged方法调用，默认情况下，组件继承自 ComponentBase，会在调用组件的事件处理程序后自动调用StateHasChanged，对于某些事件处理程序可能不会修改组件状态的情况，应用程序可以利用 IHandleEvent 接口来控制 Blazor 事件处理的行为。示例代码见官方文档。 合理重写组件生命周期方法首先要理解组件生命周期，特别是OnInitialized（组件接收 SetParametersAsync 中的初始参数后调用）、OnParametersSet（接收到参数变更时调用）、OnAfterRender（组件完成呈现后调用）。以上方法每个都会执行两次及以上(render-mode=”ServerPrerendered”)。组件初始化的逻辑合理的分配到各个生命周期方法内，最常见的就是OnAfterRender方法内,firstRender为true时调用js或者加载数据： 12345678protected override async Task OnAfterRenderAsync(bool firstRender){ if (firstRender) { await JS.InvokeVoidAsync( &quot;setElementText1&quot;, divElement, &quot;Text after render&quot;); }} OnInitialized生命周期： 在静态预呈现组件时执行一次。 在建立服务器连接后执行一次。避免双重呈现行为，应传递一个标识符以在预呈现期间缓存状态并在预呈现后检索状态。 定义可重用的 RenderFragment将重复的呈现逻辑定义为RenderFragment，无需每个组件开销即可重复使用呈现逻辑。缺点就是重用RenderFragment缺少组件边界，无法单独刷新。 1234567891011121314&lt;h1&gt;Hello, world!&lt;/h1&gt;@RenderWelcomeInfo&lt;p&gt;Render the welcome info a second time:&lt;/p&gt;@RenderWelcomeInfo@code { private RenderFragment RenderWelcomeInfo = __builder =&gt; { &lt;p&gt;Welcome to your new app!&lt;/p&gt; };} 避免为重复的元素重新创建委托Blazor 中过多重复的创建 lambda 表达式委托可能会导致性能不佳，如对一个按钮组每个按钮的OnClick分配一个委托。可以将表达式委托改为Action减少分配开销。 实现IDisposable 或 IAsyncDisposable接口组件实现IDisposable 或 IAsyncDisposable接口，会在组件从UI中被删除时释放非托管资源，事件注销操作等。 组件不需要同时实现 IDisposable 和 IAsyncDisposable。 如果两者均已实现，则框架仅执行异步重载。 更多内容参考：https://docs.microsoft.com/zh-cn/aspnet/core/blazor/performance?view=aspnetcore-6.0#define-reusable-renderfragments-in-code 总结这里只演示了一个ColorGroup很简单的例子，当然你也可以把这个组件做的足够“复杂”,其实组件的封装并没有想象的那么复杂，无外乎上面提到的四个要素：界面、参数、样式、插槽。既然有些组件官方不提供，只能自己动手丰衣足食（当然还是希望官方提供更多标准组件之外的扩展组件）。 示例项目地址，更多内容参考Masa Blazor 预置组件 实现。","link":"/2022/03/30/masa/framework/masa-blazor/6.Masa%20Blazor%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/"},{"title":"1. 一行代码让你的项目轻松使用Dapr","text":"介绍Dapr简化了云原生开发，让开发可以把焦点放在应用的业务逻辑上，从而让代码简单、可移植，那作为一个.Net开发者，我们也希望项目可以快速用上dapr，那究竟应该如何做呢？ Dapr提出了Sidecar(边车)的概念，在启动项目时再额外启动一个Sidecar, 通过Sidecar可以解决进程间通信，为此官方提供了两种部署方式： 自托管方式下运行Dapr 在 Kubernetes 模式中部署和运行 Dapr 其中Kubernetes模式部署是通过Kubernetes来完成的，在开发中我们更多的是通过自托管模式使用Dapr，那自托管模式是怎么做的呢？ 使用命令行工具，在项目根目录输入： 1dapr run --app-id assignment-server --app-port 5038 dotnet run 详细文档参考：手把手教你学Dapr - 3. 使用Dapr运行第一个.Net程序 参考以上详细文档操作后，我们就可以在命令行工具中执行dapr invoke --app-id assignment-server --method hello或者Http请求来调用对应的应用的方法 看似好像也不是很复杂，但如果你需要调试dotnet项目呢？再复杂一点的需要启动多个项目进行调试呢？端口一多起来的确会显得很麻烦。 有没有什么办法可以解决呢？有，docker-compose。 但我还不想用这么重的东西，我想像平时开发项目一样直接在windows上运行可不可以？ Masa.Contrib.Development.DaprStarter.AspNetCore 它来了协助管理dapr进程，用于开发时减少对docker compose的依赖 瞌睡了就有人送枕头，一句话让我们了解到了它的作用，正好解决了我们需要通过命令行来启动dapr的问题，那下面我们看看这个怎么用： 入门本着绝对不多写一行代码的心态，我们准备出发了…… 从大佬doddgu的博客的链接中发现一份源码地址，为防止后期文档调整，先fork一份到自己仓库 1git clone https://github.com/zhenlei520/dapr-study-room.git 使用命令行工具打开目录dapr-study-room\\Assignment03，然后执行命令 1dotnet add package Masa.Contrib.Development.DaprStarter.AspNetCore --version 0.7.0-preview.12 或使用Visual Studio打开解决方案Assignment03，选中Assignment.Server并安装Masa.Contrib.Development.DaprStarter.AspNetCore 打开Program.cs，并添加DaprStarter（注意看有注释的那一行） 123456789using Masa.Contrib.Development.DaprStarter.AspNetCore;var builder = WebApplication.CreateBuilder(args);builder.Services.AddDaprStarter();//添加DaprStarter即可var app = builder.Build();app.Map(&quot;/hello&quot;, () =&gt; Console.WriteLine(&quot;Hello World!&quot;));app.Run(); 使用命令行工具执行命令验证dapr是否启动成功 1dapr invoke --app-id Assignment-Server-00D861D0C0B7 --method hello 此时会有小伙伴问了，为什么app-id是Assignment-Server-00D861D0C0B7？ 查看文档后发现Masa.Contrib.Development.DaprStarter.AspNetCore的app-id生成规则为：AppId + AppIdDelimiter + AppIdSuffix，其中 AppId默认：项目名.Replace(“.”,”-“) AppIdSuffix默认：网卡地址 由于我们的项目名为Assignment.Server，当前电脑的网卡地址是00D861D0C0B7，所以dapr最终的appid为Assignment-Server-00D861D0C0B7，到这里，Masa.Contrib.Development.DaprStarter.AspNetCore的使用讲解已经完成了 冷知识，为什么 . 要换成 - ？ 因为Dapr的AppId采用FQDN：(Fully Qualified Domain Name)全限定域名：同时带有主机名和域名的名称。（通过符号“.”） 为什么要加网卡地址作为后缀？ 因为目前自托管默认采用mDNS，会导致局域网内用户的AppId互相污染。你的同事和你一起在开发，都启动了A应用，你俩就自动负载了，那后果自然就是请求也到处跑了。 进阶如果我希望自己指定AppId而不是使用默认的规则怎么办呢？目前支持三种写法: 根据规则（配置默认装配） 根据规则 + 代码指定（配置自定义装配） 根据配置文件（根据IConfiguration配置生成） 配置默认装配（也是上面介绍的一行代码的方式）修改Program.cs文件 12// 省略上述代码builder.Services.AddDaprStarter(); 根据规则 + 代码指定（配置自定义装配）修改Program.cs文件 123456789// 省略上述代码builder.Services.AddDaprStarter(opt =&gt;{ opt.AppId = &quot;masa-dapr-test&quot;; opt.AppPort = 5001; opt.AppIdSuffix = &quot;&quot;; opt.DaprHttpPort = 8080; opt.DaprGrpcPort = 8081;}); 基于默认装配的升级版，在默认装配基础上通过指定特殊参数完成特殊需求，未配置的参数将使用默认值 根据IConfiguration配置生成 修改appsettings.json 123456789{ &quot;DaprOptions&quot;: { &quot;AppId&quot;: &quot;masa-dapr-test&quot;, &quot;AppPort&quot;: 5001, &quot;AppIdSuffix&quot;: &quot;&quot;, &quot;DaprHttpPort&quot;: 8080, &quot;DaprGrpcPort&quot;: 8081 }} 修改Program.cs 1builder.Services.AddDaprStarter(builder.Configuration.GetSection(&quot;DaprOptions&quot;)); 优势：更改appsettings.json配置后，dapr sidecar会自动更新，项目无需重启 Masa.Contrib.Development.DaprStarter.AspNetCore的设计思路设计思路基于两个方面，其一本机自动启动dapr sidecar还可以正常调试.Net项目，其二简化配置 技术选型我们有两种启动dapr sidecar的方式： dapr run daprd 两者之间的差别如下所示： 完整的对比可查看：https://docs.dapr.io/reference/arguments-annotations-overview/ 通过对比我们发现，我们的目标使用daprd与Dapr CLI都可以实现，那为什么Masa.Contrib.Development.DaprStarter选择的是Dapr CLI，而不是daprd呢？ 核心的原因是dapr可以通过dapr list命令很简单的就获取到当前运行的所有dapr程序，而daprd无法获取。如果使用daprd，那我们就需要使用C#代码通过操作dll获取具体执行的dapr命令，且多平台支持不好，所以暂时用了Dapr CLI 更优秀的Dapr管理需要做到什么？ 使用简单 参数可配置 功能支持选择性启动 Dapr保活 配置支持动态更新 为了能更方便的使用，我们做了以下约定： 针对dapr的非必填项，默认关闭不启用，手动配置参数后开启 针对dapr的必填项: app-id、app-port、dapr-http-port、dapr-grpc-port 自动生成并配置 app-id 生成规则其中dapr的app-id默认生成规则为：AppId + AppIdDelimiter + AppIdSuffix，其中 AppId默认：项目名.Replace(“.”,”-“) AppIdDelimiter默认：- AppIdSuffix默认：当前机器网卡地址 当AppIdSuffix赋值为空字符串，dapr的AppId的生成规则为：AppId app-port 获取1234567891011121314private ushort GetAppPort(DaprOptions options){ var server = _serviceProvider.GetRequiredService&lt;IServer&gt;(); var addresses = server.Features.Get&lt;IServerAddressesFeature&gt;()?.Addresses; if (addresses is { IsReadOnly: false, Count: 0 }) throw new Exception(&quot;Failed to get the startup port, please specify the port manually&quot;); return addresses! .Select(address =&gt; new Uri(address)) .Where(address =&gt; (options.EnableSsl is true &amp;&amp; address.Scheme.Equals(Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase)) || address.Scheme.Equals(Uri.UriSchemeHttp, StringComparison.OrdinalIgnoreCase)) .Select(address =&gt; (ushort)address.Port).FirstOrDefault();} 为了防止启动过程中修改端口，过早的获取到被弃用的端口。因此我们使用后台任务启动dapr sidecar dapr-http-port、dapr-grpc-port获取因为支持用户配置，所以我们遵循下面的顺序 如果指定端口，被占用则自动kill port所在进程，保证可以sidecar可以正常启动 为什么端口占用就要先kill，复用不行吗？ 因为sidecar有初始化配置，程序调整的代码影响到sidecar配置变更我们无法检测，所以启动时保证是最新的是比较合适的选择 如果未指定端口，则交还给dapr，通过Dapr CLI的规则生成对应的http-port或grpc-port Dapr保活为了保证dapr进程是活跃的，我们在库中建立了一个心跳检查任务用来检测当前的dapr进程是否是活跃的，当dapr进程意外停止后会被重启，且配置信息与上一次成功的dapr配置保持不变 如果不需要保活机制的话可以将EnableHeartBeat改为false，则不启用dapr保活机制 配置支持动态更新我们通过IOptionsMonitor的OnChange方法来监听配置的变更，当配置变更后我们会通过IDaprProcess 提供的Refresh方法来重启dapr进程，并重新调整环境变量信息 本章源码Assignment03 https://github.com/zhenlei520/dapr-study-room 开源地址MASA.Framework：https://github.com/masastack/MASA.Framework MASA.EShop：https://github.com/masalabs/MASA.EShop MASA.Blazor：https://github.com/BlazorComponent/MASA.Blazor 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们","link":"/2022/04/17/masa/framework/practice/1.%20%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E8%AE%A9%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%E8%BD%BB%E6%9D%BE%E4%BD%BF%E7%94%A8Dapr/"},{"title":"10. 雪花id","text":"前言雪花算法是Twitter开源的分布式ID生成算法，雪花算法生成后是一个64bit大小的整数（long型），它的优势： 高性能: 每秒可生成数百万的id 生成的id是唯一的，不会重复 id是有顺序的 快速入门 安装.Net 6.0 单机版雪花id 新建ASP.NET Core 空项目Assignment.SnowflakeId，并安装Masa.Contrib.Data.IdGenerator.Snowflake（单机版的雪花id） 123dotnet new web -o Assignment.SnowflakeIdcd Assignment.SnowflakeIddotnet add package Masa.Contrib.Data.IdGenerator.Snowflake --version 0.5.0-preview.5 修改类Program，注册单机版雪花id 12345builder.Services.AddSnowflake(options =&gt;{ // options.TimestampType = TimestampType.Seconds;//时间戳使用秒 // options.EnableMachineClock = true;//启用时钟锁}); 如何生成雪花id？修改类Program 1234567//通过di获取ISnowflakeGenerator创建idapp.MapGet(&quot;/id/generator/ioc&quot;, (ISnowflakeGenerator snowflakeGenerator) =&gt; snowflakeGenerator.Create());//通过静态字段获取ISnowflakeGenerator生成雪花idapp.MapGet(&quot;/id/generator&quot;, () =&gt; IdGeneratorFactory.SnowflakeGenerator.Create()); 分布式版本雪花id 新建ASP.NET Core 空项目Assignment.DistributedSnowflakeId，并安装Masa.Contrib.Data.IdGenerator.Snowflake.Distributed.Redis（分布式雪花id） 123dotnet new web -o Assignment.DistributedSnowflakeIdcd Assignment.DistributedSnowflakeIddotnet add package Masa.Contrib.Data.IdGenerator.Snowflake.Distributed.Redis --version 0.5.0-preview.5 修改类Program 1234567891011121314//使用Redis，如果有使用MasaRedis，可省略builder.Services.AddMasaRedisCache(option =&gt;{ option.Servers = new List&lt;RedisServerOptions&gt;() { new(&quot;localhost&quot;, 6379) }; option.DefaultDatabase = 2; option.Password = &quot;&quot;;});builder.Services.AddSnowflake(option =&gt; { //通过Redis实现分布式雪花id option.UseRedis();}); 修改类Program，新增生成雪花id的服务 12345app.MapGet(&quot;/id/generator/ioc&quot;, (ISnowflakeGenerator snowflakeGenerator) =&gt; snowflakeGenerator.NewId()); //生成idapp.MapGet(&quot;/id/generator&quot;, () =&gt; IdGeneratorFactory.SnowflakeGenerator.NewId()); //生成id 生成雪花id不区分单机版雪花id、分布式雪花id 进阶雪花id的结构图如下： 固定位: 1位, 不需要更改。二进制中最高位为1的都是负数，但是我们生成的id一般都使用整数，所以这个最高位固定是0 时间戳： 41位: 毫秒，可使用0 至 ((2 ^ 41) - 1)的值（默认值） 32位: 秒（并发量低可以使用），可使用0 至 ((2 ^ 32) - 1)的值 工作机器id: 10位：默认值，可使用0 至 ((2 ^ 10) - 1)的值，支持1024个机器id 序列号: 12位：默认值，可使用0 至 ((2 ^ 12) - 1)的值，同一时间节点下同一个工作机器最多生成4096个id 雪花id最多为64位，固定位数不变，确保: 时间戳位数 + 工作机器id位数 + 序列号位数 &lt;= 63 即可 Masa.Contrib.Data.IdGenerator.Snowflake 默认实现的雪花id属于单机版的雪花id，默认工作机器为10位，序列号为12位，时间戳为41位，其中工作机器id默认获取的是环境WORKER_ID变量的值，如果未配置环境WORKER_ID变量的值，则WorkerId的值为0。 有哪些缺点及如何解决？ 不支持k8s（k8s多Pod共享同一个环境环境，会导致获取到同一个WorkerId，高并发场景下，可能生成重复id） 可以使用Masa.Contrib.Data.IdGenerator.Snowflake.Distributed.Redis, 其借助Redis做到了WorkerId的分配，可以确保WorkerId不会重复 自定义实现IWorkerProvider，并在AddSnowflake之前提前将新的WorkerProvider注册到服务集合中（其生命周期为单例） 时钟回拨（时钟回拨会导致重复id出现） 使用可靠的NTP服务器，确保时钟的稳定性 关闭NTP同步 启用时钟锁 (options.EnableMachineClock = true，代码修改，以首次运行获取到的当前时间作为基准，后续不再获取当前时间) 如何定义符合自己业务的雪花id雪花id是一个64bit的整数，其具有很强的灵活性，默认雪花id由固定位 + 时间戳 + 机器id + 序列号生成，但这不是固定的，我们可以更改的除固定位以及时间戳意外的其他组成，而时间戳可以用毫秒也可以用秒，因此机器id + 序列号的位数在22到31位。 机器id的意义在于多副本部署时，副本之间在同一时间点时不会生成相同的id 序列号的意义在于同一个机器、同一个时间点下最多生成的id数，其值是递增的，如果你的业并发很高，在同一机器、时间点的请求超过4096时，则需要将序列号的位数增大，如果并发不高，则可以将序列号的位数降低。 明确自己的业务情况，确定id的组成部分，这样一来我们接下来就可以针对性的做适合我们的雪花id 新建类库IdGenerator.Snowflake，并安装Masa.BuildingBlocks.Data 123dotnet new web -o IdGenerator.Snowflakecd IdGenerator.Snowflakedotnet add package Masa.BuildingBlocks.Data --version 0.5.0-preview.5 新建类SnowflakeIdGenerator, 并实现ISnowflakeGenerator 12345678public class SnowflakeIdGenerator : ISnowflakeGenerator{ public long Create() { //todo: 生成雪花id，具体可参考 https://github.com/masastack/MASA.Contrib/blob/main/src/Data/IdGenerator/Masa.Contrib.Data.IdGenerator.Snowflake/Internal/SnowflakeIdGenerator.cs throw new NotImplementedException(); }} 新建类ServiceCollectionExtensions, 新增AddSnowflake方法扩展服务集合 12345678public static IServiceCollection AddSnowflake(this IServiceCollection services){ services.TryAddSingleton&lt;ISnowflakeGenerator, SnowflakeIdGenerator&gt;(); services.TryAddSingleton&lt;IIdGenerator&lt;System.Snowflake, long&gt;&gt;(serviceProvider =&gt; serviceProvider.GetRequiredService&lt;ISnowflakeGenerator&gt;()); IdGeneratorFactory.SetSnowflakeGenerator(services.BuildServiceProvider().GetRequiredService&lt;ISnowflakeGenerator&gt;());//方便通过 IdGeneratorFactory.SnowflakeGenerator.Create() 获取id return services;} 性能测试通过运行Benchmark查看生成id的性能 TimestampType为1（毫秒） BenchmarkDotNet=v0.13.1, OS=Windows 10.0.19043.1023 (21H1/May2021Update) 11th Gen Intel Core i7-11700 2.50GHz, 1 CPU, 16 logical and 8 physical cores .NET SDK=7.0.100-preview.4.22252.9 [Host] : .NET 6.0.5 (6.0.522.21309), X64 RyuJIT DEBUG Job-JPQDWN : .NET 6.0.5 (6.0.522.21309), X64 RyuJIT Job-BKJUSV : .NET 6.0.5 (6.0.522.21309), X64 RyuJIT Job-UGZQME : .NET 6.0.5 (6.0.522.21309), X64 RyuJIT Runtime=.NET 6.0 RunStrategy=ColdStart Method Job IterationCount Mean Error StdDev Median Min Max SnowflakeByMillisecond Job-JPQDWN 1000 2,096.1 ns 519.98 ns 4,982.3 ns 1,900.0 ns 1,000.0 ns 156,600.0 ns SnowflakeByMillisecond Job-BKJUSV 10000 934.0 ns 58.44 ns 1,775.5 ns 500.0 ns 200.0 ns 161,900.0 ns SnowflakeByMillisecond Job-UGZQME 100000 474.6 ns 5.54 ns 532.8 ns 400.0 ns 200.0 ns 140,500.0 ns TimestampType为2（秒） BenchmarkDotNet=v0.13.1, OS=Windows 10.0.19043.1023 (21H1/May2021Update) 11th Gen Intel Core i7-11700 2.50GHz, 1 CPU, 16 logical and 8 physical cores .NET SDK=7.0.100-preview.4.22252.9 [Host] : .NET 6.0.5 (6.0.522.21309), X64 RyuJIT Job-RVUKKG : .NET 6.0.5 (6.0.522.21309), X64 RyuJIT Job-JAUDMW : .NET 6.0.5 (6.0.522.21309), X64 RyuJIT Job-LOMSTK : .NET 6.0.5 (6.0.522.21309), X64 RyuJIT Runtime=.NET 6.0 RunStrategy=ColdStart Method Job IterationCount Mean Error StdDev Median Min Max SnowflakeBySecond Job-RVUKKG 1000 1.882 us 0.5182 us 4.965 us 1.5000 us 0.9000 us 158.0 us SnowflakeBySecond Job-JAUDMW 10000 11.505 us 35.1131 us 1,066.781 us 0.4000 us 0.3000 us 106,678.8 us SnowflakeBySecond Job-LOMSTK 100000 22.097 us 15.0311 us 1,444.484 us 0.4000 us 0.2000 us 118,139.7 us TimestampType为1（毫秒）、启用时钟锁 BenchmarkDotNet=v0.13.1, OS=Windows 10.0.19043.1023 (21H1/May2021Update) 11th Gen Intel Core i7-11700 2.50GHz, 1 CPU, 16 logical and 8 physical cores .NET SDK=7.0.100-preview.4.22252.9 [Host] : .NET 6.0.5 (6.0.522.21309), X64 RyuJIT Job-BBZSDR : .NET 6.0.5 (6.0.522.21309), X64 RyuJIT Job-NUSWYF : .NET 6.0.5 (6.0.522.21309), X64 RyuJIT Job-FYICRN : .NET 6.0.5 (6.0.522.21309), X64 RyuJIT Runtime=.NET 6.0 RunStrategy=ColdStart Method Job IterationCount Mean Error StdDev Median Min Max MachineClockByMillisecond Job-BBZSDR 1000 1,502.0 ns 498.35 ns 4,775.1 ns 1,100.0 ns 700.0000 ns 151,600.0 ns MachineClockByMillisecond Job-NUSWYF 10000 602.0 ns 54.76 ns 1,663.7 ns 200.0 ns 100.0000 ns 145,400.0 ns MachineClockByMillisecond Job-FYICRN 100000 269.8 ns 5.64 ns 542.4 ns 200.0 ns 0.0000 ns 140,900.0 ns 总结单机版的雪花id与分布式雪花id的区别在于WorkerId，多副本服务获取到的WorkerId不是唯一的，而分布式雪花id的WorkerId是唯一的，目前Masa提供的分布式雪花id是基于Redis实现的，如果有其他的实现可参考IdGenerator.Snowflake.Distributed.Redis实现，如果需要支持数据中心或者服务可参考如何自定义雪花id 本章源码Assignment10 https://github.com/zhenlei520/MasaFramework.Practice 开源地址MASA.BuildingBlocks：https://github.com/masastack/MASA.BuildingBlocks MASA.Contrib：https://github.com/masastack/MASA.Contrib MASA.Utils：https://github.com/masastack/MASA.Utils MASA.EShop：https://github.com/masalabs/MASA.EShop MASA.Blazor：https://github.com/BlazorComponent/MASA.Blazor 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们","link":"/2022/06/17/masa/framework/practice/10.%20%E9%9B%AA%E8%8A%B1id/"},{"title":"11. 事件总线 - 进程内事件总线","text":"概述事件总线是一种事件发布/订阅结构，通过发布订阅模式可以解耦不同架构层级，同样它也可以来解决业务之间的耦合，它有以下优点 松耦合 横切关注点 可测试性 事件驱动 发布订阅模式通过下图我们可以快速了解发布订阅模式的本质 订阅者将自己关心的事件在调度中心进行注册 事件的发布者通过调度中心把事件发布出去 订阅者收到自己关心的事件变更并执行相对应业务 其中发布者无需知道订阅者是谁，订阅者彼此之间也互不认识，彼此之间互不干扰 事件总线类型在Masa Framework中，将事件划分为 进程内事件 (Event) 本地事件，它的发布与订阅需要在同一个进程中，订阅方与发布方需要在同一个项目中 跨进程事件 (IntegrationEvent) 集成事件，它的发布与订阅一定不在同一个进程中，订阅方与发布方可以在同一个项目中，也可以在不同的项目中 下面我们会用一个注册用户的例子来说明如何使用本地事件 入门 安装.NET 6.0 新建ASP.NET Core 空项目Assignment.InProcessEventBus，并安装Masa.Contrib.Dispatcher.Events 123dotnet new web -o Assignment.InProcessEventBuscd Assignment.InProcessEventBusdotnet add package Masa.Contrib.Dispatcher.Events --version 0.7.0-preview.7 注册EventBus (用于发布本地事件), 修改Program.cs 1builder.Services.AddEventBus(); 新增RegisterUserEvent类并继承Event，用于发布注册用户事件 12345678public record RegisterEvent : Event{ public string Account { get; set; } public string Email { get; set; } public string Password { get; set; }} 新增注册用户处理程序 在指定事件处理程序方法上增加特性 EventHandler，并在方法中增加参数 RegisterUserEvent 1234567891011121314151617181920public class UserHandler{ private readonly ILogger&lt;UserHandler&gt;? _logger; public UserHandler(ILogger&lt;UserHandler&gt;? logger = null) { //todo: 根据需要可在构造函数中注入其它服务 (需支持从DI获取) _logger = logger; } [EventHandler] public void RegisterUser(RegisterUserEvent @event) { //todo: 1. 编写注册用户业务 _logger?.LogDebug(&quot;-----------{Message}-----------&quot;, &quot;检测用户是否存在并注册用户&quot;); //todo: 2. 编写发送注册通知等 _logger?.LogDebug(&quot;-----------{Account} 注册成功 {Message}-----------&quot;, @event.Account, &quot;发送邮件提示注册成功&quot;); }} 注册用户的处理程序可以放到任意一个类中，但其构造函数参数必须支持从DI获取，且处理程序的方法仅支持 Task或 Void 两种, 不支持其它类型 发送注册用户事件，修改Program.cs 1234app.MapPost(&quot;/register&quot;, async (RegisterUserEvent @event, IEventBus eventBus) =&gt;{ await eventBus.PublishAsync(@event);}); 进阶处理流程EventBus的 请求管道包含一系列请求委托，依次调用。 它们与ASP.NET Core中间件有异曲同工之妙，区别点在于中间件的执行顺序与注册顺序相反，最先注册的最后执行 每个委托均可在下一个委托前后执行操作，其中TransactionMiddleware是EventBus发布后第一个要进入的中间件 (默认提供)，并且它是不支持多次嵌套的。 EventBus 支持嵌套，这意味着我们可以在Handler中重新发布一个新的Event，但TransactionMiddleware仅会在最外层进入时被触发一次 自定义中间件根据需要我们可以自定义中间件，并注册到EventBus的请求管道中，比如通过增加FluentValidation, 将参数验证从业务代码中剥离开来，从而使得处理程序更专注于业务 注册FluentValidation, 修改Program.cs 1builder.Services.AddValidatorsFromAssembly(Assembly.GetEntryAssembly()); 自定义验证中间件ValidatorMiddleware.cs，用于验证参数 12345678910111213141516171819202122232425262728293031323334353637public class ValidatorMiddleware&lt;TEvent&gt; : Middleware&lt;TEvent&gt; where TEvent : IEvent{ private readonly ILogger&lt;ValidatorMiddleware&lt;TEvent&gt;&gt;? _logger; private readonly IEnumerable&lt;IValidator&lt;TEvent&gt;&gt; _validators; public ValidatorMiddleware(IEnumerable&lt;IValidator&lt;TEvent&gt;&gt; validators, ILogger&lt;ValidatorMiddleware&lt;TEvent&gt;&gt;? logger = null) { _validators = validators; _logger = logger; } public override async Task HandleAsync(TEvent @event, EventHandlerDelegate next) { var typeName = @event.GetType().FullName; _logger?.LogDebug(&quot;----- Validating command {CommandType}&quot;, typeName); var failures = _validators .Select(v =&gt; v.Validate(@event)) .SelectMany(result =&gt; result.Errors) .Where(error =&gt; error != null) .ToList(); if (failures.Any()) { _logger?.LogError(&quot;Validation errors - {CommandType} - Event: {@Command} - Errors: {@ValidationErrors}&quot;, typeName, @event, failures); throw new ValidationException(&quot;Validation exception&quot;, failures); } await next(); }} 注册EventBus并使用验证中间件ValidatorMiddleware 1builder.Services.AddEventBus(eventBusBuilder=&gt;eventBusBuilder.UseMiddleware(typeof(ValidatorMiddleware&lt;&gt;))); 添加注册用户验证类RegisterUserEventValidator.cs 1234567891011121314public class RegisterUserEventValidator : AbstractValidator&lt;RegisterUserEvent&gt;{ public RegisterUserEventValidator() { RuleFor(e =&gt; e.Account).NotNull().WithMessage(&quot;用户名不能为空&quot;); RuleFor(e =&gt; e.Email).NotNull().WithMessage(&quot;邮箱不能为空&quot;); RuleFor(e =&gt; e.Password) .NotNull().WithMessage(&quot;密码不能为空&quot;) .MinimumLength(6) .WithMessage(&quot;密码必须大于6位&quot;) .MaximumLength(20) .WithMessage(&quot;密码必须小于20位&quot;); }} 编排EventBus 支持事件编排，它们可以用来处理一些对执行顺序有要求的业务，比如: 注册用户必须成功之后才可以发送注册邮件通知，发送奖励等等，那我们可以这样做 将注册用户业务拆分为三个Handler，并通过指定Order的值来对执行事件排序 123456789101112131415161718192021222324252627282930public class UserHandler{ private readonly ILogger&lt;UserHandler&gt;? _logger; public UserHandler(ILogger&lt;UserHandler&gt;? logger = null) { _logger = logger; } [EventHandler(1)] public void RegisterUser(RegisterUserEvent @event) { _logger?.LogDebug(&quot;-----------{Message}-----------&quot;, &quot;检测用户是否存在并注册用户&quot;); //todo: 编写注册用户业务 } [EventHandler(2)] public void SendAwardByRegister(RegisterUserEvent @event) { _logger?.LogDebug(&quot;-----------{Account} 注册成功 {Message}-----------&quot;, @event.Account, &quot;发送注册奖励&quot;); //todo: 编写发送奖励等 } [EventHandler(3)] public void SendNoticeByRegister(RegisterUserEvent @event) { _logger?.LogDebug(&quot;-----------{Account} 注册成功 {Message}-----------&quot;, @event.Account, &quot;发送注册成功邮件&quot;); //todo: 编写发送注册通知等 }} SagaEventBus支持Saga模式 具体是怎么做呢？ 12345[EventHandler(1, IsCancel = true)]public void CancelSendAwardByRegister(RegisterUserEvent @event){ _logger?.LogDebug(&quot;-----------{Account} 注册成功，发放奖励失败 {Message}-----------&quot;, @event.Account, &quot;发放奖励补偿&quot;);} 当发送奖励出现异常时，则执行补偿机制，执行顺序为 (2 - 1) &gt; 0，由于目前仅存在一个Order为1的Handler，则执行奖励补偿后退出 但对于部分不需要执行失败但不需要执行回退的方法，我们可以修改 FailureLevels 确保不会因为当前方法的异常而导致执行补偿机制 123456[EventHandler(3, FailureLevels = FailureLevels.Ignore)]public void SendNoticeByRegister(RegisterUserEvent @event){ _logger?.LogDebug(&quot;-----------{Account} 注册成功 {Message}-----------&quot;, @event.Account, &quot;发送邮件提示注册成功&quot;); //todo: 编写发送注册通知等} 源码解读EventHandler FailureLevels: 失败级别, 默认: Throw Throw：发生异常后，依次执行Order小于当前Handler的Order的取消动作，比如：Handler顺序为 1、2、3，CancelHandler为 1、2、3，如果执行 Handler3 异常，则依次执行 2、1 ThrowAndCancel：发生异常后，依次执行Order小于等于当前Handler的Order的取消动作，比如：Handler顺序为 1、2、3，CancelHandler为 1、2、3，如果执行 Handler3 异常，则依次执行 3、2、1 Ignore：发生异常后，忽略当前异常（不执行取消动作），继续执行其他Handler Order: 执行顺序，默认: int.MaxValue，用于控制当前方法的执行顺序 EnableRetry: 当Handler异常后是否启用重试, 默认: false RetryTimes: 重试次数，当出现异常后执行多少次重试, 需开启重试配置 IsCancel: 是否是补偿机制，默认: false Middleware SupportRecursive: 是否支持递归 (嵌套), 默认: true 部分中间件仅在最外层被触发一次，像TransactionMiddleware 就是如此，但也有很多中间件是需要被多次执行的，比如ValidatorMiddleware，每次发布事件时都需要验证参数是否正确 HandleAsync(TEvent @event, EventHandlerDelegate next): 处理程序，通过调用 next() 使得请求进入下一个Handler IEventHandler 与 ISagaEventHandler HandleAsync(TEvent @event): 提供事件的Handler CancelAsync(TEvent @event): 提供事件的补偿Handler 与EventHandler功能类似，提供基本的Handler以及补偿Handler，推荐使用EventHandler的方式使用 TransactionMiddleware提供事务中间件，当EventBus与UoW以及Masa提供的Repository来使用时，当存在待提交的数据时，会自动执行保存并提交，当出现异常后，会执行事务回滚，无需担心脏数据入库 性能测试与市面上使用较多的MeidatR作了对比，结果如下图所示: BenchmarkDotNet=v0.13.1, OS=Windows 10.0.19043.1023 (21H1/May2021Update)11th Gen Intel Core i7-11700 2.50GHz, 1 CPU, 16 logical and 8 physical cores.NET SDK=7.0.100-preview.4.22252.9 [Host] : .NET 6.0.6 (6.0.622.26707), X64 RyuJIT DEBUG Job-MHJZJL : .NET 6.0.6 (6.0.622.26707), X64 RyuJIT Runtime=.NET 6.0 IterationCount=100 RunStrategy=ColdStart Method Mean Error StdDev Median Min Max AddShoppingCartByEventBusAsync 124.80 us 346.93 us 1,022.94 us 8.650 us 6.500 us 10,202.4 us AddShoppingCartByMediatRAsync 110.57 us 306.47 us 903.64 us 7.500 us 5.300 us 9,000.1 us 根据性能测试我们发现，EventBus与MediatR性能差距很小，但EventBus提供的功能却要强大的多 常见问题 按照文档操作，通过EventBus发布事件后，对应的Handler并没有执行，也没有发现错误？ ①. EventBus.PublishAsync(@event) 是异步方法，确保等待方法调用成功，检查是否出现同步方法调用异步方法的情况②. 注册EventBus时指定程序集集合, Assembly被用于注册时获取并保存事件与Handler的对应关系 12345var assemblies = new[]{ typeof(UserHandler).Assembly};builder.Services.AddEventBus(assemblies); 程序集: 手动指定Assembly集合 -&gt; MasaApp.GetAssemblies() -&gt; AppDomain.CurrentDomain.GetAssemblies() 但由于NetCore按需加载，未使用的程序集在当前域中不存在，因此可能会导致部分事件以及Handler的对应关系未正确保存，因此可通过手动指定Assembly集合或者修改全局配置中的Assembly集合来修复这个问题 通过EventBus发布事件，Handler出错，但数据依然保存到数据库中 ①. 检查是否禁用事务 DisableRollbackOnFailure是否为true (是否失败时禁止回滚) UseTransaction是否为false (禁止使用事务) ②. 检查当前数据库是否支持回滚。例如: 使用的是Mysql数据库，但回滚数据失败，请查看 本章源码Assignment11 https://github.com/zhenlei520/MasaFramework.Practice 开源地址MASA.Framework：https://github.com/masastack/MASA.Framework MASA.EShop：https://github.com/masalabs/MASA.EShop MASA.Blazor：https://github.com/BlazorComponent/MASA.Blazor 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们","link":"/2022/11/10/masa/framework/practice/11.%20%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF%20-%20%E8%BF%9B%E7%A8%8B%E5%86%85%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/"},{"title":"12. 事件总线 - 跨进程事件总线","text":"概述跨进程事件总线允许发布和订阅跨服务传输的消息, 服务的发布与订阅不在同一个进程中 在Masa Framework中, 跨进程总线事件提供了一个可以被开箱即用的程序 IntegrationEvents: 提供了发件箱模式 IntegrationEvents.Dapr: 借助Dapr实现了消息的发布 EventLogs.EFCore: 基于EFCore实现的集成事件日志的提供者, 提供消息的记录与状态更新、失败日志重试、删除过期的日志记录等 入门跨进程事件与Dapr并不是强绑定的, Masa Framework使用了Dapr提供的pub/sub的能力, 如果你不想使用它, 你也可以更换为其它实现, 但目前Masa Framwork中仅提供了Dapr的实现 安装 .NET 6.0 安装 Dapr 新建ASP.NET Core 空项目Assignment.IntegrationEventBus，并安装Masa.Contrib.Dispatcher.IntegrationEvents.Dapr、Masa.Contrib.Dispatcher.IntegrationEvents.EventLogs.EFCore、Masa.Contrib.Data.EFCore.Sqlite、Masa.Contrib.Data.UoW.EFCore、Masa.Contrib.Development.DaprStarter.AspNetCore、Microsoft.EntityFrameworkCore.Design 123456789dotnet new web -o Assignment.IntegrationEventBuscd Assignment.IntegrationEventBusdotnet add package Masa.Contrib.Dispatcher.IntegrationEvents.Dapr --version 0.7.0-preview.8 // 使用dapr提供的pubsub能力dotnet add package Masa.Contrib.Dispatcher.IntegrationEvents.EventLogs.EFCore --version 0.7.0-preview.8 //本地消息表dotnet add package Masa.Contrib.Data.EFCore.Sqlite --version 0.7.0-preview.8 //使用EfCore.Sqlitedotnet add package Masa.Contrib.Data.UoW.EFCore --version 0.7.0-preview.8 //使用工作单元dotnet add package Masa.Contrib.Development.DaprStarter.AspNetCore --version 0.7.0-preview.8 //开发环境使用DaprStarter协助管理Dapr Sidecardotnet add package Microsoft.EntityFrameworkCore.Design --version 6.0.6 //方便后续通过CodeFirst迁移数据库 新建用户上下文类UserDbContext，并继承MasaDbContext 123456public class UserDbContext : MasaDbContext{ public UserDbContext(MasaDbContextOptions&lt;UserDbContext&gt; options) : base(options) { }} 注册DaprStarter, 协助管理Dapr Sidecar, 修改Program.cs 1234if (builder.Environment.IsDevelopment()){ builder.Services.AddDaprStarter();} 通过Dapr发布集成事件需要运行Dapr, 线上环境可通过Kubernetes来运行, 开发环境可借助Dapr Starter运行Dapr, 因此仅需要在开发环境使用它 注册跨进程事件总线，修改类Program 1234567891011121314151617builder.Services.AddIntegrationEventBus(option =&gt;{ option.UseDapr() .UseEventLog&lt;UserDbContext&gt;() .UseUoW&lt;UserDbContext&gt;(optionBuilder =&gt; optionBuilder.UseSqlite($&quot;Data Source=./Db/{Guid.NewGuid():N}.db;&quot;));});var app = builder.Build();#region dapr 订阅集成事件使用app.UseRouting();app.UseCloudEvents();app.UseEndpoints(endpoints =&gt;{ endpoints.MapSubscribeHandler();});#endregion 新增用户注册事件的集成事件 RegisterUserEvent 12345678public record RegisterUserEvent : IntegrationEvent{ public override string Topic { get; set; } = nameof(RegisterUserEvent); public string Account { get; set; } public string Mobile { get; set; }} 打开Assignment.IntegrationEventBus所在文件夹，打开cmd或Powershell执行 12dotnet ef migrations add init //创建迁移dotnet ef database update //更新数据库 发送跨进程事件，修改Program 123456789app.MapPost(&quot;/register&quot;, async (IIntegrationEventBus eventBus) =&gt;{ //todo: 模拟注册用户并发布注册用户事件 await eventBus.PublishAsync(new RegisterUserEvent() { Account = &quot;Tom&quot;, Mobile = &quot;19999999999&quot; });}); 订阅事件，修改Program 1234app.MapPost(&quot;/IntegrationEvent/RegisterUser&quot;, [Topic(&quot;pubsub&quot;, nameof(RegisterUserEvent))](RegisterUserEvent @event) =&gt;{ Console.WriteLine($&quot;注册用户成功: {@event.Account}&quot;);}); 订阅事件暂时未抽象，目前使用的是Dapr原生的订阅方式，后续我们会支持Bind，届时不会由于更换pubsub的实现而导致订阅方式的改变 尽管跨进程事件目前仅支持了Dapr，但这不代表你与RabbitMq、Kafka等无缘，发布/订阅是Dapr抽象出的能力，实现发布订阅的组件有很多种，RabbitMq、Kafka是其中一种实现，如果你想深入了解他们之间的关系，可以参考: 手把手教你学Dapr PubSub代理 源码解读首先我们先要知道的基础知识点: IIntegrationEvent: 集成事件接口, 继承 IEvent (本地事件接口)、ITopic (订阅接口, 发布订阅的主题)、ITransaction (事务接口) IIntegrationEventBus: 集成事件总线接口、用于提供发送集成事件的功能 IIntegrationEventLogService: 集成事件日志服务的接口 (提供保存本地日志、修改状态为进行中、成功、失败、删除过期日志、获取等待重试日志列表的功能) IntegrationEventLog: 集成事件日志, 提供本地消息表的模型 IHasConcurrencyStamp: 并发标记接口 (实现此接口的类会自动为RowVersion赋值) Masa.Contrib.Dispatcher.IntegrationEvents提供了集成事件接口的实现类, 并支持了发件箱模式, 其中: IPublisher: 集成事件的发送者 IProcessingServer: 后台服务接口 IProcessor: 处理程序接口 (后台处理程序中会获取所有的程序程序) DeleteLocalQueueExpiresProcessor: 删除过期程序 (从本地队列删除) DeletePublishedExpireEventProcessor: 删除已过期的发布成功的本地消息程序 (从Db删除) RetryByLocalQueueProcessor: 重试本地消息记录 (从本地队列中获取, 条件: 发送状态为失败或进行中且重试次数小于最大重试次数且重试间隔大于最小重试间隔) RetryByDataProcessor: 重试本地消息记录 (从Db获取, 条件: 发送状态为失败或进行中且重试次数小于最大重试次数且重试间隔大于最小重试间隔, 且不在本地重试队列中) IntegrationEventBus: IIntegrationEvent的实现 在Masa.Contrib.Dispatcher.IntegrationEvents中仅提供了发件箱的功能, 但集成事件的发布是由 IPublisher的实现类来提供, 由Db获取本地消息表的功能是由IIntegrationEventLogService的实现类来提供, 它们分别属于Masa.Contrib.Dispatcher.IntegrationEvents.Dapr、Masa.Contrib.Dispatcher.IntegrationEvents.EventLogs.EFCore的功能, 这也是为什么使用集成事件需要引用包 Masa.Contrib.Dispatcher.IntegrationEvents Masa.Contrib.Dispatcher.IntegrationEvents.Dapr Masa.Contrib.Dispatcher.IntegrationEvents.EventLogs.EFCore 如何快速接入其它实现那会有小伙伴问了, 我现在没有使用Dapr, 未来一段时间暂时也还不希望接入Dapr, 我想自己接入, 以实现集成事件的发布可以吗? 当然是可以的, 如果你希望自行实现集成事件, 那么这个时候你会遇到两种情况 接入方支持发件箱模式以社区用的较多的库CAP为例, 由于它本身已经完成了发件箱模式, 我们不需要再处理本地消息表, 也无需考虑本地消息记录的管理, 那我们可以这样做 新建类库Masa.Contrib.Dispatcher.IntegrationEvents.Cap, 添加Masa.BuildingBlocks.Dispatcher.IntegrationEvents的引用, 并安装DotNetCore.CAP 1dotnet add package DotNetCore.CAP 新增类IntegrationEventBus, 并实现IIntegrationEventBus 123456789101112131415161718192021222324252627282930public class IntegrationEventBus : IIntegrationEventBus{ private readonly ICapPublisher _publisher; private readonly ICapTransaction _capTransaction; private readonly IUnitOfWork? _unitOfWork; public IntegrationEventBus(ICapPublisher publisher, ICapTransaction capTransaction, IUnitOfWork? unitOfWork = null) { _publisher = publisher; _capTransaction = capTransaction; _unitOfWork = unitOfWork; } public Task PublishAsync&lt;TEvent&gt;(TEvent @event) where TEvent : IEvent { // 如果使用事务 // _publisher.Transaction.Value.DbTransaction = unitOfWork.Transaction; // _publisher.Publish(@event.Topic, @event); throw new NotImplementedException(); } public IEnumerable&lt;Type&gt; GetAllEventTypes() { throw new NotImplementedException(); } public Task CommitAsync(CancellationToken cancellationToken = default) { throw new NotImplementedException(); }} CAP已支持本地事务, 使用当前IUnitOfWork提供的事务, 确保数据的原子性 新建类ServiceCollectionExtensions, 将自定义Publisher注册到服务集合 123456789public static class ServiceCollectionExtensions{ public static DispatcherOptions UseRabbitMq(this IServiceCollection services) { //todo: 注册RabbitMq信息 services.TryAddScoped&lt;IIntegrationEventBus, IntegrationEventBus&gt;(); return dispatcherOptions; }} 已经实现发件箱模式的可以直接使用, 而不需要引用 Masa.Contrib.Dispatcher.IntegrationEvents Masa.Contrib.Dispatcher.IntegrationEvents.Dapr Masa.Contrib.Dispatcher.IntegrationEvents.EventLogs.EFCore 以上未经过实际验证, 感兴趣的可以尝试下, 欢迎随时提pr 接入方不支持发件箱模式我希望直接接入RabbitMq, 但我自己没有做发件箱模式, 那我可以怎么做呢？ 由于Masa.Contrib.Dispatcher.IntegrationEvents已提供发件箱模式, 如果仅仅希望更换一个发布事件的实现者, 那我们仅需要实现IPublisher即可 新建类库Masa.Contrib.Dispatcher.IntegrationEvents.RabbitMq, 添加Masa.Contrib.Dispatcher.IntegrationEvents项目引用, 并安装RabbitMQ.Client 1dotnet add package RabbitMQ.Client //使用RabbitMq 新增类Publisher，并实现IPublisher 12345678public class Publisher : IPublisher{ public async Task PublishAsync&lt;T&gt;(string topicName, T @event, CancellationToken stoppingToken = default) where T : IIntegrationEvent { //todo: 通过 RabbitMQ.Client 发送消息到RabbitMq throw new NotImplementedException(); }} 新建类DispatcherOptionsExtensions, 将自定义Publisher注册到服务集合 123456789public static class DispatcherOptionsExtensions{ public static DispatcherOptions UseRabbitMq(this Masa.Contrib.Dispatcher.IntegrationEvents.Options.DispatcherOptions options) { //todo: 注册RabbitMq信息 dispatcherOptions.Services.TryAddSingleton&lt;IPublisher, Publisher&gt;(); return dispatcherOptions; }} 如何使用自定义实现RabbitMq 123456builder.Services.AddIntegrationEventBus(option =&gt;{ option.UseRabbitMq();//修改为使用RabbitMq option.UseUoW&lt;UserDbContext&gt;(optionBuilder =&gt; optionBuilder.UseSqlite($&quot;Data Source=./Db/{Guid.NewGuid():N}.db;&quot;)); option.UseEventLog&lt;UserDbContext&gt;();}); 本章源码Assignment12 https://github.com/zhenlei520/MasaFramework.Practice 开源地址MASA.Framework：https://github.com/masastack/MASA.Framework MASA.EShop：https://github.com/masalabs/MASA.EShop MASA.Blazor：https://github.com/BlazorComponent/MASA.Blazor 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们","link":"/2022/11/18/masa/framework/practice/12.%20%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF%20-%20%E8%B7%A8%E8%BF%9B%E7%A8%8B%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF/"},{"title":"13. MasaFramework -- 异常处理","text":"前言在程序设计中，我们会遇到各种各样的异常问题，一个异常处理不仅仅可以帮助开发者快速的定位问题，也可以给用户更好的使用体验，那么我们在AspNetCore项目中如何捕获以及处理异常呢？ 而对应AspNetCore程序，我们有两种异常处理方案，它们分别是： 异常中间件 异常过滤器 介绍MASA Framework作为一个框架，它为开发者以及用户提供更好的开发体验和使用体验的异常处理功能 Masa.Utils.Exceptions 中定义了两种异常类 UserFriendlyException(友好异常) MasaException(框架异常) 并提供了两种异常处理方案，那接下来就让我们看看它们是如何使用的 异常中间件 异常过滤器 根据需要自行选择一种方案使用即可 快速入门项目基于.NET 6.0创建，必须安装所必须的环境 安装.NET 6.0 异常中间件基于中间件实现的全局异常处理，用于捕捉应用程序异常，并将异常信息处理后返回 新建ASP.NET Core 空项目Assignment.GlobalExceptionDemo，并安装Masa.Utils.Exceptions 1234dotnet new web -o Assignment.GlobalExceptionDemocd Assignment.GlobalExceptionDemodotnet add package Masa.Utils.Exceptions --version 0.6.0-rc.3 //提供全局异常过滤器 新建用户类User 123456public class User{ public string Name { get; set; } public int Age { get; set; }} 使用全局异常，修改Program 123456789101112//支持处理自定义异常app.UseMasaExceptionHandler(options =&gt;{ //支持处理自定义异常 options.ExceptionHandler = context =&gt; { if (context.Exception is ArgumentNullException ex) { context.ToResult($&quot;{ex.ParamName}不能为空&quot;); } };}); 新增注册用户方法（用于自定义抛出异常） 123456app.MapPost(&quot;/register&quot;, (User user) =&gt;{ if (string.IsNullOrEmpty(user.Name)) throw new ArgumentNullException(nameof(user.Name)); //todo: Impersonate a registered user}); 更多使用技巧可查看 异常过滤器基于MVC的全局异常过滤器，用于捕捉应用程序异常，并将异常信息处理后返回 新建ASP.NET Core 空项目Assignment.GlobalFilterDemo，并安装Masa.Utils.Exceptions 1234dotnet new web -o Assignment.GlobalFilterDemocd Assignment.GlobalFilterDemodotnet add package Masa.Utils.Exceptions --version 0.6.0-rc.3 //提供全局异常过滤器 新建用户类User 123456public class User{ public string Name { get; set; } public int Age { get; set; }} 使用全局异常过滤器，修改Program 1234567891011121314builder.Services .AddMvc() //使用MasaException .AddMasaExceptionHandler(options =&gt; { options.ExceptionHandler = context =&gt; { if (context.Exception is ValidationException ex) { string message = ex.Errors.Select(error =&gt; error.ErrorMessage).FirstOrDefault()!; context.ToResult(message); } }; }); 新增注册用户方法，用于自定义抛出异常 12345678910111213[ApiController][Route(&quot;[Action]&quot;)]public class UserController : ControllerBase{ [HttpPost] public void Register(User user) { if (string.IsNullOrEmpty(user.Name)) throw new ArgumentNullException(nameof(user.Name)); //todo: Impersonate a registered user }} 验证全局异常处理分别启用使用异常中间件的项目以及异常过滤器的项目，用Postman或者通过Swagger分别请求两个项目的注册用户接口，其中Name为空，可得到以下提示，则代表全局异常处理成功 进阶不论是通过中间件还是过滤器来处理全局异常，我们都支持自定义异常处理，我们首先来看一下异常的处理流程 根据流程图可以直观的了解到，只要使用了Masa提供的异常处理，哪怕我们不自定义异常，框架也会帮助我们按照无自定义异常流程默认处理异常信息，但如果我们希望对特定的异常做出特定的响应，那么就需要我们自定义异常 自定义异常自定义异常支持三种方式 以中间件为例： 方案一. 通过配置ExceptionHandler（异常处理），修改Program.cs 1234567891011app.UseMasaExceptionHandler(options =&gt;{ options.ExceptionHandler = context =&gt; { // 根据context.Exception判断异常类型，并通过context.ToResult()输出响应内容 if (context.Exception is ArgumentNullException ex) { context.ToResult($&quot;{ex.ParamName}不能为空&quot;); } };}); 方案二. 通过自定义ExceptionHandler，并注册到服务集合 自定义异常处理类ExceptionHandler，并继承IMasaExceptionHandler 12345678910111213/// &lt;summary&gt;/// 构造函数参数需支持从IOC获取/// &lt;/summary&gt;public class ExceptionHandler : IMasaExceptionHandler{ public void OnException(MasaExceptionContext context) { if (context.Exception is ArgumentNullException ex) { context.ToResult($&quot;{ex.ParamName}不能为空&quot;); } }} 使用指定的异常Handler，修改Program.cs 12345builder.Services.AddSingleton&lt;IMasaExceptionHandler, ExceptionHandler&gt;();//注册自定义异常var app = builder.Build();app.UseMasaExceptionHandler();// 在Program中执行异常处理程序 方案三. 通过自定义ExceptionHandler并指定ExceptionHandler来实现 自定义异常处理类ExceptionHandler，并继承IMasaExceptionHandler 12345678910111213/// &lt;summary&gt;/// 构造函数参数需支持从IOC获取/// &lt;/summary&gt;public class ExceptionHandler : IMasaExceptionHandler{ public void OnException(MasaExceptionContext context) { if (context.Exception is ArgumentNullException ex) { context.ToResult($&quot;{ex.ParamName}不能为空&quot;); } }} 使用指定的异常Handler，修改Program.cs 1app.UseMasaExceptionHandler(options =&gt; options.UseExceptionHanlder&lt;ExceptionHandler&gt;());//指定使用特定的异常处理程序 上述三种方案任选其一即可，提供的功能时一样的，仅仅是写法不同 修改HttpStatusCode状态码MasaExceptionContext默认提供了ToResult方法支持输入响应内容，状态码(默认: 299)，内容类型 (默认：text/plain; charset=utf-8)，我们可以根据自己的实际情况调用传参即可 修改日志级别异常类型为UserFriendlyException的默认日志等级为Information，其余异常的日志等级为Error，那么如果我想修改对应异常的日志等级应该怎么做？ 配置异常日志关系： 1234builder.Services.Configure&lt;MasaExceptionLogRelationOptions&gt;(options =&gt;{ options.MapLogLevel&lt;ArgumentNullException&gt;(LogLevel.None);}); 按照此方式，可以将类型为ArgumentNullException异常的日志等级设置为None（不记录日志） 常见问题Q: 为什么使用全局异常后没有记录日志？A： 检查是否指定了自定义异常处理的Handler，并且当前异常已经被自定义异常处理程序处理（ExceptionHandled = true） 检查当前异常类型是否配置了指定的日志等级，且当前日志等级小于默认记录日志的等级 Q: 实现IMasaExceptionHandler后，为什么发生异常后没有进入OnExceptionA: 未注入到服务集合且没有指定使用指定的ExceptionHanlder 自定义异常Handler 1234567public class ExceptionHandler : IMasaExceptionHandler{ public void OnException(MasaExceptionContext context) { throw new NotImplementedException(); }} 可参考自定义异常中的方案二或者方案三修改即可 总结Masa提供的全局异常中间件，对自定义异常的扩展支持较好，并且后续MASA Framework支持I18n后，全局异常也将增加I18n支持, 届时全局异常会更加方便 本章源码Assignment13 https://github.com/zhenlei520/MasaFramework.Practice 开源地址MASA.Framework：https://github.com/masastack/MASA.Framework MASA.EShop：https://github.com/masalabs/MASA.EShop MASA.Blazor：https://github.com/BlazorComponent/MASA.Blazor 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们","link":"/2022/10/13/masa/framework/practice/13.%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"title":"14. 最小API - MinimalAPIs","text":"在以前的MVC引用程序中，控制器负责接收输入信息、执行、编排操作并返回响应，它是一个功能齐全的框架，它提供了过滤器、内置了模型绑定与验证，并提供了很多可扩展的管道，但它偏重，不像其它语言是通过更加简洁的方式来开启Web之旅的，因此在.Net6.0官方引入了MinimalAPIs，即最小API，与MVC相比，它足够的简洁，适合小型服务来使用，下面就让我们看看如何使用MinimalAPI来开发一个web应用程序 入门下面我们来看一下官方提供的MinimalAPI是如何使用的 前提条件：安装.NET 6.0 新建ASP.NET Core 空项目Assignment.MinimalApiDemo 12dotnet new web -o Assignment.MinimalApiDemocd Assignment.MinimalApiDemo 增加一个Get请求，修改Program 1app.MapGet(&quot;/test&quot;, () =&gt; &quot;Test Success!&quot;); 根据需求，自行增加Get (MapGet)、Post (MapPost)、Put (MapPut)、Delete (MapDelete)方法即可，完整代码如下: 123var builder = WebApplication.CreateBuilder(args);var app = builder.Build();app.MapGet(&quot;/test&quot;, () =&gt; &quot;Test Success!&quot;); Masa版MinimalAPI随着我们的服务变得越来越多，这些服务全部被堆积在Program中，这样岂不是变成流水账式的代码？那怎么做才能使得我们的代码更加美观呢？ 下面我们就来看一下Masa提供的MinimalAPIs是如何来使用的 选中项目Assignment.MinimalApiDemo，并安装Masa.Contrib.Service.MinimalAPIs 1dotnet add package Masa.Contrib.Service.MinimalAPIs --version 0.6.0-preview.13 注册Masa版的MinimalAPI，修改Program 1var app = builder.AddServices(); 新增加一个用户的服务，新增UserService类 12345678public class UserService : ServiceBase{ public IResult Add(RegisterUserRequest request) { //模拟添加用户 return Results.Ok(); }} 到这里已经结束了，可能会有小伙伴十分的疑惑，Masa提供的方案让我有点摸不着头脑，但项目运行后就会发现在Swagger上多了一个服务 细心的小伙伴发现了，这个服务好像是我们新增的添加用户服务，但链接地址为什么是api/v1/Users 🤔🤔 进阶通过快速入门我们了解到如何使用MinimalAPI，但我们也清楚流水账式编程的危害，我们不希望让项目中充斥着流水账式的代码，我们希望它是整洁的，并且是有迹可循的，这时候Masa提供的MinimalAPI方案进入了我们的视野，它上手难度极低，对我们来说它是很棒的，但如果我们不清楚它是如何设计的话，我们敢放心大胆的使用它吗？虽然它有些枯燥，但我们必须要掌握它是如何设计的，它都支持了什么样的功能 约定当服务未禁用自动映射路由时，框架会自动扫描继承ServiceBase的非抽象子类并注册到服务集合中(IServiceCollection)，并为满足以下要求的方法自动注册路由 当前类的方法的访问级别为public（不包含父类方法） 方法上未增加特性IgnoreRouteAttribute 路由规则路由规则优先级： 自定义路由 &gt; 约定生成路由 如何自定义路由？ 通过RoutePattern特性我们可以为方法自定义路由 123456[RoutePattern(&quot;user/add&quot;)]public IResult Add([FromBody]RegisterUserRequest request){ //模拟添加用户 return Results.Ok();} 约定的生成路由规则为： Pattern(路由) = BaseUri + RouteMethodName BaseUri: 根地址，默认: null 当BaseUri为空或者null时，则 BaseUri = Prefix/Version/ServiceName RouteMethodName: 除非自定义RouteMethodName，否则RouteMethodName = GetMethodName(方法名) GetMethodName: TrimStart：Get/Post/Create/Put/Update/Delete/Remove 等 TrimEnd：Async PS：/api/v1/User/Add，将会变成/api/v1/User 当方法的参数存在id并且id支持从Route中获取时，将会变成/api/v1/User/{id}，如果id为可空或者存在默认值时，将会变成/api/v1/User/{id?} 配置配置分为全局配置、局部配置（仅在当前服务生效），其中优先级为：局部配置 &gt; 全局配置，默认局部配置的参数为null，我们约定局部参数未配置时，以全局配置为准 全局配置 DisableAutoMapRoute: 是否禁用自动映射路由，如果为true (禁用)，则框架不会自动映射路由，默认：false Prefix: 前缀，默认: api Version: 版本，默认: v1 AutoAppendId: 是否追加Id，默认: true PluralizeServiceName: 服务名称是否启用复数，默认: true GetPrefixes: 用于识别当前方法类型为Get请求，默认: new List&lt;string&gt; { &quot;Get&quot;, &quot;Select&quot; } PostPrefixes: 用于识别当前方法类型为Post请求，默认: new List&lt;string&gt; { &quot;Post&quot;, &quot;Add&quot;, &quot;Upsert&quot;, &quot;Create&quot; } PutPrefixes: 用于识别当前方法类型为Put请求，默认: new List&lt;string&gt; { &quot;Put&quot;, &quot;Update&quot;, &quot;Modify&quot; } DeletePrefixes: 用于识别当前方法类型为Delete请求，默认: new List&lt;string&gt; { &quot;Delete&quot;, &quot;Remove&quot; } DisableTrimMethodPrefix: 禁用移除方法前缀(Get/Post/Create/Put/Update/Delete/Remove 等), 默认: false MapHttpMethodsForUnmatched: 匹配请求方式失败使用，默认: 支持Post、Get、Delete、Put Assemblies: 用于扫描服务所在的程序集，默认: AppDomain.CurrentDomain.GetAssemblies() RouteHandlerBuilder: 基于RouteHandlerBuilder的委托，可用于权限认证、Cors等 局部配置 BaseUri: 根地址，默认: null ServiceName: 自定义服务名，默认: null RouteHandlerBuilder：基于RouteHandlerBuilder的委托，可用于权限认证、Cors等 RouteOptions: 局部路由配置 DisableAutoMapRoute Prefix Version AutoAppendId PluralizeServiceName GetPrefixes PostPrefixes PutPrefixes DeletePrefixes DisableTrimMethodPrefix MapHttpMethodsForUnmatched 其中ServiceName为null时，ServiceName = 类名.TrimEnd(&quot;Service&quot;) //不区分大小写 特性RoutePattern用于自定义路由，支持参数 Pattern: 自定义路由或自定义方法名 当StartWithBaseUri：true，Pattern为自定义方法名 当StartWithBaseUri：false，Pattern为自定义路由 StartWithBaseUri: 是否基于BaseUri进行追加，默认: false HttpMethod：请求类型，默认: null（根据方法名前缀自动识别），如果希望指定请求类型而非自动识别，则可手动指定：Get、Post、Put、Delete IgnoreRoute用于忽略方法自动映射，例如；存在某个方法已经手动指定映射路由，不希望框架重复进行映射可使用IgnoreRoute, 例如: 12345678910111213public class User2Service : ServiceBase{ public User2Service() { App.Map(&quot;/api/v2/user/add&quot;, Add); } [IgnoreRoute] public void Add([FromBody] RegisterUserRequest request, IData data) { data.Add(request.Name, request.Age); }} 场景通过上面的学习我们已经了解到了Masa提供了哪些配置，那下面就让我们实战来演练一下，通过模拟不同的场景使用不同的配置，以确保我们正确掌握这些知识 Q: 我不是一个新手，从0.6.0版本以前的版本就开始使用Masa提供的MinimalAPI了，对新版的MinimalAPI很喜欢，但我暂时不希望更改手动注册的方式，我希望升级之后不会对我现有的项目造成影响，我不希望将升级导致原来的服务无法访问 A: 您希望继续使用最新版的MinimalAPI，但不希望对原来的项目造成影响，在当前服务中，希望能一如既往的使用手动注册，而不是自动注册，那你可以配置全局禁用自动注册，例如： 1234var app = builder.AddServices(options =&gt;{ options.DisableAutoMapRoute = true;}); 当然如果您希望在某个特定的服务中开启自动映射，则可以在服务中配置: 123456789101112public class UserService: ServiceBase{ public UserService() { RouteOptions.DisableAutoMapRoute = false; } public void Add([FromBody] RegisterUserRequest request, IData data) { data.Add(request.Name, request.Age); }} Q: 我是一个新手，我觉得我的项目不需要使用前缀以及版本，我希望自动映射的路由可以帮助我删掉它们 A: 你需要的是全局配置，通过全局配置禁用前缀以及版本即可，例如： 12345var app = builder.AddServices(options =&gt;{ options.Prefix = string.Empty; options.Version = string.Empty;}); Q: 我是一个新手，虽然我很想严格遵守Resetful标准来写服务，但遗憾的是我无法掌控全局，总是有人不按照标准对方法进行命名，我希望可以人为控制特定的方法的路由 A: 目前有两种方法可供选择，它们分别是： 第一种：自定义路由并忽略自动映射 12345678910111213public class UserService : ServiceBase{ public UserService() { App.Map(&quot;/user/add&quot;, Add); } [IgnoreRoute] public void Add([FromBody] RegisterUserRequest request, IData data) { data.Add(request.Name, request.Age); }} 第二种: 完整自定义路由： 12345678public class UserService : ServiceBase{ [RoutePattern(&quot;/api/v2/user/add&quot;)] public void CreateUser([FromBody] RegisterUserRequest request, IData data) { data.Add(request.Name, request.Age); }} 第三种: 仅修改请求方式 12345678public class UserService : ServiceBase{ [RoutePattern(HttpMethod = &quot;Post&quot;)] public void CreateUser([FromBody] RegisterUserRequest request, IData data) { data.Add(request.Name, request.Age); }} 如果您希望手动指定方法的请求类型，则可以使用[RoutePattern(&quot;/api/v2/user/add&quot;, HttpMethod = &quot;Post&quot;)] Q: 我希望为项目中所有的接口都必须授权才能访问，但我不希望在每个方法上增加Authorize特性，那样太恶心了 A: 您的项目是需要为全局服务来设置，则可通过全局配置的RouteHandlerBuilder参数来完成，例如： 1234var app = builder.AddServices(options =&gt;{ options.RouteHandlerBuilder = routeHandlerBuilder =&gt; routeHandlerBuilder.RequireAuthorization();}); 如果您希望对某个服务增加特殊的授权策略，则可以： 123456789101112public class UserService : ServiceBase{ public UserService() { RouteHandlerBuilder = routeHandlerBuilder =&gt; routeHandlerBuilder.RequireAuthorization(&quot;test&quot;); } public void CreateUser([FromBody] RegisterUserRequest request, IData data) { data.Add(request.Name, request.Age); }} 但是你必须知道的是，如果在服务内配置了RouteHandlerBuilder，那么全局配置的RouteHandlerBuilder将对当前服务失效，局部配置存在时，全局配置将不起作用 Q: 我希望某个服务不需要经过授权即可访问，那我该怎么做？ A: 只需要在方法上加AllowAnonymous特性即可, 它是MinimalAPI支持的，除了AllowAnonymous、EnableCors、Authorize等都是支持的, 但HttpGet、HttpPost、HttpPut、HttpDelete特性是不支持的 12345678public class UserService : ServiceBase{ [AllowAnonymous] public void CreateUser([FromBody] RegisterUserRequest request, IData data) { data.Add(request.Name, request.Age); }} 常见问题 为何使用DbContext时总是提示DbContext已经被释放？ UserService仅在项目启动时会被初始化一次，之后不再初始化，因此Service的构造函数参数仅支持Singleton或Transient。如果您的服务的生命周期为Scoped，建议在对应的方法中增加参数，例如： 1234public void Add([FromBody] RegisterUserRequest request, IData data){ data.Add(request.Name, request.Age);} 模型校验不起作用？ 目前版本的MinimalAPI并不支持模型绑定与验证，后续版本会增加支持 Builder.AddServices()又为什么必须要放到最后？ 我们知道通过builder.Build()可以得到WebApplication，但在.Net6.0中新增加了限制，这个限制就是在Build后无法再次更新IServiceCollection，否则会提示Cannot modify ServiceCollection after application is built 为什么MinimalAPIs的生命周期是单例？ 目前AddServices方法中做了两件事，第一件事就是获取到所有的服务，并注册到服务集合中，第二件事就是触发服务并将对应服务的地址以及方法映射到到App，App.Map类似App.Use，也是一个扩展方法，类似MVC的路由，其生命周期是单例，我们仅仅是将继承ServiceBase的服务映射到App中，并没有魔改MinimalAPI，因此并不存在性能问题，但同样其生命周期也无法改变 总结MinimalAPI与MVC我应该如何选择？ 小型服务使用MinimalAPI，因为它是很轻量级的，但如果是大型服务或者功能特别复杂的，还是推荐使用MVC，MinimalAPI的上手成本很低，但它不是银弹，选择适合自己的才是最好的 MinimalAPI还有一些特殊的地方，例如Get请求无法使用类对象来接收参数，如果希望使用类对象来接受，则需要使用自定义绑定，除此之外还有其他不一样的地方，完整文档可查看 本章源码Assignment14 https://github.com/zhenlei520/MasaFramework.Practice 开源地址MASA.Framework：https://github.com/masastack/MASA.Framework MASA.EShop：https://github.com/masalabs/MASA.EShop MASA.Blazor：https://github.com/BlazorComponent/MASA.Blazor 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们","link":"/2022/07/12/masa/framework/practice/14.%20%E6%9C%80%E5%B0%8F%20API%20-%20MinimalAPIs/"},{"title":"15. 命令查询职责分离 - CQRS","text":"概念CQRS是一种与领域驱动设计和事件溯源相关的架构模式, 它的全称是Command Query Responsibility Segregation, 又叫命令查询职责分离, Greg Young在2010年创造了这个术语, 它是基于Bertrand Meyer 的 CQS (Command-Query Separation 命令查询分离原则) 设计模式。 CQRS认为不论业务多复杂在最终实现的时候, 无非是读写操作, 因此建议将应用程序分为两个方面, 即Command（命令）和Query（查询） 命令端: 关注各种业务如何处理, 更新状态进行持久化 不返回任何结果 (void) 查询端: 查询, 并从不修改数据库 CQRS的三种实现单一数据库的CQRS 命令与读取操作的是同一个数据库, 命令端通过ORM框架将实体保存到数据库中, 查询端通过数据访问层获取数据 (数据访问层通过ORM框架或者存储过程获取数据) 双数据库的CQRS 命令与读取操作的是不同的数据库, 命令端通过ORM框架将实体保存到 写库 (Write Db), 并将本地改动推送到 读库 (Read Db), 查询端通过数据访问层访问 读库 (Read Db), 使用这种模式可以带来以下好处: 查询更简单 读操作不需要任何的完整性校验, 也不需要外键约束, 可以减少锁争用, 我们可以针对查询端单独优化, 还可以使用刚好包含每个模板需要的数据的数据库视图，使得查询变得更快更简单 提升查询端的使用体验 由于这种架构将读写彻底分离,由于一般系统是读操作远远大于写操作, 这给我们的系统带来了巨大的性能提升, 极大的提升了客户的使用体验 关注点分离 读写分离的模型可以使得关注点分离, 使得读模型会变得相对简单 事件溯源 (Event Sourcing) CQRS 通过事件溯源实现的CQRS中会将应用程序的改变都以事件的方式存储起来, 使用这种模式可以带来以下好处: 事件存储中了完整的审计跟踪, 后续出现问题时方便跟踪 可以在任何的时间点重建实体的状态, 它将有助于排查问题并修复问题 提升查询端的使用体验 查询端与命令端可以是完全不同的数据源, 查询端可以针对查询条件做针对应的优化, 或者使用像ES、Redis等用来存储数据, 提升查询效率 独立缩放 命令端与查询端可以被独立缩放, 减少锁争用 当然事情有利自然也有弊, CQRS的使用固然会带来很多好处, 但同样它也会给项目带来复杂度的提升, 并且双数据库模式、事件溯源模式 的CQRS, 使用的是最终一致性, 这些都是我们在选择技术方案时必须要考虑的 设计上述文章中我们了解到了CQRS其本质上是一种读写分离的设计思想, 它并不是强制性的规定必须要怎样去做, 这点与之前的IEvent (进程内事件)、IIntegrationEvent (跨进程事件)不同, 它并不是强制性的, 根据CQRS的设计模式我们将事件分成Command、Query 由于Query (查询) 是需要有返回值的, 因此我们在继承IEvent的同时, 还额外增加了一个Result属性用以存储结果, 我们希望将查询的结果保存到Result中, 但它不是强制性的, 我们并没有强制性要求必须要将结果保存到Result中。 由于Command (命令) 是没有返回值的, 因此我们并没有额外新增Result属性, 我们认为命令会更新数据, 那就需要用到工作单元, 因此Command除了继承IEvent之外, 还继承了ITransaction，这方便了我们在Handler中的可以通过@event.UnitOfWork来管理工作单元, 而不需要通过构造函数来获取 但MasaFramework 并没有要求必须使用 Event Sourcing 模式 或者 双数据库模式 的CQRS, 具体使用哪种实现, 它取决于业务的决策者 下面就就来看看MasaFramework提供的CQRS是如何使用的 入门 安装.NET 6.0 新建ASP.NET Core 空项目Assignment.CqrsDemo，并安装Masa.Contrib.Dispatcher.Events，Masa.Contrib.Dispatcher.IntegrationEvents，Masa.Contrib.Dispatcher.IntegrationEvents.Dapr，Masa.Contrib.ReadWriteSplitting.Cqrs，Masa.Contrib.Development.DaprStarter.AspNetCore 123456789dotnet new web -o Assignment.CqrsDemocd Assignment.CqrsDemodotnet add package Masa.Contrib.Dispatcher.Events --version 0.7.0-preview.9 //使用进程内事件总线dotnet add package Masa.Contrib.Dispatcher.IntegrationEvents --version 0.7.0-preview.9 //使用跨进程事件总线dotnet add package Masa.Contrib.Dispatcher.IntegrationEvents.Dapr --version 0.7.0-preview.9 //使用Dapr提供pubsub能力dotnet add package Masa.Contrib.ReadWriteSplitting.Cqrs --version 0.7.0-preview.9 //使用CQRSdotnet add package Masa.Contrib.Development.DaprStarter.AspNetCore --version 0.7.0-preview.9 //开发环境下协助 Dapr Sidecar, 用于通过Dapr发布集成事件 注册跨进程事件总线、进程内事件总线, 修改类Program.cs 示例中未真实使用DB, 不再使用发件箱模式, 只需要使用集成事件提供的PubSub能力即可 12345builder.Services.AddIntegrationEventBus(dispatcherOptions =&gt;{ dispatcherOptions.UseDapr();//使用 Dapr 提供的PubSub能力 dispatcherOptions.UseEventBus();//使用进程内事件总线}); 注册Dapr Starter 协助管理Dapr Sidecar (开发环境使用) 12if (builder.Environment.IsDevelopment()) builder.Services.AddDaprStarter(); 新增加添加商品方法, 修改类Program.cs 123456789101112131415161718app.MapPost(&quot;/goods/add&quot;, async (AddGoodsCommand command, IEventBus eventBus) =&gt;{ await eventBus.PublishAsync(command);});/// &lt;summary&gt;/// 添加商品参数, 用于接受商品参数/// &lt;/summary&gt;public record AddGoodsCommand : Command{ public string Name { get; set; } public string Cover { get; set; } public decimal Price { get; set; } public int Count { get; set; }} 新增加查询商品的方法, 修改类Program.cs 123456789101112131415161718192021222324252627282930313233343536373839app.MapGet(&quot;/goods/{id}&quot;, async (Guid id, IEventBus eventBus) =&gt;{ var query = new GoodsItemQuery(id); await eventBus.PublishAsync(query); return query.Result;});/// &lt;summary&gt;/// 用于接收查询商品信息参数/// &lt;/summary&gt;public record GoodsItemQuery : Query&lt;GoodsItemDto&gt;{ public Guid Id { get; set; } = default!; public override GoodsItemDto Result { get; set; } public GoodsItemQuery(Guid id) { Id = id; }}/// &lt;summary&gt;/// 用于返回商品信息/// &lt;/summary&gt;public class GoodsItemDto{ public Guid Id { get; set; } public string Name { get; set; } public string Cover { get; set; } public decimal Price { get; set; } public int Count { get; set; } public DateTime DateTime { get; set; }} 新增Command处理程序, 添加类CommandHandler.cs 12345678910111213141516171819202122232425262728293031323334353637383940public class CommandHandler{ /// &lt;summary&gt; /// 将商品添加到Db，并发送跨进程事件 /// &lt;/summary&gt; /// &lt;param name=&quot;command&quot;&gt;&lt;/param&gt; /// &lt;param name=&quot;integrationEventBus&quot;&gt;&lt;/param&gt; [EventHandler] public async Task AddGoods(AddGoodsCommand command, IIntegrationEventBus integrationEventBus) { //todo: 模拟添加商品到db并发送添加商品集成事件 var goodsId = Guid.NewGuid(); //模拟添加到db后并获取商品id await integrationEventBus.PublishAsync(new AddGoodsIntegrationEvent(goodsId, command.Name, command.Cover, command.Price, command.Count)); }}/// &lt;summary&gt;/// 跨进程事件, 发送添加商品事件/// &lt;/summary&gt;/// &lt;param name=&quot;Id&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;Name&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;Cover&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;Price&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;Count&quot;&gt;&lt;/param&gt;public record AddGoodsIntegrationEvent(Guid Id, string Name, string Cover, decimal Price, int Count) : IntegrationEvent{ public Guid Id { get; set; } = Id; public string Name { get; set; } = Name; public string Cover { get; set; } = Cover; public decimal Price { get; set; } = Price; public int Count { get; set; } = Count; public override string Topic { get; set; } = nameof(AddGoodsIntegrationEvent);} 新增Query处理程序, 添加类QueryHandler.cs 1234567891011121314151617public class QueryHandler{ /// &lt;summary&gt; /// 从缓存查询商品信息 /// &lt;/summary&gt; /// &lt;param name=&quot;query&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; [EventHandler] public Task GetGoods(GoodsItemQuery query) { //todo: 模拟从cache获取商品 var goods = new GoodsItemDto(); query.Result = goods; return Task.CompletedTask; }} 新增添加商品的跨进程事件的处理服务, 修改Program.cs 12345678910111213141516app.MapPost( &quot;/integration/goods/add&quot;, [Topic(&quot;pubsub&quot;, nameof(AddGoodsIntegrationEvent))] (AddGoodsIntegrationEvent @event, ILogger&lt;Program&gt; logger) =&gt; { //todo: 模拟添加商品到缓存 logger.LogInformation(&quot;添加商品到缓存, {Event}&quot;, @event); });// 使用 dapr 来订阅跨进程事件app.UseRouting();app.UseCloudEvents();app.UseEndpoints(endpoint =&gt;{ endpoint.MapSubscribeHandler();}); 流水账式的服务会使得Program.cs变得十分臃肿, 可以通过Masa Framework提供的MinimalAPIs来简化Program.cs 点击查看详情。 总结我们上面的例子是通过事件总线来完成解耦以及数据模型的同步, 使用的双数据库模式, 但读库使用的是 缓存数据库, 在Command端做商品的添加操作, 在Query端只做查询, 且两端分别使用各自的数据源, 两者业务互不影响, 并且由于缓存数据库性能更强, 它将最大限度的提升性能, 使得我们有更好的使用体验。 在Masa Framework中仅仅是通过ICommand、IQuery将读写分开, 但这并没有硬性要求, 事实上你使用IEvent也是可以的, CQRS只是一种设计模式, 这点我们要清楚, 它只是告诉我们要按照一个什么样的标准去做, 但具体怎么来做, 取决于业务的决策者, 除此之外, 后续Masa Framework还会增加对Event Sourcing（事件溯源）的支持, 通过事件重放, 允许我们随时重建到对象的任何状态 本章源码Assignment15 https://github.com/zhenlei520/MasaFramework.Practice CQRS架构项目：https://github.com/masalabs/MASA.EShop/tree/main/src/Services/Masa.EShop.Services.Catalog 参考 CQRS 模式 在微服务中应用简化后的 CQRS 和 DDD 模式 .NET现代化应用开发 - CQRS&amp;类目管理代码剖析 开源地址MASA.Framework：https://github.com/masastack/MASA.Framework MASA.EShop：https://github.com/masalabs/MASA.EShop MASA.Blazor：https://github.com/BlazorComponent/MASA.Blazor 如果你对我们的 MASA Framework 感兴趣, 无论是代码贡献、使用、提 Issue, 欢迎联系我们","link":"/2022/11/23/masa/framework/practice/15.%20%E5%91%BD%E4%BB%A4%E6%9F%A5%E8%AF%A2%E8%81%8C%E8%B4%A3%E5%88%86%E7%A6%BB%20-%20CQRS/"},{"title":"16. 缓存 - Caching","text":"概念什么是缓存，在项目中，为了提高数据的读取速度，我们会对不经常变更但访问频繁的数据做缓存处理，我们常用的缓存有： 本地缓存 内存缓存：IMemoryCache 分布式缓存 Redis: StackExchange.Redis 功能目前，MasaFramework为我们提供了以下能力 IDistributedCacheClient: 分布式缓存 Masa.Contrib.Caching.Distributed.StackExchangeRedis: 基于StackExchange.Redis实现的分布式缓存 IMultilevelCacheClient: 多级缓存 Masa.Contrib.Caching.MultilevelCache: 基于内存缓存以及分布式缓存实现的多级缓存，支持监控缓存变更，分布式缓存更新后相应的内存缓存也会同步更新，避免命中过时的内存缓存导致获取错误的数据，同时也尽可能的将多个副本的内存缓存保持同步 入门 前提条件：安装.NET 6.0 分布式缓存 新建ASP.NET Core 空项目Assignment.DistributedCache，并安装Masa.Contrib.Caching.Distributed.StackExchangeRedis 1234dotnet new web -o Assignment.DistributedCachecd Assignment.DistributedCachedotnet add package Masa.Contrib.Caching.Distributed.StackExchangeRedis --version 0.6.0-rc.5 配置Redis配置信息 123456789101112{ &quot;RedisConfig&quot;:{ &quot;Servers&quot;:[ { &quot;Host&quot;:&quot;localhost&quot;, &quot;Port&quot;:6379 } ], &quot;DefaultDatabase&quot;:3, &quot;ConnectionPoolSize&quot;:10 }} 注册分布式缓存，并使用Redis缓存，修改Program.cs 1234567var builder = WebApplication.CreateBuilder(args);//注册分布式缓存builder.Services.AddDistributedCache(distributedCacheOptions =&gt;{ distributedCacheOptions.UseStackExchangeRedisCache();//使用分布式Redis缓存, 默认使用本地`RedisConfig`下的配置}); 使用分布式缓存的数据来源默认为 IOptionsMonitor&lt;RedisConfigurationOptions&gt;，如果本地未正确在RedisConfig节点配置缓存信息，且项目中也没有通过其它方式配置使其支持选项模式，则默认使用的Redis配置为： 地址: localhost、端口：6379，密码：空，数据库：db0 新建User类，用于接收用户信息 123456public class User{ public string Name { get; set; } public int Age { get; set; }} 如何使用IDistributedCacheClient，修改Program.cs 12345678910111213// 设置缓存app.MapPost(&quot;/set/{id}&quot;, async (IDistributedCacheClient distributedCacheClient, [FromRoute] string id, [FromBody] User user) =&gt;{ await distributedCacheClient.SetAsync(id, user); return Results.Accepted();});// 获取缓存app.MapGet(&quot;/get/{id}&quot;, async (IDistributedCacheClient distributedCacheClient, [FromRoute] string id) =&gt;{ var value = await distributedCacheClient.GetAsync&lt;User&gt;(id); return Results.Ok(value);}); 多级缓存 新建ASP.NET Core 空项目Assignment.DistributedCache，并安装Masa.Contrib.Caching.MultilevelCache、Masa.Contrib.Caching.Distributed.StackExchangeRedis 12345dotnet new web -o Assignment.MultilevelCachecd Assignment.MultilevelCachedotnet add package Masa.Contrib.Caching.MultilevelCache --version 0.6.0-rc.5dotnet add package Masa.Contrib.Caching.Distributed.StackExchangeRedis --version 0.6.0-rc.5 注册多级缓存，并使用分布式Redis缓存，修改Program.cs 1234567var builder = WebApplication.CreateBuilder(args);//注册多级缓存builder.Services.AddMultilevelCache(distributedCacheOptions =&gt;{ distributedCacheOptions.UseStackExchangeRedisCache();//使用分布式Redis缓存}); 新建User类，用于接收用户信息 123456public class User{ public string Name { get; set; } public int Age { get; set; }} 如何使用IMultilevelCacheClient，修改Program.cs 12345678910111213// 设置缓存app.MapPost(&quot;/set/{id}&quot;, async (IMultilevelCacheClient multilevelCacheClient, [FromRoute] string id, [FromBody] User user) =&gt;{ await multilevelCacheClient.SetAsync(id, user); return Results.Accepted();});// 获取缓存app.MapGet(&quot;/get/{id}&quot;, async (IMultilevelCacheClient multilevelCacheClient, [FromRoute] string id) =&gt;{ var value = await multilevelCacheClient.GetAsync&lt;User&gt;(id); return Results.Ok(value);}); 测试借助Postman或者Swagger或者使用其它API测试工具，分别测试设置缓存与获取缓存，以验证分布式缓存以及多级缓存是可以正常使用的。 友情提示：检查Redis缓存，找到刚刚你配置的缓存，确定下它的存储结果是否与你想象的一致!! 规则经过测试，我们的分布式缓存与多级缓存是可以正常使用的，但查看Redis的存储结果后，发现它们实际的存储与我们心目中的结果好像是有点出入，它们分别是： 缓存Key不同 (与我们设置的Key不完全一致) 结构不同 (实际存储的为Hash类型) 内容不同 (内容经过压缩) 缓存Key的生成规则缓存Key支持三种规则： 枚举 值 描述 None 1 不做处理，传入的Key即为实际的缓存Key TypeName 2 实际的缓存Key = $”{GetTypeName(T)}.{传入缓存Key}” (默认) TypeAlias 3 根据TypeName得到对应的别名与Key的组合，Format: ${TypeAliasName}{:}{key} 详细规则可查看 存储结构与规则Masa.Contrib.Caching.Distributed.StackExchangeRedis使用的是Hash存储，通过使用Hash存储，支持缓存的绝对过期以及相对过期，其中： 键 描述 详细 特殊 absexp 绝对过期时间的Ticks 自公历 0001-01-01 00:00:00:000 到绝对过期时间的计时周期数 (1周期 = 100ns 即 1/10000 ms) -1 为永不过期 sldexp 滑动过期时间的Ticks 自公历 0001-01-01 00:00:00:000 到滑动过期时间的计时周期数 (1周期 = 100ns 即 1/10000 ms，每次获取数据时会刷新滑动过期时间) -1 为永不过期 data 数据 存储用户设置的缓存数据 内容压缩规则 当存储值类型为以下类型时，不对数据进行压缩： Byte SByte UInt16 UInt32 UInt64 Int16 Int32 Int64 Double Single Decimal 当存储值类型为字符串时，对数据进行压缩 当存储值类型不满足以上条件时，对数据进行序列化并进行压缩 分布式Redis缓存示例分布式缓存注册方案一. 通过本地配置文件注册 修改appsettings.json文件 123456789101112{ &quot;RedisConfig&quot;:{ &quot;Servers&quot;:[ { &quot;Host&quot;:&quot;localhost&quot;, &quot;Port&quot;:6379 } ], &quot;DefaultDatabase&quot;:3, &quot;ConnectionPoolSize&quot;:10 }} 注册分布式Redis缓存 1234builder.Services.AddDistributedCache(distributedCacheOptions =&gt;{ distributedCacheOptions.UseStackExchangeRedisCache();}); 方案二. 手动指定Redis配置注册 12345678910111213141516builder.Services.AddDistributedCache(distributedCacheOptions =&gt;{ distributedCacheOptions.UseStackExchangeRedisCache(options =&gt; { options.Servers = new List&lt;RedisServerOptions&gt;() { new(&quot;localhost&quot;, 6379) }; options.DefaultDatabase = 3; options.ConnectionPoolSize = 10; options.GlobalCacheOptions = new CacheOptions() { CacheKeyType = CacheKeyType.None //全局禁用缓存Key格式化处理 }; });}); 方案三. 通过选项模式注册 通过Configure方法使其支持选项模式 12345678910111213builder.Services.Configure&lt;RedisConfigurationOptions&gt;(redisConfigurationOptions =&gt;{ redisConfigurationOptions.Servers = new List&lt;RedisServerOptions&gt;() { new(&quot;localhost&quot;, 6379) }; redisConfigurationOptions.DefaultDatabase = 3; redisConfigurationOptions.ConnectionPoolSize = 10; redisConfigurationOptions.GlobalCacheOptions = new CacheOptions() { CacheKeyType = CacheKeyType.None };}); 注册分布式Redis缓存 1234builder.Services.AddDistributedCache(distributedCacheOptions =&gt;{ distributedCacheOptions.UseStackExchangeRedisCache();}); 方案四. 通过指定Configuration注册 在Redis缓存的配置存储到本地appsettings.json文件 123456789101112{ &quot;RedisConfig&quot;:{ &quot;Servers&quot;:[ { &quot;Host&quot;: &quot;localhost&quot;, &quot;Port&quot;: 6379 } ], &quot;DefaultDatabase&quot;: 3, &quot;ConnectionPoolSize&quot;: 10 }} 指定Configuration注册分布式Redis缓存 12345678var builder = WebApplication.CreateBuilder(args);//注册分布式缓存builder.Services.AddDistributedCache(distributedCacheOptions =&gt;{ // 使用存储Redis配置的Configuration distributedCacheOptions.UseStackExchangeRedisCache(builder.Configuration.GetSection(&quot;RedisConfig&quot;));}); 方案五. 将配置存储到Dcc上，并通过Configuration提供的手动映射功能，实现选项模式 使用Dcc，并手动指定映射 12345678910builder.AddMasaConfiguration(configurationBuilder =&gt;{ configurationBuilder.UseDcc();//使用Dcc 扩展Configuration能力，支持远程配置 configurationBuilder.UseMasaOptions(options =&gt; { //通过手动映射RedisConfigurationOptions的配置，实现选项模式 options.MappingConfigurationApi&lt;RedisConfigurationOptions&gt;(&quot;{替换为Dcc中配置所属的AppId}&quot;, &quot;{替换为Redis配置的对象名称}&quot;); });}); 注册分布式Redis缓存 1234builder.Services.AddDistributedCache(distributedCacheOptions =&gt;{ distributedCacheOptions.UseStackExchangeRedisCache();}); 方案三、四、五的本质都是通过支持选项模式来注册分布式Redis缓存 修改缓存Key映射规则修改缓存Key映射规则十分简单，我们在配置时更改CacheKeyType为对应的规则即可，但当 CacheKeyType = 3 需要注意，它需要额外提供类型名与别名的对应关系，完整例子如下： 修改appsettings.json, 将CacheKeyType的值改为 3 123456789101112131415{ &quot;RedisConfig&quot;:{ &quot;Servers&quot;:[ { &quot;Host&quot;:&quot;localhost&quot;, &quot;Port&quot;:6379 } ], &quot;DefaultDatabase&quot;:3, &quot;ConnectionPoolSize&quot;:10, &quot;GlobalCacheOptions&quot;: { &quot;CacheKeyType&quot;: 3 //CacheKeyType为3时启用别名格式化缓存Key，可节省缓存Key的键长度 } }} 注册分布式缓存并配置类型名与别名的对应关系 12345678910builder.Services.AddDistributedCache(distributedCacheOptions =&gt;{ distributedCacheOptions.UseStackExchangeRedisCache();}, typeAliasOptions =&gt;{ typeAliasOptions.GetAllTypeAliasFunc = () =&gt; new Dictionary&lt;string, string&gt;() { { &quot;String&quot;, &quot;s&quot; }//当类型为String时，格式化后的Key为 s:key };}); 通过指定类型与别名的对应关系，从而使得最终形成较短的缓存Key，以达到节省存储空间的目的，缓存Key生成规则可查看 多级缓存示例多级缓存注册方案一. 通过本地配置文件注册 修改appsettings.json文件，分别配置多级缓存配置以及Redis缓存配置 12345678910111213141516171819202122{ // 多级缓存全局配置，非必填 &quot;MultilevelCache&quot;: { &quot;SubscribeKeyPrefix&quot;: &quot;masa&quot;,//默认订阅方key前缀，用于拼接channel &quot;SubscribeKeyType&quot;: 3, //默认订阅方key的类型，默认ValueTypeFullNameAndKey，用于拼接channel &quot;CacheEntryOptions&quot;: { &quot;AbsoluteExpirationRelativeToNow&quot;: &quot;00:00:30&quot;,//绝对过期时长（距当前时间） &quot;SlidingExpiration&quot;: &quot;00:00:50&quot;//滑动过期时长（距当前时间） } }, // Redis分布式缓存配置 &quot;RedisConfig&quot;: { &quot;Servers&quot;: [ { &quot;Host&quot;: &quot;localhost&quot;, &quot;Port&quot;: 6379 } ], &quot;DefaultDatabase&quot;: 3 }} 添加多级缓存并使用分布式Redis缓存 1234builder.Services.AddMultilevelCache(distributedCacheOptions =&gt;{ distributedCacheOptions.UseStackExchangeRedisCache();}); 方案二. 通过手动指定配置 1234builder.Services.AddMultilevelCache(distributedCacheOptions =&gt;{ distributedCacheOptions.UseStackExchangeRedisCache(RedisConfigurationOptions);}); 未配置内存缓存时，默认内存缓存永久有效 除了上述两种方式以外，多级缓存的内存缓存配置也同样支持选项模式，我们可以通过Dcc或者利用 builder.Services.Configure&lt;MultilevelCacheOptions&gt;(builder.Configuration)来支持选项模式 修改缓存Key映射规则源码解读IDistributedCacheClient (分布式缓存客户端)IDistributedCacheClient接口提供以下方法来处理分布式缓存 以下方法会根据全局缓存Key的规则配置以及传入缓存Key的规则配置，检测是否需要格式化缓存Key，对需要格式化Key的操作按照缓存Key格式化规则进行处理，详细查看: Get&lt;T&gt;、GetAsync&lt;T&gt;: 根据缓存Key返回类型为T的结果 (如果缓存不存在，则返回Null) GetList&lt;T&gt;、GetListAsync&lt;T&gt;: 根据缓存Key集合返回对应的缓存值的集合 (针对不存在的缓存key，其值返回Null) GetOrSet&lt;T&gt;、GetOrSetAsync&lt;T&gt;: 如果在缓存中找到，则返回类型为T的结果，如果缓存未找到，则执行Setter，并返回Setter的结果 Set&lt;T&gt;、SetAsync&lt;T&gt;: 将指定的缓存Key以及缓存值添加到缓存 SetList&lt;T&gt;、SetListAsync&lt;T&gt;: 将指定的缓存Key、Value集合添加缓存 Remove&lt;T&gt;、RemoveAsync&lt;T&gt;: 将指定的缓存Key (缓存Key集合) 从缓存中移除 Refresh&lt;T&gt;、RefreshAsync&lt;T&gt;: 刷新指定的缓存Key (缓存Key集合) 的生命周期 适用于未被删除、绝对过期时间没有到，但相对过期时间快到的缓存 (延长滑动过期时间) Exists&lt;T&gt;、ExistsAsync&lt;T&gt;: 如果在缓存中找到，则返回true，否则返回false GetKeys&lt;T&gt;、GetKeysAsync&lt;T&gt;: 根据key pattern 得到符合规则的所有缓存Key GetByKeyPattern&lt;T&gt;、GetByKeyPatternAsync&lt;T&gt;: 根据key pattern 得到符合规则的所有缓存Key、Value集合 HashIncrementAsync: 将指定的缓存Key的值增加Value，并返回增长后的结果 HashDecrementAsync: 将指定的缓存Key的值减少Value，并返回减少后的结果 支持设置最小的Value，避免减少后的值低于设置的最小值，执行失败则返回: -1 KeyExpire&lt;T&gt;、KeyExpireAsync&lt;T&gt;: 设置缓存Key的生命周期 以下方法不执行缓存Key格式化, 应传入缓存完整Key: Remove、RemoveAsync: 将指定的缓存Key (缓存Key集合) 从缓存中移除 Refresh、RefreshAsync: 刷新指定的缓存Key (缓存Key集合) 的生命周期 适用于未被删除、绝对过期时间没有到，但相对过期时间快到的缓存 Exists、ExistsAsync: 如果在缓存中找到，则返回true，否则返回false GetKeys、GetKeysAsync: 根据key pattern 得到符合规则的所有缓存Key 例: 传入User*，可得到缓存中以User开头的所有缓存Key KeyExpire、KeyExpireAsync: 设置缓存Key的生命周期 IMultilevelCacheClient (多级缓存客户端) Get&lt;T&gt;、GetAsync&lt;T&gt;: 根据缓存Key返回类型为T的结果 (如果缓存不存在，则返回Null) (支持监控缓存变更) GetList&lt;T&gt;、GetListAsync&lt;T&gt;: 根据缓存Key集合返回对应的缓存值的集合 (针对不存在的缓存key，其值返回Null) GetOrSet&lt;T&gt;、GetOrSetAsync&lt;T&gt;: 如果在缓存中找到，则返回类型为T的结果，如果缓存未找到，则执行Setter，并返回Setter的结果 Set&lt;T&gt;、SetAsync&lt;T&gt;: 将指定的缓存Key以及缓存值添加到缓存 SetList&lt;T&gt;、SetListAsync&lt;T&gt;: 将指定的缓存Key、Value集合添加缓存 Remove&lt;T&gt;、RemoveAsync&lt;T&gt;: 将指定的缓存Key (缓存Key集合) 从缓存中移除 Refresh&lt;T&gt;、RefreshAsync&lt;T&gt;: 刷新指定的缓存Key (缓存Key集合) 的生命周期 适用于未被删除、绝对过期时间没有到，但相对过期时间快到的缓存 (延长滑动过期时间) IDistributedCacheClientFactory (分布式缓存工厂) Create: 返回指定Name的分布式缓存客户端 IMultilevelCacheClientFactory (多级缓存工厂) Create: 返回指定Name的多级缓存客户端 如果Name为空字符串时，可直接使用IDistributedCacheClient或IMultilevelCacheClient, 默认注册不指定Name时，则其Name为空字符串，可不通过Factory创建 总结MASA Framework提供了分布式缓存以及多级缓存的实现，其中有几个优秀的功能： 多级缓存提供了缓存更新后同步更新内存缓存功能 当我们的服务是多副本时，不必担心会缓存更新后其它副本由于内存缓存未过期，导致获取到过期的缓存数据，大大提升我们的用户体验 支持滑动过期以及绝对过期混合使用 避免无用的缓存长时间被持久化，但对于热点数据又可以避免打到Redis或者数据库 配置支持热更新，配置更新后同步生效，无需重启项目 缓存Key支持格式化，可根据当前缓存值类型与传入缓存Key结合形成新的缓存Key，提高了开发效率以及代码可读性 比如获取用户id为1的数据，可通过Client.Get&lt;User&gt;(&quot;1&quot;)，而无需：Client.Get&lt;User&gt;(&quot;User.1&quot;) 本章源码Assignment16 https://github.com/zhenlei520/MasaFramework.Practice 开源地址MASA.Framework：https://github.com/masastack/MASA.Framework MASA.EShop：https://github.com/masalabs/MASA.EShop MASA.Blazor：https://github.com/BlazorComponent/MASA.Blazor 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们","link":"/2022/10/20/masa/framework/practice/16.%20%E7%BC%93%E5%AD%98%20-%20Caching/"},{"title":"17. MasaFramework -- 领域驱动设计","text":"概念什么是领域驱动设计 领域驱动的主要思想是, 利用确定的业务模型来指导业务与应用的设计和实现。主张开发人员与业务人员持续地沟通和模型的持续迭代，从而保证业务模型与代码的一致性，实现有效管理业务的复杂度，优化软件设计的目的 痛点基于领域驱动设计的模型有很多难点需要克服 统一认知 语言统一, 领域模型术语、DDD模式名称、技术专业术语、设计模式、业务术语等统一为大家都能认可且理解的名词, 避免在沟通中出现语言不统一, 从而出现高昂的沟通成本 开发人员应统一认知, 清晰应用服务、领域服务职责、明确聚合根、实体、值对象的基础概念 划分限界上下文、找到业务中的核心域、子域、支撑域、通用域 建立聚合根、实体、值对象，明确领域服务与对象的依赖关系 Masa Framework框架提供了基础设施使得基于领域驱动设计的开发更容易实现, 但它并不能教会你什么是DDD, 这些概念知识需要我们自己去学习、理解 功能科普为了方便更好的理解, 下面会先说说关于领域驱动设计的包以及功能职责 Masa.BuildingBlocks.Ddd.Domain提供了DDD中一些接口以及实现, 它们分别是: Entity (实体) 接口规范、实体实现 未指定主键类型的实体需要通过重写GetKeys方法来指定主键, 聚合根支持添加领域事件 (并在EventBus的Handler执行完成后执行) 小窍门: 继承以AggregateRoot结尾的类是聚合根、继承以Entity结尾的类是实体 Event (事件) 接口 领域事件是由聚合根或者领域服务发出的事件, 其中根据事件类型又可以分为本地事件 (DomainEvent)、集成事件 (IntegrationDomainEvent), 而本地事件根据读写性质不同划分为DomainCommand、DomainQuery IDomainEventBus (领域事件总线)被用于发布领域事件, 支持发布本地事件和集成事件, 同时它还支持事件的压栈发送, 压栈发送的时间将在 UnitOfWork(工作单元) 提交后依次发送 Repository (仓储) 接口、仓储基类实现 屏蔽业务逻辑和持久化基础设施的差异, 针对不同的存储设施, 会有不同的实现方式, 但这些不会对我们的业务产生影响, 作为开发者只需要根据实际情况使用对应的依赖包即可, 与 DAO (数据访问对象)略有不同, DAO是数据访问技术的抽象, 而Repository是领域驱动设计的一部分, 我们仅会提供针对聚合根做简单的增删改查操作, 而并非针对单个表 由于一些特殊的原因, 我们解除了对非聚合根的限制, 使得它们也可以使用IRepository, 但这个是错误的, 后续版本仍然会增加限制, 届时IRepository将只允许对聚合根进行操作 Enumeration (枚举类) 提供枚举类基类, 使用枚举类来代替使用枚举, 查看原因 Services 服务 领域服务是领域模型的操作者, 被用来处理业务逻辑, 它是无状态的, 状态由领域对象来保存, 提供面向应用层的服务, 完成封装领域知识, 供应用层使用。与应用服务不同的是, 应用服务仅负责编排和转发, 它将要实现的功能委托给一个或多个领域对象来实现, 它本身只负责处理业务用例的执行顺序以及结果的拼装, 在应用服务中不应该包含业务逻辑 继承IDomainService的类被标记为领域服务, 领域服务支持从DI获取, 其中提供了EventBus (用于提供发送领域事件) Values: 值对象 继承ValueObject的类被标记为值对象。值对象没有唯一标识, 任何属性的变化都视为新的值对象 在项目开发中, 我们可以通过模型映射将值对象映射存储到单独的表中也可以映射为一个json字符串存储又或者根据属性拆分为多列使用, 这些都是可以的, 但无论数据是以什么方式存储, 它们是值对象这点不会改变, 因此我们不能错误的理解为在数据库中的表一定是实体或者聚合根, 这种想法是错误的 Masa.BuildingBlocks.Data.UoW提供工作单元接口标准, 工作单元管理者, 确保Repository的操作可以在同一个工作单元下的一致性 (全部成功或者全部失败) 功能与对应的nuget包 Masa.Contrib.Ddd.Domain: 领域驱动设计 Masa.Contrib.Data.EFCore.SqlServer: 基于EFCore的实现 Masa.Contrib.Ddd.Domain.Repository.EFCore: 提供仓储的默认实现 Masa.Contrib.Development.DaprStarter.AspNetCore: 协助管理Dapr Sidecar, 运行dapr Masa.Contrib.Dispatcher.Events.FluentValidation: 提供基于FluentValidation的中间件, 为事件提供参数验证的功能 (后续与MasaBlazor对接后参数错误提示更友好, 而不是简单的Toast) Masa.Contrib.Dispatcher.Events: 本地事件总线实现 Masa.Contrib.Dispatcher.IntegrationEvents.Dapr: 基于dapr的集成事件实现 Masa.Contrib.Dispatcher.IntegrationEvents.EventLogs.EFCore: 为集成事件提供发件箱模式支持 Masa.Contrib.Data.UoW.EFCore: 提供工作单元实现 FluentValidation.AspNetCore: 提供基于FluentValidation的参数验证 FluentValidation.AspNetCore: 提供基于FluentValidation的参数验证 入门我们先简单了解一下下单的流程, 如下图所示 其中事务中间件 (默认提供) 与验证中间件是公共代码, 进程内事件发布后都会执行, 但事务中间件不支持嵌套 通过Ddd设计下单设计到的代码过多, 下面代码只会展示重要部分, 不会逐步讲解, 希望大家谅解, 有不理解的加群或者评论探讨 安装.NET 6.0 分别创建Assignment17.Ordering.API (订单服务, ASP.NET Core Web项目)、Assignment17.Ordering.Domain (订单领域, 类库)、Assignment17.Ordering.Infrastructure (订单基础设施, 类库) 注册DomainEventBus (领域事件总线), EventBus (事件总线), IntegrationEventBus (集成事件总线), 并注册Repository (仓储), IUnitOfWork (工作单元) 12345678910builder.Services .AddValidatorsFromAssembly(Assembly.GetEntryAssembly())//提供基于FluentValidation的参数验证 .AddDomainEventBus(assemblies.Distinct().ToArray(), options =&gt; { options .UseIntegrationEventBus(dispatcherOptions =&gt; dispatcherOptions.UseDapr().UseEventLog&lt;OrderingContext&gt;()) .UseEventBus(eventBuilder =&gt; eventBuilder.UseMiddleware(typeof(ValidatorMiddleware&lt;&gt;))) .UseUoW&lt;OrderingContext&gt;(dbContextBuilder =&gt; dbContextBuilder.UseSqlServer()) .UseRepository&lt;OrderingContext&gt;(); }); 在Program.cs中注册DaprStarter 12345678if (builder.Environment.IsDevelopment()){ builder.Services.AddDaprStarter(options =&gt; { options.DaprGrpcPort = 3000; options.DaprGrpcPort = 3001; });} 如果不使用Dapr, 则可以不注册DaprStarter Dapr订阅集成事件 1234567app.UseRouting();app.UseCloudEvents();app.UseEndpoints(endpoints =&gt;{ endpoints.MapSubscribeHandler();}); 下单参数验证 为下单提供参数验证, 确保进入应用服务Handler的请求参数是合法有效的 12345678910public class CreateOrderCommandValidator: AbstractValidator&lt;CreateOrderCommand&gt;{ public CreateOrderCommandValidator() { RuleFor(o =&gt; o.Country).NotNull().WithMessage(&quot;收件人信息有误&quot;); RuleFor(o =&gt; o.City).NotNull().WithMessage(&quot;收件人信息有误&quot;); RuleFor(o =&gt; o.Street).NotNull().WithMessage(&quot;收件人信息有误&quot;); RuleFor(o =&gt; o.ZipCode).NotNull().WithMessage(&quot;收件人邮政编码信息有误&quot;); }} 参数验证无需手动触发, 框架会根据传入ValidatorMiddleware自动触发 下单Handler 12345678910111213141516171819202122232425262728public class OrderCommandHandler{ private readonly IOrderRepository _orderRepository; private readonly ILogger&lt;OrderCommandHandler&gt; _logger; public OrderCommandHandler(IOrderRepository orderRepository, ILogger&lt;OrderCommandHandler&gt; logger) { _orderRepository = orderRepository; _logger = logger; } [EventHandler] public async Task CreateOrderCommandHandler(CreateOrderCommand message, CancellationToken cancellationToken) { var address = new Address(message.Street, message.City, message.State, message.Country, message.ZipCode); var order = new Order(message.UserId, message.UserName, address, message.CardTypeId, message.CardNumber, message.CardSecurityNumber, message.CardHolderName, message.CardExpiration); foreach (var item in message.OrderItems) { order.AddOrderItem(item.ProductId, item.ProductName, item.UnitPrice, item.Discount, item.PictureUrl, item.Units); } _logger.LogInformation(&quot;----- Creating Order - Order: {@Order}&quot;, order); await _orderRepository.AddAsync(order, cancellationToken); }} 下单时聚合根发布订单状态变更事件 1234567891011121314151617181920212223242526272829303132333435363738public Order(string userId, string userName, Address address, int cardTypeId, string cardNumber, string cardSecurityNumber, string cardHolderName, DateTime cardExpiration, int? buyerId = null, int? paymentMethodId = null) : this(){ _buyerId = buyerId; _paymentMethodId = paymentMethodId; _orderStatusId = OrderStatus.Submitted.Id; _orderDate = DateTime.UtcNow; Address = address; AddOrderStartedDomainEvent(userId, userName, cardTypeId, cardNumber, cardSecurityNumber, cardHolderName, cardExpiration);}private void AddOrderStartedDomainEvent(string userId, string userName, int cardTypeId, string cardNumber, string cardSecurityNumber, string cardHolderName, DateTime cardExpiration){ var orderStartedDomainEvent = new OrderStartedDomainEvent(this, userId, userName, cardTypeId, cardNumber, cardSecurityNumber, cardHolderName, cardExpiration); this.AddDomainEvent(orderStartedDomainEvent);}/// &lt;summary&gt;/// Event used when an order is created/// &lt;/summary&gt;public record OrderStartedDomainEvent(Order Order, string UserId, string UserName, int CardTypeId, string CardNumber, string CardSecurityNumber, string CardHolderName, DateTime CardExpiration) : DomainEvent; 订单状态变更领域事件Handler 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class BuyerHandler{ private readonly IBuyerRepository _buyerRepository; private readonly IIntegrationEventBus _integrationEventBus; private readonly ILogger&lt;BuyerHandler&gt; _logger; public BuyerHandler(IBuyerRepository buyerRepository, IIntegrationEventBus integrationEventBus, ILogger&lt;BuyerHandler&gt; logger) { _buyerRepository = buyerRepository; _integrationEventBus = integrationEventBus; _logger = logger; } [EventHandler] public async Task ValidateOrAddBuyerAggregateWhenOrderStarted(OrderStartedDomainEvent orderStartedEvent) { var cardTypeId = (orderStartedEvent.CardTypeId != 0) ? orderStartedEvent.CardTypeId : 1; var buyer = await _buyerRepository.FindAsync(orderStartedEvent.UserId); bool buyerOriginallyExisted = buyer != null; if (!buyerOriginallyExisted) { buyer = new Buyer(orderStartedEvent.UserId, orderStartedEvent.UserName); } buyer!.VerifyOrAddPaymentMethod(cardTypeId, $&quot;Payment Method on {DateTime.UtcNow}&quot;, orderStartedEvent.CardNumber, orderStartedEvent.CardSecurityNumber, orderStartedEvent.CardHolderName, orderStartedEvent.CardExpiration, orderStartedEvent.Order.Id); var buyerUpdated = buyerOriginallyExisted ? _buyerRepository.Update(buyer) : _buyerRepository.Add(buyer); var orderStatusChangedToSubmittedIntegrationEvent = new OrderStatusChangedToSubmittedIntegrationEvent( orderStartedEvent.Order.Id, orderStartedEvent.Order.OrderStatus.Name, buyer.Name); await _integrationEventBus.PublishAsync(orderStatusChangedToSubmittedIntegrationEvent); _logger.LogTrace(&quot;Buyer {BuyerId} and related payment method were validated or updated for orderId: {OrderId}.&quot;, buyerUpdated.Id, orderStartedEvent.Order.Id); }} 订阅订单状态更改为已提交集成事件, 修改Program.cs 123456app.MapPost(&quot;/integrationEvent/OrderStatusChangedToSubmitted&quot;, [Topic(&quot;pubsub&quot;, nameof(OrderStatusChangedToSubmittedIntegrationEvent))] (ILogger&lt;Program&gt; logger, OrderStatusChangedToSubmittedIntegrationEvent @event) =&gt; { logger.LogInformation(&quot;接收到订单提交事件, {Order}&quot;, @event); }); 最终的项目结构: 下单的核心逻辑来自于eShopOnContainers, 属于简化版的下单, 通过它大家可以更快的理解如何借助Masa Framework, 方便快捷的设计出基于领域驱动设计的业务系统 参考 MASA Framework - DDD设计(1) MASA Framework - DDD设计(2) DDD 概念参考 DAO与Repository有什么区别 本章源码Assignment17 https://github.com/zhenlei520/MasaFramework.Practice 开源地址MASA.Framework：https://github.com/masastack/MASA.Framework MASA.EShop：https://github.com/masalabs/MASA.EShop MASA.Blazor：https://github.com/BlazorComponent/MASA.Blazor 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们","link":"/2022/11/28/masa/framework/practice/17.%20MasaFramework%20--%20%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"},{"title":"18. i18n","text":"概念作为一个普通开发者, 我们负责的项目的使用群体大多数是本国的人民, 但不可避免的也有一些做外贸的业务或者给外企做的项目, 这个时候就要求我们的项目有服务全球客户的能力, 而一个支持国际化能力的框架会让我们项目的体验变得更好. 关于本地化我们听到最多的是I18N (国际化)、L10N (本地化)、G11N (全球化), 那它们分别代表了什么意思呢？ 国际化: 使产品或软件具有不同国际市场的普遍适应性, 从而无需重新设计就可适应多种语言和文化习俗 本地化: 将产品或软件针对特定国际语言和文化进行加工, 使之符合特定区域市场. 全球化: 是指在产品的业务拓展到世界上其他地方的过程, 可以简单理解为: 全球化 = “国际化” + “本地化” MasaFramework提供的国际化能力使得我们可以通过修改资源获得不同区域的内容, 而不必要修改源码, 除此之外, 在框架中使用的时间也是UTC时间, 不管项目被应用到哪个地区, 只需要做一次UTC时间向本地时间的转换即可, 为项目以后的本地化奠定了基础 使用 安装.NET 6.0 新建ASP.NET Core 空项目Assignment.I18nDemo，并安装Masa.Contrib.Globalization.I18n.AspNetCore 1dotnet add package Masa.Contrib.Globalization.I18n.AspNetCore --version 0.7.0-preview.16 注册I18n, 并修改Program.cs 1builder.Services.AddI18n(); 使用I18N 1app.UseI18n();//启用中间件, 完成对请求的解析并为当前请求设置区域 添加多语言资源文件, 文件夹结构如下: 12345- Resources - I18n - en-US.json - zh-CN.json - supportedCultures.json en-US.json 123{ &quot;Home&quot;:&quot;Home&quot;} zh-CN.json 123{ &quot;Home&quot;:&quot;首页&quot;} supportedCultures.json 123456789101112[ { &quot;Culture&quot;:&quot;zh-CN&quot;, &quot;DisplayName&quot;:&quot;中文简体&quot;, &quot;Icon&quot;: &quot;{Replace-Your-Icon}&quot; }, { &quot;Culture&quot;:&quot;en-US&quot;, &quot;DisplayName&quot;:&quot;English (United States)&quot;, &quot;Icon&quot;: &quot;{Replace-Your-Icon}&quot; }] 使用I18n 1app.Map(&quot;/test&quot;, (string key) =&gt; I18n.T(key)); 测试多语言, 在浏览器访问 “https://localhost:7082/get?key=Home&quot; 即可得到对应语言下键名为Home的值 是不是感觉用起来十分简单呢, 但这究竟是如何做的呢 进阶国内的小伙伴根据上面的例子操作下来, 会发现请求响应的内容是中文, 那什么情况下它会变成英文呢？ I18n中间件这里我们借助了微软提供的本地化的中间件的能力, 通过它使得我们的项目具备解析当前语言的能力, 如果希望自定义规则也可以自己按照自己的规则去解析请求并设置区域 目前它支持了以下三种方式进行语言切换: URL 参数 方式： ?culture=en-US，此方式优先级最高，格式为：culture=区域码 Cookies 方式：cookie 格式为 c=%LANGCODE%|uic=%LANGCODE%，其中 c 是 Culture，uic 是 UICulture, 例如: 1c=en-UK|uic=en-US 客户端浏览器语言自动匹配：如果前面两种方式都没有设置，支持自动根据客户端浏览器语言进行匹配 如果当前请求的语言是不支持的, 则使用默认语言, 其中语言优先级为: URL 参数 方式 &gt; Cookies方式 &gt; 客户端语言 &gt; 默认语言 默认语言默认语言有两种配置方式, 它们分别是: 手动指定默认语言 通过app.UseI18n(&quot;{Replace-Your-DefaultCulture}&quot;) 约定配置 supportedCultures.json文件中的第一个语言 它们的优先级是: 手动指定默认语言 &gt; 约定配置 修改默认资源路径123456789builder.Services.AddI18n(options =&gt;{ options.ResourcesDirectory = Path.Combine(&quot;Resources&quot;, &quot;I18n&quot;);//修改默认资源路径 options.SupportedCultures = new List&lt;CultureModel&gt;() //支持语言 { new(&quot;zh-CN&quot;), new(&quot;en-US&quot;) };}); 支持资源文件如果你希望将配置文件嵌入到dll文件中, 不希望被看到修改, 那么你需要将资源json文件的生成操作改为嵌入的资源 (EmbeddedResource), 并修改I18N注册代码为: 1builder.Services.AddI18nByEmbedded(); 嵌套配置相信了解前端开发的小伙伴也见到过嵌套的资源配置, 那对于Masa提供的多语言方案而言, 我们也支持这种格式的配置, 例如: 123456{ &quot;Home&quot;:&quot;首页&quot;, &quot;User&quot;:{ &quot;Name&quot;:&quot;名称&quot; }} 我们希望拿到User节点下的Name属性的值, 则可以通过: 1var result = I18N.T(&quot;User.Name&quot;);//其中key的值不区分大小写 当然除此之外, 我们也可以将不同资源的文件分开存放到不同的json文件, 然后通过添加多个资源目录的文件, 最终实现, 但在使用时稍微有区别: 1app.Map(&quot;/test2&quot;, (string key, II18n&lt;CustomResource&gt; i18n) =&gt; i18n.T(key));//通过DI获取到自定义资源下Key对应内容 如何对接远程资源配置多语言的远程资源配置目前仅支持DCC, 我们可以这样做: 注册MasaConfiguration并使用DCC, 修改Program.cs 1234builder.Services.AddMasaConfiguration(configurationBuilder =&gt;{ configurationBuilder.UseDcc();}); 配置DCC配置信息, 修改appsettings.json 123456789101112131415{ &quot;DccOptions&quot;: { &quot;ManageServiceAddress&quot;: &quot;{Replace-Your-DccManagerServiceHost}&quot;, &quot;RedisOptions&quot;: { &quot;Servers&quot;: [ { &quot;Host&quot;: &quot;{Replace-Your-DccUseRedisHost}&quot;, &quot;Port&quot;: 6379 } ], &quot;DefaultDatabase&quot;: 0, &quot;Password&quot;: &quot;&quot; } }} 对MasaConfiguration有疑问点这里 注册I18n 1234builder.Services.AddI18n( Path.Combine(&quot;Resources&quot;, &quot;I18n&quot;), &quot;supportedCultures.json&quot;, options =&gt; options.UseDcc()); 我们仅需要在/Resources/I18n目录下存放支持语言的配置即可, 具体的语言配置将从DCC读取 (读取DCC语言的配置节点: 在DCC配置下默认AppId下的”Culture.{语言}”), 例如: 如果支持语言为zh-CN、en-US, 则默认读取DCC配置下默认AppId下Culture.zh-CN、Culture.en-Us两个配置对象的值, 我们仅需要修改它们的值即可, 并且如果对应的内容发生更改, 项目无需重启即可完成自动更新 如何管理对象 源码解读在MasaFramework中, 抽象了多语言的能力, 它提供了 string this[string name]: 获取指定name的值 (如果name不存在, 则返回name的值) string? this[string name, bool returnKey]: 获取指定name的值 (如果returnKey为false, 且name不存在, 则返回null) string this[string name, params object[] arguments]: 获取指定name的值, 并根据文化、输入参数格式化响应信息返回 (如果name不存在, 则返回name的值) string? this[string name, bool returnKey, params object[] arguments]: 获取指定name的值, 并根据文化、输入参数格式化响应信息返回 (如果returnKey为false, 且name不存在, 则返回null) string T(string name): 获取指定name的值, 如果name不存在, 则返回name的值 string? T(string name, bool returnKey): 获取指定name的值 (如果returnKey为false, 且name不存在, 则返回null) string T(string name, params object[] arguments): 获取指定name的值, 并根据文化、输入参数格式化响应信息返回 (如果name不存在, 则返回name的值) string? T(string name, bool returnKey, params object[] arguments): 获取指定name的值, 并根据文化、输入参数格式化响应信息返回 (如果returnKey为false, 且name不存在, 则返回null) CultureInfo GetCultureInfo(): 获取当前线程的区域性 (被用于需要格式化响应信息的方法) void SetCulture(string cultureName, bool useUserOverride = true): 设置当前线程的区域性 void SetCulture(CultureInfo culture): 设置当前线程的区域性 CultureInfo GetUiCultureInfo(): 获取资源管理器使用的当前区域性以便在运行时查找区域性特定的资源 void SetUiCulture(string cultureName, bool useUserOverride = true): 设置资源管理器使用的当前区域性以便在运行时查找区域性特定的资源 void SetUiCulture(CultureInfo culture): 设置资源管理器使用的当前区域性以便在运行时查找区域性特定的资源 我们可以通过DI获取到II18n进而来使用它提供的这些能力, 当然它使用的是资源类型为DefaultResource的资源 (在服务注册时所指向的资源 services.AddI18n()), 除此之外, 我们也可以通过DI获取到II18n&lt;DefaultResource&gt;来使用, 也可以通过I18n(全局静态类)来使用它提供的能力, 但是如果你使用了自定义资源类型, 则只能通过DI获取II18n&lt;{Replace-Your-ResourceType}&gt;来使用. 除此之外, 我们还提供了支持的语言列表的能力, 它被抽象在ILanguageProvider IReadOnlyList GetLanguages(): 获取支持语言集合 我们可以通过DI获取ILanguageProvider来使用, 也可以通过I18n.GetLanguages()来使用 总结当然, MasaFramework绝不仅仅只是提供了这么简单的多语言的能力, 目前全局异常、Caller也已经支持了多语言, 其它模块也在逐步完善多语言支持, 等之后框架的错误信息也将会支持多语言, 我们的开发体验也将会变得更加友好, 但这只是为我们项目的本地化提供了可能, 绝不意味着这么简单就完成了本地化, 在项目中我们还需要针对不同区域定制部分功能, 以便让它更符合规定, 以便于让不同地区的人接受它, 最好的本地化就是产品或讯息与特定目标文化产生共鸣的过程，就如同内容是在当地创建的一样, 但这个是一件知易行难的事 参考 本地化与国际化有什么关系？ 为什么本地化对企业而言非常重要? 本地化、全球化和国际化：区别何在？ 本章源码Assignment18 https://github.com/zhenlei520/MasaFramework.Practice 开源地址MASA.Framework：https://github.com/masastack/MASA.Framework MASA.EShop：https://github.com/masalabs/MASA.EShop MASA.Blazor：https://github.com/BlazorComponent/MASA.Blazor 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们","link":"/2022/12/21/masa/framework/practice/18.%20i18n/"},{"title":"2. Caller服务调用 - HttpClient","text":"前言绝大多数项目都离不开服务调用，服务的调用方式通常是基于Http、RPC协议的调用，需要获取到对应服务的域名或者ip地址以及详细的控制器方法后才能进行调用，如果项目需要支持分布式部署，则需要借助服务发现或者Nginx才能实现。 但随着Dapr的崛起，服务的调用方式也发生了变化，它不仅仅提供了处理重试和瞬态错误等功能，还内置服务发现，启用dapr的服务仅需知道任意一个启用dapr服务的HttpPort端口、gRpc端口、以及对应服务的appid以及对应的方法名称就可以完成调用，dapr的出现使得服务间调用变得更为的简单、方便 目前我们有一个项目是Dapr的，但它所依赖的另外一个项目是基于Http协议的调用，目前只能使用HttpClient或RestSharp实现服务间的调用，但未来有一天它会使用Dapr，因为我们计划会把所有的项目都逐步升级到Dapr上 什么是Masa.Utils.Caller？Masa的Caller是一个用于服务调用的类库，它提供了以下能力： 基础Http请求的能力，包括Get、Post、Put、Delete等 GetAsync GetStringAsync: 得到响应信息为字符串类型的Get请求 GetByteArrayAsync: 得到响应信息为字节数组的Get请求 GetStreamAsync: 得到响应信息为流的Get请求 GetAsync: 得到响应信息支持泛型类型的Get请求 PostAsync PatchAsync PutAsync DeleteAsync SendGrpcAsync (Caller.HttpClient暂不支持) SendAsync 降低了不同的部署方式对业务代码的影响，对于前期不使用Dapr，后期更改为通过Dapr调用，只需修改少量代码即可 当请求方法发生异常后，会继续抛出异常，服务的调用变得像方法调用一样简单，对开发者友好，当然你也可以选择返回HttpResponseMessage自行解析 检查请求响应的StatusCode的值来判断当前请求是否成功，具体代码可查看 目前Caller支持了两种实现方式： 基于HttpClient的实现: Masa.Contrib.Service.Caller.HttpClient 基于DaprClient的实现: Masa.Contrib.Service.Caller.DaprClient 下面就让我们先看一下HttpClient版的Caller Caller.HttpClient 入门下面我们会写一个简单的Demo，作为入门教程，为大家讲解一下Get请求与Post请求的使用办法 在开始之前，我们先明确我们的目的以及打算如何做？ 目标：通过Caller.HttpClient让大家理解Masa提供的Caller如何实现服务调用（请求） 如何做：分别创建两个Asp.Net Core空的Web服务，一个作为服务端（被调用方），一个作为客户端（调用方），在服务端写两个方法，分别是Get请求（获取用户信息）、Post请求（创建用户）的方法，在客户端同样创建两个对应的方法用来测试获取用户请求、创建用户请求能否正常运行 准备工作 安装.Net 6.0 创建ASP.NET Core 空项目Assignment.Server作为服务端，并修改Program.cs 1234567891011121314151617181920212223242526272829using Microsoft.AspNetCore.Mvc;var builder = WebApplication.CreateBuilder(args);var app = builder.Build();app.MapGet(&quot;/&quot;, () =&gt; &quot;Hello Assignment.Server!&quot;);app.MapGet(&quot;/User&quot;, ([FromQuery] int id) =&gt;{ //todo: 模拟根据id查询用户信息 return new { Id = id, Name = &quot;John Doe&quot; };});app.MapPost(&quot;/User&quot;, ([FromBody] AddUserRequest request) =&gt;{ //todo: 模拟添加用户，并返回用户名称 return request.Name;});app.Run();public class AddUserRequest{ public string Name { get; set; }} 创建ASP.NET Core 空项目Assignment.Client.HttpClientWeb作为客户端 选中Assignment.Client.HttpClientWeb并安装Masa.Contrib.Service.Caller.HttpClient 1dotnet add package Masa.Contrib.Service.Caller.HttpClient --version 0.7.0-preview.12 修改Program.cs 12345678910111213141516171819202122232425262728293031323334353637383940414243using System.Globalization;using Masa.Utils.Caller.Core;using Masa.Contrib.Service.Caller.HttpClient;using Microsoft.AspNetCore.Mvc;var builder = WebApplication.CreateBuilder(args);builder.Services.AddCaller(option =&gt;{ option.UseHttpClient(opt =&gt; { opt.BaseApi = &quot;http://localhost:5000&quot;; opt.Name = &quot;userCaller&quot;; // 当前Caller的别名(仅有一个Caller时可以不填)，Name不能重复 opt.IsDefault = true; // 默认的Caller支持注入ICallerProvider获取 });});var app = builder.Build();app.MapGet(&quot;/&quot;, () =&gt; &quot;Hello HttpClientWeb.V1!&quot;);app.MapGet(&quot;/Test/User/Get&quot;, async ([FromServices] ICaller caller) =&gt;{ var user = await caller.GetAsync&lt;object, UserDto&gt;(&quot;User&quot;, new { id = new Random().Next(1, 10) }); return $&quot;获取用户信息成功：用户名称为：{user!.Name}&quot;;});app.MapGet(&quot;/Test/User/Add&quot;, async ([FromServices] ICaller caller) =&gt;{ var dateTimeOffset = new DateTimeOffset(DateTime.UtcNow); string timeSpan = dateTimeOffset.ToUnixTimeSeconds().ToString(); var userName = &quot;ss_&quot; + timeSpan; //模拟一个用户名 string? response = await caller.PostAsync&lt;object, string&gt;(&quot;User&quot;, new { Name = userName }); return $&quot;创建用户成功了，用户名称为：{response}&quot;;});app.Run();public class UserDto{ public int Id { get; set; } public string Name { get; set; } = default!;} -&gt; &gt; Q:为什么BaseApi的地址是http://localhost:5000 A:因为服务端项目的地址是http://localhost:5000，根据实际情况替换成你自己的服务端项目地址 现在Caller的HttpClient版本就可以使用了，分别启动Assignment.Server、Assignment.Client.HttpClientWeb服务，浏览器访问http://localhost:5107/Test/User/Get、http://localhost:5107/Test/User/Add，分别输出对应的获取用户信息成功以及创建用户成功的提示，则证明调用成功了。 搞笑对话： HttpClient 进阶版随着与工程师经理的一番切磋后发现了上述代码仅是基础版的，更贴合传统的HttpClient的写法，与默认的HttpClient有异曲同工之妙，但并不是只能这样写，下面就来看看新的写法： 创建ASP.NET Core 空项目Assignment.Client.HttpClientWeb.V2作为调用方V2版本 选中Assignment.Client.HttpClientWeb.V2并安装Masa.Contrib.Service.Caller.HttpClient 1dotnet add package Masa.Contrib.Service.Caller.HttpClient --version 0.7.0-preview.12 添加类ServerCaller (对应服务端服务) 12345678910111213141516171819202122232425262728293031323334namespace Assignment.Client.HttpClientWeb.V2;public class ServerCaller : HttpClientCallerBase{ protected override string BaseAddress { get; set; } = &quot;http://localhost:5000&quot;; public ServerCaller(IServiceProvider serviceProvider) : base(serviceProvider) { } /// &lt;summary&gt; /// 调用服务获取用户信息 （重点） /// &lt;/summary&gt; /// &lt;param name=&quot;id&quot;&gt;用户id&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public Task&lt;UserDto?&gt; GetUserAsync(int id) =&gt; Caller.GetAsync&lt;object, UserDto&gt;(&quot;User&quot;, new { id = id }); /// &lt;summary&gt; /// 调用服务添加用户（重点） /// &lt;/summary&gt; /// &lt;param name=&quot;userName&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public Task&lt;string?&gt; AddUserAsync(string userName) =&gt; Caller.PostAsync&lt;object, string&gt;(&quot;User&quot;, new { Name = userName });}public class UserDto{ public int Id { get; set; } public string Name { get; set; } = default!;} 修改Program.cs 1234567891011121314151617181920212223242526272829using System.Globalization;using Assignment.Client.HttpClientWeb.V2;using Microsoft.AspNetCore.Mvc;var builder = WebApplication.CreateBuilder(args);builder.Services.AddCaller();var app = builder.Build();app.MapGet(&quot;/&quot;, () =&gt; &quot;Hello HttpClientWeb.V2!&quot;);// 重点：直接注入对应的ServiceCaller，调用对应的方法即可app.MapGet(&quot;/Test/User/Get&quot;, async ([FromServices] ServerCaller serverCaller) =&gt;{ var id = new Random().Next(1, 10);//默认用户id var user = await serverCaller.GetUserAsync(id); return $&quot;获取用户信息成功：用户名称为：{user!.Name}&quot;;});app.MapGet(&quot;/Test/User/Add&quot;, async ([FromServices] ServerCaller serverCaller) =&gt;{ var dateTimeOffset = new DateTimeOffset(DateTime.UtcNow); string timeSpan = dateTimeOffset.ToUnixTimeSeconds().ToString(); var userName = &quot;ss_&quot; + timeSpan; //模拟一个用户名 string? response= await serverCaller.AddUserAsync(userName); return $&quot;创建用户成功了，用户名称为：{response}&quot;;});app.Run(); 最后，分别启动Assignment.Server、Assignment.Client.HttpClientWeb.V2服务，浏览器访问http://localhost:5188/Test/User/Get、http://localhost:5188/Test/User/Add，分别输出对应的获取用户信息成功以及创建用户成功的提示，则证明调用成功了。 这个版本的Caller很不错，调用请求变成了跟调用方法一样，简单明了，很不错 不过ServerCaller下面好像是同一个服务的方法，如果我这个服务方法特别多的话，那这个类岂不是特别庞大，但如果我要拆分成好几个的话，那BaseAddress我岂不是需要复制很多份 ʅ( T﹏T )ʃ HttpClient 推荐让请求调用更简单，让你的代码更简洁 在V2版本的基础上添加类ServerCallerBase 123456789namespace Assignment.Client.HttpClientWeb.V3;/// &lt;summary&gt;/// 注意：ServerCallerBase是抽象类哟/// &lt;/summary&gt;public abstract class ServerCallerBase: HttpClientCallerBase{ protected override string BaseAddress { get; set; } = &quot;http://localhost:5000&quot;;} ServerCallerBase可以以服务拆分，每个服务建一个'ServerCallerBase' 调整ServerCaller.cs重命名为UserCaller.cs，然后删除重写BaseAddress属性： 12345678910111213141516171819202122232425262728namespace Assignment.Client.HttpClientWeb.V3;public class UserCaller : ServerCallerBase{ // protected override string BaseAddress { get; set; } = &quot;http://localhost:5000&quot;; //注意：父类已经实现，无需重写，所以被删除了 /// &lt;summary&gt; /// 调用服务获取用户信息 /// &lt;/summary&gt; /// &lt;param name=&quot;id&quot;&gt;用户id&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public Task&lt;UserDto?&gt; GetUserAsync(int id) =&gt; Caller.GetAsync&lt;object, UserDto&gt;(&quot;User&quot;, new { id = id }); /// &lt;summary&gt; /// 调用服务添加用户 /// &lt;/summary&gt; /// &lt;param name=&quot;userName&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public Task&lt;string?&gt; AddUserAsync(string userName) =&gt; Caller.PostAsync&lt;object, string&gt;(&quot;User&quot;, new { Name = userName });}public class UserDto{ public int Id { get; set; } public string Name { get; set; } = default!;} 修改Program.cs，将ServerCaller修改为UserCaller即可 123456789101112131415app.MapGet(&quot;/Test/User/Get&quot;, async ([FromServices] UserCaller caller) =&gt;{ var id = new Random().Next(1, 10);//默认用户id var user = await caller.GetUserAsync(id); return $&quot;获取用户信息成功：用户名称为：{user!.Name}&quot;;});app.MapGet(&quot;/Test/User/Add&quot;, async ([FromServices] UserCaller caller) =&gt;{ var dateTimeOffset = new DateTimeOffset(DateTime.UtcNow); string timeSpan = dateTimeOffset.ToUnixTimeSeconds().ToString(); var userName = &quot;ss_&quot; + timeSpan; //模拟一个用户名 string? response= await caller.AddUserAsync(userName); return $&quot;创建用户成功了，用户名称为：{response}&quot;;}); 其余代码不变，就形成了V3版本，V3版本与V2版本相比，减少了多次对BaseAddress的赋值、使得代码更加简洁，按照控制器结构建立对应的Caller，让服务调用像方法调用一样简单明了 最后，分别启动Assignment.Server、Assignment.Client.HttpClientWeb.V3服务，浏览器访问http://localhost:5201/Test/User/Get、http://localhost:5201/Test/User/Add，分别输出对应的获取用户信息成功以及创建用户成功的提示，则证明调用成功了。 本章源码Assignment02 https://github.com/zhenlei520/MasaFramework.Practice 开源地址MASA.Framework：https://github.com/masastack/MASA.Framework MASA.EShop：https://github.com/masalabs/MASA.EShop MASA.Blazor：https://github.com/BlazorComponent/MASA.Blazor 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们","link":"/2022/05/07/masa/framework/practice/2.%20Caller%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%20-%20HttpClient/"},{"title":"3. Caller 服务调用 - dapr","text":"前言上一篇我们讲了使用HttpClient的方式调用，那么如果我们现在需要更换为通过dapr实现服务调用，我们需要做哪些事情呢？ Caller.Dapr 入门如果我们的项目原本使用的是Caller.HttpClient，现在希望改为使用Caller.Dapr，那么我们需要做什么呢？ 改造Caller 服务调用 - HttpClient的中的服务端，使得服务端支持dapr调用 调整客户端代码，使客户端支持通过dapr来做到服务调用，并达到与HttpClient调用相同的结果 准备工作 安装.Net 6.0 创建ASP.NET Core 空白解决方案Assignment03 将Assignment02文件夹下的Assignment.Server复制到Assignment03的文件夹下，然后将项目Assignment.Server添加到解决方案Assignment03中 选中Assignment.Server并安装Masa.Contrib.Development.DaprStarter.AspNetCore 1dotnet add package Masa.Contrib.Development.DaprStarter.AspNetCore --version 0.7.0-preview.12 修改Assignment.Server项目下的Program.cs 123456789101112131415//忽略命名空间引用var builder = WebApplication.CreateBuilder(args);// 添加DaprStarter，用于服务端启动dapr sidecar，改造服务端支持dapr调用的重点（建议在开发环境下使用，线上环境使用k8s部署）builder.Services.AddDaprStarter(option =&gt;{ option.AppId = &quot;Assignment-Server&quot;; option.DaprGrpcPort = 7007; option.DaprHttpPort = 7008; option.AppIdSuffix = string.Empty;});var app = builder.Build();/// 忽略路由等 Q: 什么是DaprStarter？为什么要使用DaprStarter？A: DaprStarter是Masa团队开发出来用于管理Dapr sidecar的包，可以帮助我们在开发环境下很简单的使用dapr sidecar Q: 为什么要指定AppId、DaprGrpcPort、DaprHttpPort等信息？A: 客户端调用需要得到Dapr的AppId、设置DaprGrpcPort、DaprHttpPort是因为客户端演示项目没有使用dapr sidecar，如果客户端项目也使用dapr sidecar，此处可以不指定DaprGrpcPort、DaprHttpPort，更多信息请参考[文章](https://www.cnblogs. com/zhenlei520/p/16157625.html) 创建ASP.NET Core 空项目Assignment.Client.DaprClientWeb作为客户端并安装Masa.Contrib.Service.Caller.DaprClient 1dotnet add package Masa.Contrib.Service.Caller.DaprClient --version 0.7.0-preview.12 修改Assignment.Client.DaprClientWeb项目下的Program.cs 123456789101112131415161718192021222324252627282930313233343536373839404142using Masa.Contrib.Service.Caller.DaprClient;using Microsoft.AspNetCore.Mvc;var builder = WebApplication.CreateBuilder(args);builder.Services.AddCaller(option =&gt;{ // 注意: 与Caller.HttpClient相比，需要修改的地方 options.UseDapr(masaDaprClientBuilder =&gt; { masaDaprClientBuilder.Name = &quot;userCaller&quot;; // 当前Caller的别名(仅有一个Caller时可以不填)，Name不能重复 masaDaprClientBuilder.IsDefault = true; // 默认的Caller支持注入ICallerProvider获取（仅有一个Caller时可不赋值） masaDaprClientBuilder.AppId = &quot;Assignment-Server&quot;;//设置当前caller下Dapr的AppId });});var app = builder.Build();app.MapGet(&quot;/&quot;, () =&gt; &quot;Hello HttpClientWeb.V1!&quot;);app.MapGet(&quot;/Test/User/Get&quot;, async ([FromServices] ICaller caller) =&gt;{ var user = await caller.GetAsync&lt;object, UserDto&gt;(&quot;User&quot;, new { id = new Random().Next(1, 10) }); return $&quot;获取用户信息成功：用户名称为：{user!.Name}&quot;;});app.MapGet(&quot;/Test/User/Add&quot;, async ([FromServices] ICaller caller) =&gt;{ var dateTimeOffset = new DateTimeOffset(DateTime.UtcNow); string timeSpan = dateTimeOffset.ToUnixTimeSeconds().ToString(); var userName = &quot;ss_&quot; + timeSpan; //模拟一个用户名 string? response = await caller.PostAsync&lt;object, string&gt;(&quot;User&quot;, new { Name = userName }); return $&quot;创建用户成功了，用户名称为：{response}&quot;;});app.Run();public class UserDto{ public int Id { get; set; } public string Name { get; set; } = default!;} 相较于Assignment.Client.HttpClientWeb，Assignment.Client.DaprClientWeb仅仅是更改了Program.cs，将UseHttpClient改为UseDapr，其余代码无需修改 添加环境变量DAPR_GRPC_PORT，值为7007、DAPR_HTTP_PORT，值为7008 Q: 为什么要添加环境变量？A: 由于当前客户端并未使用dapr sidecar，若当前客户端也使用dapr sidecar，此处可以不添加环境变量 现在Caller的HttpClient版本就可以使用了，分别启动Assignment.Server、Assignment.Client.DaprClientWeb服务，浏览器访问http://localhost:5042/Test/User/Get、http://localhost:5042/Test/User/Add，分别输出对应的获取用户信息成功以及创建用户成功的提示，则证明调用成功了 DaprClient 最佳实践Assignment.Client.DaprClientWeb的写法比较简单，其用法与Assignment.Client.HttpClientWeb基本一致，与Caller.HttpClient类似，DaprClient我们推荐使用下面的写法: 创建ASP.NET Core 空项目Assignment.Client.DaprClientWeb.V2作为调用方V2版本 选中Assignment.Client.DaprClientWeb.V2并安装Masa.Contrib.Service.Caller.DaprClient 1dotnet add package Masa.Contrib.Service.Caller.DaprClient --version 0.7.0-preview.12 添加类ServerCallerBase (对应服务端服务) 1234567891011using Masa.Contrib.Service.Caller.DaprClient;namespace Assignment.Client.DaprClientWeb.V2;/// &lt;summary&gt;/// 注意：ServerCallerBase是抽象类哟（抽象类不会被DI注册）, 与使用Caller.HttpClient相比，需要修改的是继承的基类改为DaprCallerBase/// &lt;/summary&gt;public abstract class ServerCallerBase : DaprCallerBase{ protected override string AppId { get; set; } = &quot;Assignment-Server&quot;;//设置当前Caller需要请求的服务端项目Dapr的AppId} 添加类UserCaller.cs 123456789101112131415161718192021222324252627namespace Assignment.Client.DaprClientWeb.V2;public class UserCaller : ServerCallerBase{ /// &lt;summary&gt; /// 调用服务获取用户信息 /// &lt;/summary&gt; /// &lt;param name=&quot;id&quot;&gt;用户id&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public Task&lt;UserDto?&gt; GetUserAsync(int id) =&gt; Caller.GetAsync&lt;object, UserDto&gt;(&quot;User&quot;, new { id = id }); /// &lt;summary&gt; /// 调用服务添加用户 /// &lt;/summary&gt; /// &lt;param name=&quot;userName&quot;&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public Task&lt;string?&gt; AddUserAsync(string userName) =&gt; Caller.PostAsync&lt;object, string&gt;(&quot;User&quot;, new { Name = userName });}public class UserDto{ public int Id { get; set; } public string Name { get; set; } = default!;} 添加环境变量DAPR_GRPC_PORT，值为7007、DAPR_HTTP_PORT，值为7008 最后，分别启动Assignment.Server、Assignment.Client.DaprClientWeb.V2服务，浏览器访问http://localhost:5102/Test/User/Get、http://localhost:5102/Test/User/Add，分别输出对应的获取用户信息成功以及创建用户成功的提示，则证明调用成功了 常见问题在开发中我们会遇到各种各样的问题，下面就来列举几个我们项目中遇到的问题： 一个项目在同一个k8s集群部署了两套环境，为什么会出现代码调用混乱（开发环境调用线上环境）？ 1在于同一个K8s集群下，dapr会将服务组网，并将它们认为是同一个服务(AppId一致的服务)。 如何解决同一个k8s集群中调用混乱的问题？ 12345678910111213解决方案有两种：1. 将不同环境下的服务分别部署在不同的K8s集群2. 根据环境调整相对应服务的dapr sidecar的配置，其`AppId`的命名规则：`AppId`-`环境名`。修改自定义Caller的规则：public abstract class CustomizeDaprCallerBase : DaprCallerBase{ protected CustomizeDaprCallerBase(IServiceProvider serviceProvider) : base(serviceProvider) { var hostEnvironment = serviceProvider.GetRequiredService&lt;IWebHostEnvironment&gt;(); if (!hostEnvironment.IsDevelopment() || hostEnvironment.IsStaging()) AppId = AppId + &quot;-&quot; + hostEnvironment.EnvironmentName; }} 如何修改支持自定义Header？ 1目前Caller.Dapr不支持自定义Header，目前只能使用`SendAsync`才能自定义Header，不过此功能已经在0.5.0的开发计划中，在0.5.0中会支持 总结使用Masa提供的Caller服务，有助于我们的项目在前期没有使用Dapr的情况下先利用Caller.HttpClient做缓冲，等后期时机成熟，只需要更改相对应的CallerBase即可，其他代码基本不需要调整，减轻了我们的开发成本，并且不同的Caller仍然可以很灵活的调整超时时间、Header等信息，并且Caller默认提供了处理异常的功能，当调用出错后，会自动抛出异常，让我们可以更专心的处理业务。 但目前Caller还有不足之处，目前Caller.Dapr版针对请求头处理的并不完善，除此之外，目前不支持Content-Type为非Json类型，这块功能会在0.5.0版本中加以支持完善 本章源码Assignment03 https://github.com/zhenlei520/MasaFramework.Practice 开源地址MASA.Framework：https://github.com/masastack/MASA.Framework MASA.EShop：https://github.com/masalabs/MASA.EShop MASA.Blazor：https://github.com/BlazorComponent/MASA.Blazor 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们","link":"/2022/05/22/masa/framework/practice/3.%20Caller%20%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%20-%20Dapr/"},{"title":"4. 对象映射 - Mapping.Mapster","text":"前言在项目中我们会经常遇到对象的映射，比如像Model和Dto之间的映射，或者是对象的深拷贝，这些都是需要我们自己实现的。此时，项目中会出现很多初始化对象的代码，这些代码写起来相当的枯燥乏味，那么有没有什么办法减轻我们的工作量，使得我们可以把时间花费到业务功能上呢？ 目前，.Net中的对象映射框架，功能强大且性能极佳的对象映射框架已经存在，其中使用最多的有: Mapster AutoMapper 说到对象映射框架，大家想到的最多的是AutoMapper，可能很多人连Mapster都没听过，但不可否认的是Mapster确实是一个很好的对象映射框架，但由于中文文档的缺失，导致在国内知名度不是很高，今天我们就来介绍一下Mapster提供了哪些功能，如何在项目中使用它，Masa提供的Mapster又做了什么？ Mapster 简介Mapster是一个使用简单，功能强大的对象映射框架，自2014年开源到现在已经过去8个年头，截止到现在，github上已经拥有2.6k的star，并保持着每年3次的发版频率，其功能与AutoMapper类似，提供对象到对象的映射、并支持IQueryable到对象的映射，与AutoMapper相比，在速度和内存占用方面表现的更加优秀，可以在只使用1/3内存的情况下获得4倍的性能提升，那我们下面就来看看Mapster如何使用？ 准备工作 新建一个控制台项目Assignment.Mapster，并安装Mapster 1dotnet add package Mapster --version 7.3.0 映射到新对象 新建类UserDto 12345678910public class UserDto{ public int Id { get; set; } public string Name { get; set; } public uint Gender { get; set; } public DateTime BirthDay { get; set; }} 新建一个匿名对象，作为待转换的对象源 1234567var user = new{ Id = 1, Name = &quot;Tom&quot;, Gender = 1, BirthDay = DateTime.Parse(&quot;2002-01-01&quot;)}; 将user源对象映射到为目标对象 (UserDto) 12var userDto = user.Adapt&lt;UserDto&gt;();Console.WriteLine($&quot;映射到新对象，Name: {userDto.Name}&quot;); 运行控制台程序验证转换成功: 数据类型除了提供对象到对象的映射，还支持数据类型的转换，如： 基本类型 提供类型映射的功能，类似Convert.ChangeType() 123string res = &quot;123&quot;;decimal i = res.Adapt&lt;decimal&gt;(); //equal to (decimal)123;Console.WriteLine($&quot;结果为：{i == int.Parse(res)}&quot;); 运行控制台程序: 枚举类型 把枚举映射到数字类型，同样也支持字符串到枚举和枚举到字符串的映射，比.NET的默认实现快两倍 12var fileMode = &quot;Create, Open&quot;.Adapt&lt;FileMode&gt;();//等于 FileMode.Create | FileMode.OpenConsole.WriteLine($&quot;枚举类型转换的结果为：{fileMode == (FileMode.Create | FileMode.Open)}&quot;); 运行控制台程序验证转换成功: Queryable扩展Mapster提供了Queryable的扩展，用于实现DbContext的按需查找，例如: 新建类UserDbContext 123456789101112131415using Assignment.Mapster.Domain;using Microsoft.EntityFrameworkCore;namespace Assignment.Mapster.Infrastructure;public class UserDbContext : DbContext{ public DbSet&lt;User&gt; User { get; set; } protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) { var dataBaseName = Guid.NewGuid().ToString(); optionsBuilder.UseInMemoryDatabase(dataBaseName);//使用内存数据库，方便测试 }} 新建类User 1234567891011121314151617public class User{ public int Id { get; set; } public string Name { get; set; } public uint Gender { get; set; } public DateTime BirthDay { get; set; } public DateTime CreationTime { get; set; } public User() { CreationTime = DateTime.Now; }} 使用基于Queryable的扩展方法ProjectToType 123456789101112131415using (var dbContext = new UserDbContext()){ dbContext.Database.EnsureCreated(); dbContext.User.Add(new User() { Id = 1, Name = &quot;Tom&quot;, Gender = 1, BirthDay = DateTime.Parse(&quot;2002-01-01&quot;) }); dbContext.SaveChanges(); var userItemList = dbContext.User.ProjectToType&lt;UserDto&gt;().ToList();} 运行控制台程序验证转换成功: 除此之外，Mapster还提供了映射前/后处理，拷贝与合并以及映射配置嵌套支持，详细可查看文档，既然Mapster已经如此强大，那我直接使用它就可以了，为什么还要使用Masa提供的Mapper呢？ 什么是Masa.Contrib.Data.Mapping.Mapster？Masa.Contrib.Data.Mapping.Mapster是基于Mapster的一个对象到对象的映射器，并在原来Mapster的基础上增加自动获取并使用最佳构造函数映射，支持嵌套映射，减轻映射的工作量。 映射规则 目标对象没有构造函数时：使用空构造函数，映射到字段和属性。 目标对象存在多个构造函数：获取最佳构造函数映射 最佳构造函数: 目标对象构造函数参数数量从大到小降序查找，参数名称一致（不区分大小写）且参数类型与源对象属性一致 准备工作 新建一个控制台项目Assignment.Masa.Mapster，并安装Masa.Contrib.Data.Mapping.Mapster，Microsoft.Extensions.DependencyInjection 12dotnet add package Masa.Contrib.Data.Mapping.Mapster --version 0.4.0-rc.4dotnet add package Microsoft.Extensions.DependencyInjection --version 6.0.0 新建类OrderItem 1234567891011121314151617181920public class OrderItem{ public string Name { get; set; } public decimal Price { get; set; } public int Number { get; set; } public OrderItem(string name, decimal price) : this(name, price, 1) { } public OrderItem(string name, decimal price, int number) { Name = name; Price = price; Number = number; }} 新建类Order 12345678910111213141516171819public class Order{ public string Name { get; set; } public decimal TotalPrice { get; set; } public List&lt;OrderItem&gt; OrderItems { get; set; } public Order(string name) { Name = name; } public Order(string name, OrderItem orderItem) : this(name) { OrderItems = new List&lt;OrderItem&gt; { orderItem }; TotalPrice = OrderItems.Sum(item =&gt; item.Price * item.Number); }} 修改类Program 12345678910111213141516171819202122using Assignment.Masa.Mapster.Domain.Aggregate;using Masa.BuildingBlocks.Data.Mapping;using Masa.Contrib.Data.Mapping.Mapster;using Microsoft.Extensions.DependencyInjection;Console.WriteLine(&quot;Hello Masa Mapster!&quot;);IServiceCollection services = new ServiceCollection();services.AddMapping();var request = new{ Name = &quot;Teach you to learn Dapr ……&quot;, OrderItem = new OrderItem(&quot;Teach you to learn Dapr hand by hand&quot;, 49.9m)};var serviceProvider = services.BuildServiceProvider();var mapper = serviceProvider.GetRequiredService&lt;IMapper&gt;();var order = mapper.Map&lt;Order&gt;(request);Console.WriteLine($&quot;{nameof(Order.TotalPrice)} is {order.TotalPrice}&quot;);//控制台输出49.9Console.ReadKey(); 如果转换成功，TotalPrice的值应该是49.9，那么我们运行控制台程序来验证转换是否成功： 如何实现上面我们提到了Masa.Contrib.Data.Mapping.Mapster可以自动获取并使用最佳构造函数映射，进而完成对象到对象的映射，那么它是如何实现的呢？会不会对性能有什么影响呢？ 做到自动获取并使用最佳构造函数映射是使用的Mapster提供的构造函数映射的功能，通过指定构造函数，完成对象到对象的映射。 查看文档 总结目前Masa.Contrib.Data.Mapping.Mapster的功能相对较弱，当前版本与Mapster的相比仅仅增加了一个自动获取并使用最佳构造函数的功能，让我们在面对无空构造函数且拥有多个构造函数的类时也能轻松的完成映射，不需要额外多写一行代码。 但我觉得Masa版的Mapping最大的好处是项目依赖的是BuildingBlocks下的IMapper，而不是Mapster，这也就使得我们的项目与具体的映射器实现脱离，如果我们被要求项目必须要使用AutoMapper，只需要实现AutoMapper版的IMapper即可，无需更改太多的业务代码，仅需要更换一下引用的包即可，这也是BuildingBlocks的魅力所在 本章源码Assignment04 https://github.com/zhenlei520/MasaFramework.Practice 开源地址MASA.BuildingBlocks：https://github.com/masastack/MASA.BuildingBlocks MASA.Contrib：https://github.com/masastack/MASA.Contrib MASA.Utils：https://github.com/masastack/MASA.Utils MASA.EShop：https://github.com/masalabs/MASA.EShop MASA.Blazor：https://github.com/BlazorComponent/MASA.Blazor 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们","link":"/2022/05/28/masa/framework/practice/4.%20%E5%AF%B9%E8%B1%A1%E6%98%A0%E5%B0%84%20-%20Mapster/"},{"title":"5. 数据访问 - EntityFramework集成","text":"前言Masa提供了基于EntityFramework的数据集成，并提供了数据过滤与软删除的功能，下面我们将介绍如何使用它？ MasaDbContext入门 安装.Net 6.0 新建ASP.NET Core 空项目Assignment.MasaEntityFramework，并安装Masa.Contrib.Data.EntityFrameworkCore、Swashbuckle.AspNetCore、Microsoft.EntityFrameworkCore.InMemory、Microsoft.EntityFrameworkCore.Tools 1234dotnet add package Masa.Contrib.Data.EntityFrameworkCore --version 0.4.0-rc.4dotnet add package Swashbuckle.AspNetCore --version 6.2.3dotnet add package Microsoft.EntityFrameworkCore.InMemory --version 6.0.5dotnet add package Microsoft.EntityFrameworkCore.Tools --version 6.0.5 安装Swashbuckle.AspNetCore是为了方便通过Swagger来操作服务安装Microsoft.EntityFrameworkCore.InMemory是为了方便，因此使用内存数据库，如果需要使用其他数据库，请自行安装对应的包安装Microsoft.EntityFrameworkCore.Tools是为了使用CodeFirst创建数据库 新建类User 1234567891011121314151617public class User{ public int Id { get; set; } public string Name { get; set; } public uint Gender { get; set; } public DateTime BirthDay { get; set; } public DateTime CreationTime { get; set; } public User() { this.CreationTime = DateTime.Now; }} 新建用户上下文UserDbContext.cs 12345678public class UserDbContext : MasaDbContext{ public DbSet&lt;User&gt; User { get; set; } public UserDbContext(MasaDbContextOptions options) : base(options) { }} UserDbContext改为继承MasaDbContext, 并新增一个参数的构造函数，参数类型为MasaDbContextOptions当项目中存在多个DbContext时，需要改为继承MasaDbContext&lt;TDbContext&gt;，构造函数参数类型改为MasaDbContext&lt;TDbContext&gt; 新建类AddUserRequest作为添加用户的参数 12345678public class AddUserRequest{ public string Name { get; set; } public uint Gender { get; set; } public DateTime BirthDay { get; set; }} 新建类HostExtensions用于迁移数据库（使用CodeFirst） 1234567891011121314public static class HostExtensions{ public static void MigrateDbContext&lt;TContext&gt;( this IHost host, Action&lt;TContext, IServiceProvider&gt; seeder) where TContext : DbContext { using (var scope = host.Services.CreateScope()) { var services = scope.ServiceProvider; var context = services.GetRequiredService&lt;TContext&gt;(); context.Database.EnsureCreated(); seeder(context, services); } }} 修改Program.cs，新增Swagger支持 1234567builder.Services.AddEndpointsApiExplorer();builder.Services.AddSwaggerGen();var app = builder.Build();app.UseSwagger();app.UseSwaggerUI(); 不需要Swagger可不添加，使用Swagger仅仅是为了测试调用服务，使用Postman或其他的Http工具也可以 修改Program.cs，添加用户上下文（重点） 1234builder.Services.AddMasaDbContext&lt;UserDbContext&gt;(options =&gt; { options.Builder = (_, dbContextOptionsBuilder) =&gt; dbContextOptionsBuilder.UseInMemoryDatabase(&quot;test&quot;)}); 修改Program.cs，使项目支持CodeFirst 123app.MigrateDbContext&lt;UserDbContext&gt;((context, services) =&gt;{}); 不需要CodeFirst，不支持代码生成数据库可不添加 测试MasaDbContext，修改Program.cs 123456789101112131415app.MapPost(&quot;/add&quot;, (UserDbContext dbContext, [FromBody] AddUserRequest request) =&gt;{ dbContext.Set&lt;User&gt;().Add(new User() { Name = request.Name, Gender = request.Gender, BirthDay = request.BirthDay }); dbContext.SaveChanges();});app.MapGet(&quot;/list&quot;, (UserDbContext dbContext) =&gt;{ return dbContext.Set&lt;User&gt;().ToList();}); 自行运行项目，执行add后创建一个新的用户，之后执行list得到一个以上的用户数据，则证明MasaDbContext使用无误 如何使用软删除 选中Assignment.MasaEntityFramework并安装Masa.Contrib.Data.Contracts.EF 1dotnet add package Masa.Contrib.Data.Contracts.EF --version 0.4.0-rc.4 修改类User，并实现ISoftDelete，代码改为： 12345678910111213141516171819public class User : ISoftDelete//重点：改为实现ISoftDelete{ public int Id { get; set; } public string Name { get; set; } public uint Gender { get; set; } public DateTime BirthDay { get; set; } public DateTime CreationTime { get; set; } public bool IsDeleted { get; private set; } public User() { this.CreationTime = DateTime.Now; }} 增加实现ISoftDelete，并为IsDeleted属性添加set支持（可以是private set;） 修改Program.cs，并启用数据过滤 12345builder.Services.AddMasaDbContext&lt;UserDbContext&gt;(options =&gt;{ options.Builder = (_, dbContextOptionsBuilder) =&gt; dbContextOptionsBuilder.UseInMemoryDatabase(&quot;test&quot;); options.UseFilter();//启用数据过滤，完整写法：options.UseFilter(filterOptions =&gt; filterOptions.EnableSoftDelete = true);}); 测试软删除是否成功 修改Program.cs，新增删除方法 123456app.MapDelete(&quot;/delete&quot;, (UserDbContext dbContext, int id) =&gt;{ var user = dbContext.Set&lt;User&gt;().First(u =&gt; u.Id == id); dbContext.Set&lt;User&gt;().Remove(user); dbContext.SaveChanges();}); 最后，先调用add方法创建用户后，之后再调用list方法获取所有的用户列表，并取出任意一条id信息，然后再调用delete方法删除用户，最后再调用list方法，查看取出的id是否存在，以此来验证软删除是否有效。 如何临时禁用软删除过滤默认查询中会将标记已经被删除的数据过滤不再进行查询，但也有一些场景需要查询所有的数据，此时就需要用到数据过滤IDataFilter 新增All方法用于查询所有的数据（包含标记已经删除的数据） 12345678app.MapGet(&quot;/all&quot;, (UserDbContext dbContext, [FromServices] IDataFilter dataFilter) =&gt;{ //通过DI获取到IDataFilter，并调用其Disable方法可临时禁用ISoftDelete条件过滤 using (dataFilter.Disable&lt;ISoftDelete&gt;()) { return dbContext.Set&lt;User&gt;().ToList(); }}); 重新运行项目，重复执行验证软删除步骤，确保通过list方法访问不到数据 重复运行验证软删除步骤的原因在于本示例使用的是内存数据库，项目停止后，所有数据都会被清空，重新执行是为了确保数据存在，仅被标记为删除 执行all方法，获取所有的数据，查看id所对应的用户数据是否存在 从配置文件中获取数据库连接字符串 选中项目Assignment.MasaEntityFramework，并安装Masa.Contrib.Data.EntityFrameworkCore.InMemory 1dotnet add package Masa.Contrib.Data.EntityFrameworkCore.InMemory --version 0.4.0-rc.4 根据需要安装对应数据库包即可，如：Masa.Contrib.Data.EntityFrameworkCore.SqlServer (SqlServer)、Masa.Contrib.Data.EntityFrameworkCore.Pomelo.MySql (Pomelo提供的MySql)、Masa.Contrib.Data.EntityFrameworkCore.Oracle (Oracle)等 修改Program.cs，调整添加用户上下文配置为: 1builder.Services.AddMasaDbContext&lt;UserDbContext&gt;(options =&gt; options.UseInMemoryDatabase().UseFilter()); 修改appsettings.json，增加用户数据库连接字符串: 12345{ &quot;ConnectionStrings&quot;: { &quot;DefaultConnection&quot;: &quot;test&quot;//更换为指定的数据库连接字符串 }} 修改Program.cs，新增database方法，验证当前数据库是test 1234567891011121314app.MapGet(&quot;/database&quot;, (UserDbContext dbContext) =&gt;{ var field = typeof(MasaDbContext).GetField(&quot;Options&quot;, BindingFlags.Public | BindingFlags.Instance | BindingFlags.NonPublic)!; var masaDbContextOptions = field.GetValue(dbContext) as MasaDbContextOptions; foreach (var dbContextOptionsExtension in masaDbContextOptions!.Extensions) { if (dbContextOptionsExtension is InMemoryOptionsExtension memoryOptionsExtension) { return memoryOptionsExtension.StoreName; } } return &quot;&quot;;}); 最后访问http://localhost:5002/database，验证当前的数据库名称与修改后的数据库名称是否一致 常见问题 如何更改默认读取的配置节点? 修改用户上下文UserDbContext并增加ConnectionStringName特性: 123456789[ConnectionStringName(&quot;User&quot;)]//自定义节点名public class UserDbContext : MasaDbContext{ public DbSet&lt;User&gt; User { get; set; } public UserDbContext(MasaDbContextOptions options) : base(options) { }} 修改配置appsettings.json 12345{ &quot;ConnectionStrings&quot;: { &quot;User&quot;: &quot;test&quot;//改为从User节点读取数据库连接字符串 }} 除了从配置文件中获取，还支持从其他地方获取数据库连接字符串吗？ 目前有两种办法可以更改数据库连接字符串。 方法1: 修改Program.cs，并删除appsettings.json数据库连接字符串的配置 修改Program.cs 1234567builder.Services.Configure&lt;MasaDbConnectionOptions&gt;(option =&gt;{ option.ConnectionStrings = new ConnectionStrings(new List&lt;KeyValuePair&lt;string, string&gt;&gt;() { new(&quot;User&quot;, &quot;test2&quot;)//其中键为节点名，与ConnectionStringName特性的Name值保持一致即可，如果未指定ConnectionStringName，则应该为DefaultConnection，值为数据库连接字符串 });}); 修改appsettings.json配置 123// &quot;ConnectionStrings&quot;: {// &quot;User&quot;: &quot;test&quot;// }, 调用database方法，验证当前数据库是否为test2 方法2: 重写IConnectionStringProvider和IDbConnectionStringProvider的实现并添加到DI中 新建类CustomizeConnectionStringProvider 123456public class CustomizeConnectionStringProvider : IConnectionStringProvider{ public Task&lt;string&gt; GetConnectionStringAsync(string name = &quot;DefaultConnection&quot;) =&gt; Task.FromResult (GetConnectionString(name)); public string GetConnectionString(string name = &quot;DefaultConnection&quot;) =&gt; &quot;test3&quot;;} 新建类CustomizeDbConnectionStringProvider 1234567public class CustomizeDbConnectionStringProvider : IDbConnectionStringProvider{ public List&lt;MasaDbContextConfigurationOptions&gt; DbContextOptionsList { get; } = new() { new MasaDbContextConfigurationOptions(&quot;test3&quot;) };} 修改Program.cs 12builder.Services.AddSingleton&lt;IConnectionStringProvider,CustomizeConnectionStringProvider&gt;();builder.Services.AddSingleton&lt;IDbConnectionStringProvider,CustomizeDbConnectionStringProvider&gt;(); 调用database方法，验证当前数据库是否为test3 总结本篇文章主要讲解了MasaDbContext的基本用法以及软删除、数据过滤如何使用，下篇文章我们会讲解一下MasaDbContext是如何实现软删除、数据过滤的，以及本篇文章中提到使用数据库时不指定数据库链接字符串时如何实现的 本章源码Assignment05 https://github.com/zhenlei520/MasaFramework.Practice 开源地址MASA.BuildingBlocks：https://github.com/masastack/MASA.BuildingBlocks MASA.Contrib：https://github.com/masastack/MASA.Contrib MASA.Utils：https://github.com/masastack/MASA.Utils MASA.EShop：https://github.com/masalabs/MASA.EShop MASA.Blazor：https://github.com/BlazorComponent/MASA.Blazor 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们","link":"/2022/05/29/masa/framework/practice/5.%20%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%20-%20EntityFramework%E9%9B%86%E6%88%90/"},{"title":"6. 对象存储","text":"什么是对象存储在工作中，我们经常需要将文件内容（文件或二进制流）存储在应用程序中，例如你可能要保存商品的封面图片。Masa框架为此提供了对象存储的功能，并对功能抽象，抽象给我们带来的好处: 存储的无关性（不关心存储平台时阿里云OSS还是腾讯云的COS） 更换存储平台成本更低（仅需要更改下存储的提供者，业务侵染低） 支持自定义存储提供者（仅需要自行实现IClient） 对象存储提供程序 阿里云: 在阿里云OSS存储服务上存储 目前仅支持阿里云存储，后续将逐步提供更多的云存储平台支持，如果您有喜欢的其它云存储平台，欢迎提建议，或者自己实现它并为Masa框架做出贡献 如何制作自定义存储程序? 快速入门Masa.BuildingBlocks.Storage.ObjectStorage是对象存储服务的抽象包，你可以在项目中使用它来进行编写代码，最后在Program.cs中选择一个存储提供程序使用即可 安装.Net 6.0 新建ASP.NET Core 空项目Assignment.OSS，并安装Masa.Contrib.Storage.ObjectStorage.Aliyun 123dotnet new web -o Assignment.OSScd Assignment.OSSdotnet add package Masa.Contrib.Storage.ObjectStorage.Aliyun --version 0.5.0-preview.2 修改Program.cs 123456789101112131415161718builder.Services.AddAliyunStorage();#region 或者通过代码指定传入阿里云存储配置信息使用，无需使用配置文件// builder.Services.AddAliyunStorage(new AliyunStorageOptions()// {// AccessKeyId = &quot;Replace-With-Your-AccessKeyId&quot;,// AccessKeySecret = &quot;Replace-With-Your-AccessKeySecret&quot;,// Endpoint = &quot;Replace-With-Your-Endpoint&quot;,// RoleArn = &quot;Replace-With-Your-RoleArn&quot;,// RoleSessionName = &quot;Replace-With-Your-RoleSessionName&quot;,// Sts = new AliyunStsOptions()// {// RegionId = &quot;Replace-With-Your-Sts-RegionId&quot;,// DurationSeconds = 3600,// EarlyExpires = 10// }// }, &quot;storage1-test&quot;);#endregion 修改appsettings.json，增加阿里云配置 123456789101112131415161718192021{ &quot;Aliyun&quot;: { &quot;AccessKeyId&quot;: &quot;Replace-With-Your-AccessKeyId&quot;, &quot;AccessKeySecret&quot;: &quot;Replace-With-Your-AccessKeySecret&quot;, &quot;Sts&quot;: { &quot;RegionId&quot;: &quot;Replace-With-Your-Sts-RegionId&quot;, &quot;DurationSeconds&quot;: 3600, &quot;EarlyExpires&quot;: 10 }, &quot;Storage&quot;: { &quot;Endpoint&quot;: &quot;Replace-With-Your-Endpoint&quot;, &quot;RoleArn&quot;: &quot;Replace-With-Your-RoleArn&quot;, &quot;RoleSessionName&quot;: &quot;Replace-With-Your-RoleSessionName&quot;, &quot;TemporaryCredentialsCacheKey&quot;: &quot;Aliyun.Storage.TemporaryCredentials&quot;, &quot;Policy&quot;: &quot;&quot;, &quot;BucketNames&quot; : { &quot;DefaultBucketName&quot; : &quot;storage1-test&quot;//默认BucketName，非必填项，仅在使用IClientContainer时需要指定 } } }} 新增上传文件服务 123456789app.MapPost(&quot;/upload&quot;, async (HttpRequest request, IClient client) =&gt;{ var form = await request.ReadFormAsync(); var formFile = form.Files[&quot;file&quot;]; if (formFile == null) throw new FileNotFoundException(&quot;Can't upload empty file&quot;); await client.PutObjectAsync(&quot;storage1-test&quot;, formFile.FileName, formFile.OpenReadStream());}); 进阶IClientIClient是用来存储和读取对象的主要接口，可以在项目的任意地方通过DI获取到IClient来上传、下载或删除指定BucketName下的对象，也可用于判断对象是否存在，获取临时凭证等。 上传对象 123456789app.MapPost(&quot;/upload&quot;, async (HttpRequest request, IClient client) =&gt;{ var form = await request.ReadFormAsync(); var formFile = form.Files[&quot;file&quot;]; if (formFile == null) throw new FileNotFoundException(&quot;Can't upload empty file&quot;); await client.PutObjectAsync(&quot;storage1-test&quot;, formFile.FileName, formFile.OpenReadStream());}); Form表单提交，key为file，类型为文件上传 删除对象 123456789public class DeleteRequest{ public string Key { get; set; }}app.MapDelete(&quot;/delete&quot;, async (IClient client, [FromBody] DeleteRequest request) =&gt;{ await client.DeleteObjectAsync(&quot;storage1-test&quot;, request.Key);}); 判断对象是否存在 1234app.MapGet(&quot;/exist&quot;, async (IClient client, string key) =&gt;{ await client.ObjectExistsAsync(&quot;storage1-test&quot;, key);}); 返回对象数据的流 12345678910111213141516app.MapGet(&quot;/download&quot;, async (IClient client, string key, string path) =&gt;{ await client.GetObjectAsync(&quot;storage1-test&quot;, key, stream =&gt; { //下载文件到指定路径 using var requestStream = stream; byte[] buf = new byte[1024]; var fs = File.Open(path, FileMode.OpenOrCreate); int len; while ((len = requestStream.Read(buf, 0, 1024)) != 0) { fs.Write(buf, 0, len); } fs.Close(); });}); 获取临时凭证(STS) 1234app.MapGet(&quot;/GetSts&quot;, (IClient client) =&gt;{ client.GetSecurityToken();}); 阿里云、腾讯云存储等平台使用STS来获取临时凭证 获取临时凭证(字符串类型的临时凭证) 1234app.MapGet(&quot;/GetToken&quot;, (IClient client) =&gt;{ client.GetToken();}); 七牛云等存储平台使用较多 IBucketNameProviderIBucketNameProvider是用来获取BucketName的接口，通过IBucketNameProvider可以获取指定存储空间的BucketName，为IClientContainer提供BucketName能力，在业务项目中不会使用到 IClientContainerIClientContainer对象存储容器，用来存储和读取对象的主要接口，一个应用程序下可能会存在管理多个BucketName，通过使用IClientContainer，像管理DbContext一样管理不同Bucket的对象，不需要在项目中频繁指定BucketName，在同一个应用程序中，有且只有一个默认ClientContainer，可以通过DI获取IClientContainer来使用，例如： 上传对象（上传到默认Bucket） 123456789app.MapPost(&quot;/upload&quot;, async (HttpRequest request, IClientContainer clientContainer) =&gt;{ var form = await request.ReadFormAsync(); var formFile = form.Files[&quot;file&quot;]; if (formFile == null) throw new FileNotFoundException(&quot;Can't upload empty file&quot;); await clientContainer.PutObjectAsync(formFile.FileName, formFile.OpenReadStream());}); 上传到指定Bucket 123456789101112131415161718192021222324[BucketName(&quot;picture&quot;)]public class PictureContainer{}builder.Services.Configure&lt;StorageOptions&gt;(option =&gt;{ option.BucketNames = new BucketNames(new List&lt;KeyValuePair&lt;string, string&gt;&gt;() { new(&quot;DefaultBucketName&quot;, &quot;storage1-test&quot;),//默认BucketName new(&quot;picture&quot;, &quot;storage1-picture&quot;)//指定别名为picture的BucketName为storage1-picture });});app.MapPost(&quot;/upload&quot;, async (HttpRequest request, IClientContainer&lt;PictureContainer&gt; clientContainer) =&gt;{ var form = await request.ReadFormAsync(); var formFile = form.Files[&quot;file&quot;]; if (formFile == null) throw new FileNotFoundException(&quot;Can't upload empty file&quot;); await clientContainer.PutObjectAsync(formFile.FileName, formFile.OpenReadStream());}); IClientFactoryIClientFactory对象存储提供者工厂，通过指定BucketName，创建指定的IClientContainer 创建对象存储提供程序以适配腾讯云存储为例： 新建类库Masa.Contrib.Storage.ObjectStorage.Tencent 选中Masa.Contrib.Storage.ObjectStorage.Tencent并新建类DefaultStorageClient，并实现IClient 由于腾讯云存储提供Sts临时凭证，所以仅需要实现GetSecurityToken方法即可，GetToken方法可抛出不支持的异常，并在文档说明即可 新建类ServiceCollectionExtensions，并提供对IServiceCollection的扩展方法AddTencentStorage，例如： 123456789101112131415161718192021222324public static IServiceCollection AddTencentStorage( this IServiceCollection services, TencentStorageOptions options, string? defaultBucketName = null){ //todo: 添加腾讯云存储的客户端 if (defaultBucketName != null) { services.Configure&lt;StorageOptions&gt;(option =&gt; { option.BucketNames = new BucketNames(new List&lt;KeyValuePair&lt;string, string&gt;&gt;() { new(BucketNames.DEFAULT_BUCKET_NAME, defaultBucketName) }); }); services.TryAddSingleton&lt;IClientContainer&gt;(serviceProvider =&gt; new DefaultClientContainer(serviceProvider.GetRequiredService&lt;IClient&gt;(), defaultBucketName)); } services.TryAddSingleton&lt;IClientFactory, DefaultClientFactory&gt;(); services.TryAddSingleton&lt;ICredentialProvider, DefaultCredentialProvider&gt;(); services.TryAddSingleton&lt;IClient, DefaultStorageClient&gt;(); return services;} 总结目前对象存储暂时并未支持多租户、多环境，后续根据情况逐步完善增加多租户、多环境支持，以适配不同的租户、不同的环境下的对象存储到指定的Bucket中 本章源码Assignment06 https://github.com/zhenlei520/MasaFramework.Practice 开源地址MASA.BuildingBlocks：https://github.com/masastack/MASA.BuildingBlocks MASA.Contrib：https://github.com/masastack/MASA.Contrib MASA.Utils：https://github.com/masastack/MASA.Utils MASA.EShop：https://github.com/masalabs/MASA.EShop MASA.Blazor：https://github.com/BlazorComponent/MASA.Blazor 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们","link":"/2022/06/01/masa/framework/practice/6.%20%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8/"},{"title":"7. 依赖注入","text":"Masa的依赖注入系统是基于Microsoft的依赖注入扩展库（Microsoft.Extensions.DependencyInjection nuget包）开发的，因此，它的文档在Masa中也是有效的。 按照约定的注册Masa引入了按照约定进行服务注册，依据约定大于配置，开发者无需做任何事，框架会自动完成注册 依赖接口 ISingletonDependency: 注册生命周期为Singleton的服务 IScopedDependency: 注册生命周期为Scoped的服务 ITransientDependency: 注册生命周期为Transient的服务 IAutoFireDependency: 自动触发（与ISingletonDependency、IScopedDependency、ITransientDependency结合使用，在服务自动注册结束后触发一次获取服务操作，仅继承IAutoFireDependency不起作用） 示例： 1234public class StorageOptions : ITransientDependency{ } 特性IgnoreInjection忽略注入，用于排除不被自动注入 Cascade: 设置为true时，当前类以及子类都不再被自动注册，设置为false，仅当前类不被自动注册（默认false） 示例： 1234567891011121314151617181920212223242526272829303132public class BaseService : ISingletonDependency{ public static int Count { get; set; } = 0; public BaseService() { Count++; } public BaseService(bool isChildren) { }}[IgnoreInjection]public class GoodsBaseService : BaseService{ public GoodsBaseService() : base(true) { }}public class GoodsService : GoodsBaseService{ public static int GoodsCount { get; set; } = 0; public GoodsService() { GoodsCount++; }} 效果等同于：services.AddSingleton&lt;BaseService&gt;(); services.AddSingleton&lt;GoodsService&gt;(); Dependency配合ISingletonDependency、IScopedDependency、ITransientDependency使用，实现服务仅被注册一次 TryRegister: 设置true则仅当服务未注册时才会被注册，类似IServiceCollection的TryAdd … 扩展方法. 示例： 12345678910111213141516171819202122232425262728public interface ICache : ISingletonDependency{ void Set(string key, string value);}[Dependency(TryRegister = true)]public class EmptyCache : ICache{ public void Set(string key, string value) { throw new NotSupportedException($&quot;暂不支持{nameof(Set)}方法&quot;); }}public class MemoryCache : ICache{ private readonly ConcurrentDictionary&lt;string, Lazy&lt;string&gt;&gt; _dicCache = new(); public void Set(string key, string value) { _ = _dicCache.AddOrUpdate ( key, k =&gt; new Lazy&lt;string&gt;(() =&gt; value, LazyThreadSafetyMode.ExecutionAndPublication), (_, _) =&gt; new Lazy&lt;string&gt;(() =&gt; value, LazyThreadSafetyMode.ExecutionAndPublication) ).Value; }} 效果等同于：services.AddSingleton&lt;ICache, MemoryCache&gt;(); ReplaceServices: 设置true则替换之前已经注册过的服务，类似IServiceCollection的Replace … 扩展方法. 示例： 123456789101112131415public interface IEncryptionService : ISingletonDependency{ string MethodName { get; }}[Dependency(ReplaceServices = true)]public class Sha1EncryptionService : IEncryptionService{ public string MethodName =&gt; &quot;Sha1&quot;;}public class Md5EncryptionService : IEncryptionService{ public string MethodName =&gt; &quot;Md5&quot;;} 效果等同于：services.AddSingleton&lt;IEncryptionService, Sha1EncryptionService&gt;(); 快速入门 安装.Net 6.0 新建单元测试项目Assignment.DependencyInjection，选择MSTest，并安装Masa.Utils.Extensions.DependencyInjection 123dotnet new xunit -o Assignment.DependencyInjectioncd Assignment.DependencyInjectiondotnet add package Masa.Utils.Extensions.DependencyInjection --version 0.5.0-preview.2 新建类StorageOptions 1234public class StorageOptions : ITransientDependency{ } 新建类DITest 1234567891011121314151617181920[TestClass]public class DITest{ private IServiceCollection _services; [TestInitialize] public void Init() { _services = new ServiceCollection(); _services.AddAutoInject();//执行自动注入 } [TestMethod] public void TestAutoInject() { Assert.IsTrue(_services.Any&lt;StorageOptions&gt;(ServiceLifetime.Transient));//判断StorageOptions注册成功，且生命周期为Transient } private IServiceProvider ServiceProvider =&gt; _services.BuildServiceProvider();} 总结如果需要使用按照约定自动注册服务，则请记住 根据业务需要，则指定类或接口中实现以下接口 ISingletonDependency 单例（项目启动后仅初始化一次） IScopedDependency 请求 （每次请求仅初始化一次） ITransientDependency 瞬时（每次获取都会被初始化） 抽象类不会被自动注册 如果你有一个自定义接口IRepository，且希望接口以及对应的默认实现类RepositoryBase会被自动注册生命周期为Scoped，则接口IRepository应该继承IScopedDependency 如果你希望默认提供的RepositoryBase可以被用户定义的类替换，则应该在RepositoryBase上方增加[Dependency(TryRegister = true)]，那用户仅需要实现IRepository即可 或不更改默认提供的RepositoryBase，用户实现IRepository后，并在新的实现类上方增加[Dependency(ReplaceServices = true)] 本章源码Assignment07 https://github.com/zhenlei520/MasaFramework.Practice 开源地址MASA.BuildingBlocks：https://github.com/masastack/MASA.BuildingBlocks MASA.Contrib：https://github.com/masastack/MASA.Contrib MASA.Utils：https://github.com/masastack/MASA.Utils MASA.EShop：https://github.com/masalabs/MASA.EShop MASA.Blazor：https://github.com/BlazorComponent/MASA.Blazor 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们","link":"/2022/06/07/masa/framework/practice/7.%20%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"},{"title":"8. 更优雅的获取配置信息","text":"前言配置是我们必不可少的功能，我们在开发中，经常会遇到需要获取配置信息的需求，那么如何才能优雅的获取配置信息？ 我们希望新的配置: 支持强类型 配置变更后通知 学习难度低 快速入门根据使用场景我们将配置分为本地配置以及远程配置，下面我们就来看一下本地配置与远程配置是如何来使用的？ 安装.Net 6.0 本地配置 新建ASP.NET Core 空项目Assignment.MasaConfiguration，并安装Masa.Contrib.Configuration 123dotnet new web -o Assignment.MasaConfigurationcd Assignment.MasaConfigurationdotnet add package Masa.Contrib.Configuration --version 0.6.0-preview.7 新建类AppConfig、ConnectionStrings，用于存储数据库配置 123456789101112/// &lt;summary&gt;/// 应用配置类/// &lt;/summary&gt;public class AppConfig : LocalMasaConfigurationOptions{ public ConnectionStrings ConnectionStrings { get; set; }}public class ConnectionStrings{ public string DefaultConnection { get; set; }} 修改文件appsettings.json 1234567{ &quot;AppConfig&quot;: { &quot;ConnectionStrings&quot;: { &quot;DefaultConnection&quot;: &quot;server=localhost;uid=sa;pwd=P@ssw0rd;database=identity&quot; } }} 注册MasaConfiguration，修改类Program 1builder.AddMasaConfiguration(); 如何使用？修改类Program 1234app.MapGet(&quot;/AppConfig&quot;, (IOptions&lt;AppConfig&gt; appConfig){ return appConfig.Value.ConnectionStrings.DefaultConnection);}); 如果希望监听配置变更事件，则可使用IOptionsMonitor的OnChange方法 远程配置目前我们远程配置的能力仅实现了Dcc, 下面就让我们看看如何来使用它 选中Assignment.MasaConfiguration，并安装Masa.Contrib.Configuration.ConfigurationApi.Dcc 1dotnet add package Masa.Contrib.Configuration.ConfigurationApi.Dcc --version 0.6.0-preview.7 修改appsettings.json 12345678910111213141516{ //Dcc配置，扩展Configuration能力，支持远程配置 &quot;DccOptions&quot;: { &quot;ManageServiceAddress &quot;: &quot;http://localhost:8890&quot;, &quot;RedisOptions&quot;: { &quot;Servers&quot;: [ { &quot;Host&quot;: &quot;localhost&quot;, &quot;Port&quot;: 8889 } ], &quot;DefaultDatabase&quot;: 0, &quot;Password&quot;: &quot;&quot; } }} 新建类RedisOptions, 用于配置业务项目中使用的缓存地址 12345678910public class RedisOptions : ConfigurationApiMasaConfigurationOptions{ public string Host { get; set; } public int Port { get; set; } public string Password { get; set; } public int DefaultDatabase { get; set; }} 修改类Program 1234var app = builder.AddMasaConfiguration(configurationBuilder =&gt;{ configurationBuilder.UseDcc();}).Build(); 如何使用？ 12345// 推荐使用，通过IOptions&lt;TOptions&gt;获取配置，支持强类型app.MapGet(&quot;/AppConfig&quot;, (IOptions&lt;RedisOptions&gt; options){ return options.Value.Host;}); 进阶到目前为止，我们已经学会了如何使用Masa提供的配置，但只有了解原理，我们才敢在项目中大胆的用起来，出现问题后才能快速的定位并解决问题，下面我们就来深入了解下 分类根据使用场景我们将配置划分为： 本地配置（配置存储在本地配置文件中，后期配置变更不变） 远程配置（配置在远程配置中心、例如Dcc、Apollo、其它配置中心） IConfiguration结构在使用MasaConfiguration后，IConfiguration的文件结构变更为： 12345678IConfiguration├── Local 本地节点（固定）│ ├── Platforms 自定义配置│ ├── ├── Name 参数├── ConfigurationAPI 远程节点（固定）│ ├── AppId 替换为你的AppId│ ├── AppId ├── Platforms 自定义节点│ ├── AppId ├── Platforms ├── Name 参数 除了以下配置源以及配置的提供者提供的配置除外，其余的配置会迁移到Local节点下 配置源 CommandLineConfigurationSource EnvironmentVariablesConfigurationSource KeyPerFileConfigurationSource MemoryConfigurationSource 配置提供者 CommandLineConfigurationProvider EnvironmentVariablesConfigurationProvider KeyPerFileConfigurationProvider MemoryConfigurationProvider 全局配置MasaConfiguration中提供了全局配置的功能，并默认支持AppId、Environment、Cluster 优先级 获取参数值的优先级为： 1自定义全局配置 &gt; 从IConfiguration中获取（支持命令、环境变量、配置文件） &gt; 约定配置 自定义全局配置 12345678service.Configure&lt;MasaAppConfigureOptions&gt;(options =&gt; { options.AppId = &quot;Replace-With-Your-AppId&quot;; options.Environment = &quot;Replace-With-Your-Environment&quot;; options.Cluster = &quot;Replace-With-Your-Cluster&quot;; options.TryAdd(&quot;Replace-With-Your-ConfigKey&quot;, &quot;Replace-With-Your-ConfigValue&quot;);// 自定义全局配置键、值}) IConfiguration中获取 当未指定配置的值时，将会从配置中获取得到配置的值，默认配置与Key的关系为： AppId: AppId Environment: ASPNETCORE_ENVIRONMENT Cluster: Cluster 当命令行与环境变量获取参数失败后，则会尝试从配置文件根据配置的Key获取对应的值 约定默认值 当未自定义配置，且无法从IConfiguration中获取到相对应参数的配置后，我们将根据约定好的规则生成对应的值 AppId: 启动程序名.Replace(“.”, “-“) Environment: Production Cluster: Default 配置映射在快速入门的例子中，看似很简单就可以通过IOptions&lt;TOptions&gt;获取到AppConfig的配置信息以及Dcc中配置的Redis信息，这一切是如何做到的呢？ 在MasaConfiguration中提供了两种映射方式，用来映射配置与类的对应关系，分别是：自动映射、手动映射。 自动映射 分为本地配置以及远程配置的自动映射 本地配置: 由Masa.Contrib.Configuration提供 远程配置 Dcc: 由Masa.Contrib.Configuration.ConfigurationApi.Dcc提供 1.1 当配置存储在本地时，则将对应的配置类继承LocalMasaConfigurationOptions 12345678910111213141516171819202122232425// &lt;summary&gt;/// 应用配置类/// &lt;/summary&gt;public class AppConfig : LocalMasaConfigurationOptions{ // /// &lt;summary&gt; // /// 如果当前配置挂载在根节点（一级节点）时，则无需重载，如果挂载在二级节点时，则需要重载ParentSection并赋值为一级节点名 // /// 根节点名：默认为一级节点，可不写，格式：一级节点:二级节点:三级节点…… // /// &lt;/summary&gt; // [JsonIgnore] // public override string? ParentSection =&gt; null; // /// &lt;summary&gt; // /// 如果类名与节点名保持一致，则可忽略不写，否则重写`Section`并赋值为节点名 // /// &lt;/summary&gt; // [JsonIgnore] // public override string? Section =&gt; &quot;RabbitMq&quot;; public ConnectionStrings ConnectionStrings { get; set; }}public class ConnectionStrings{ public string DefaultConnection { get; set; }} 当配置中的参数直接平铺挂载根节点下，而不是挂载到跟节点下的某个指定节点时，ParentSection无需重载，Section需要重载并赋值为空字符串 1.2 当配置存储在Dcc，则将对应的配置类继承ConfigurationApiMasaConfigurationOptions 1234567891011121314151617181920public class RedisOptions : ConfigurationApiMasaConfigurationOptions{ /// &lt;summary&gt; /// 配置所属的AppId，当AppId与默认AppId一致时，可忽略 /// &lt;/summary&gt; // public virtual string AppId { get; } /// &lt;summary&gt; /// Dcc的配置对象名称，当配置对象名称与类名一致时，可忽略 /// &lt;/summary&gt; // public virtual string? ObjectName { get; } public string Host { get; set; } public int Port { get; set; } public string Password { get; set; } public int DefaultDatabase { get; set; }} 手动映射 虽然自动映射的方式很简单，也很方便，但总是有一些场景使得我们无法通过自动映射来做，那如何手动指定映射关系呢？ 为了方便大家理解，手动映射仍然使用AppConfig以及Redis来举例 1234567891011builder.AddMasaConfiguration(configurationBuilder =&gt;{ configurationBuilder.UseDcc();//使用Dcc 扩展Configuration能力，支持远程配置 configurationBuilder.UseMasaOptions(options =&gt; { options.MappingLocal&lt;AppConfig&gt;(&quot;AppConfig&quot;);//其中参数&quot;AppConfig&quot;可不写（当类与节点名称一致时可忽略） options.MappingConfigurationApi&lt;RedisOptions&gt;(&quot;{替换为Dcc中配置所属的AppId}&quot;, &quot;{配置对象名称}&quot;);//其中配置对象名称可不写（当配置对象名与类名一致时可忽略） });}); Dcc配置完整的Dcc配置如下: 12345678910111213141516171819202122232425262728293031{ &quot;DccOptions&quot;: { &quot;ManageServiceAddress &quot;: &quot;http://localhost:8890&quot;, &quot;RedisOptions&quot;: { &quot;Servers&quot;: [ { &quot;Host&quot;: &quot;localhost&quot;, &quot;Port&quot;: 8889 } ], &quot;DefaultDatabase&quot;: 0, &quot;Password&quot;: &quot;&quot; }, &quot;AppId&quot;: &quot;Replace-With-Your-AppId&quot;, &quot;Environment&quot;: &quot;Development&quot;, &quot;ConfigObjects&quot;: [ &quot;Platforms&quot; ], &quot;Secret&quot;: &quot;&quot;, &quot;Cluster&quot;: &quot;Default&quot;, &quot;ExpandSections&quot; : [ { &quot;AppId&quot;: &quot;Replace-With-Your-AppId&quot;, &quot;Environment&quot;: &quot;Development&quot;, &quot;ConfigObjects&quot;: [ &quot;Platforms&quot; ], &quot;Secret&quot;: &quot;&quot;, &quot;Cluster&quot;: &quot;Default&quot;, } ], &quot;PublicId&quot;: &quot;Replace-With-Your-Public-AppId&quot;, &quot;PublicSecret&quot;: &quot;Replace-With-Your-Public-AppId-Secret&quot; }} ManageServiceAddress: 用于更新远程配置使用，非必填 RedisOptions：Dcc会在Redis中存储配置的副本，此处是存储Dcc配置的的Redis地址（*） AppId：项目中需要获取配置的AppId，也被称为Dcc的默认AppId，当未赋值时从全局配置中获取 Environment：项目中需要获取配置的环境信息，当未赋值时从全局配置中获取 ConfigObjects：项目中需要使用的配置对象名称，未赋值时默认获取当前环境、当前集群、当前AppId下的全部配置对象 Secret：秘钥，用于更新远程配置，每个AppId有一个秘钥，非必填（不可使用更新远程配置的能力） Cluster：需要加载配置的集群，后面我们简称为Dcc的默认集群，未赋值时从全局配置中获取 PublicId：Dcc中公共配置的AppId，默认：public-$Config，非必填 PublicSecret：Dcc中公共配置的AppId的秘钥，非必填 ExpandSections：扩展配置的集合，适用于当前应用需要获取多个AppId下的配置时使用，其中AppId为必填项、Environment、Cluster为非必填项，当不存在时将与Dcc默认环境、集群一致，非必填 扩展其它的配置中心上面提到了目前的远程配置能力仅支持Dcc，那如果我希望接入自己开发的配置中心或者其它更优秀的配置中心需要接入如何做？ 以Apollo为例： 新建类库Masa.Contrib.Configuration.ConfigurationApi.Apollo 新建ApolloConfigurationRepository并实现类AbstractConfigurationRepository 123456789101112131415161718192021internal class ApolloConfigurationRepository : AbstractConfigurationRepository{ private readonly IConfigurationApiClient _client; public override SectionTypes SectionType =&gt; SectionTypes.ConfigurationAPI; public DccConfigurationRepository( IConfigurationApiClient client, ILoggerFactory loggerFactory) : base(loggerFactory) { _client = client; //todo: 借助 IConfigurationApiClient 获取需要挂载到远程节点的配置信息并监听配置变化 // 当配置变更时触发FireRepositoryChange(SectionType, Load()); } public override Properties Load() { //todo: 返回当前挂载到远程节点的配置信息 }} 新建类ConfigurationApiClient，为ConfigurationApi提供获取基础配置的能力 123456789101112131415161718192021222324252627282930public class ConfigurationApiClient : IConfigurationApiClient{ public Task&lt;(string Raw, ConfigurationTypes ConfigurationType)&gt; GetRawAsync(string configObject, Action&lt;string&gt;? valueChanged = null) { throw new NotImplementedException(); } public Task&lt;(string Raw, ConfigurationTypes ConfigurationType)&gt; GetRawAsync(string environment, string cluster, string appId, string configObject, Action&lt;string&gt;? valueChanged = null) { throw new NotImplementedException(); } public Task&lt;T&gt; GetAsync&lt;T&gt;(string configObject, Action&lt;T&gt;? valueChanged = null); { throw new NotImplementedException(); } public Task&lt;T&gt; GetAsync&lt;T&gt;(string environment, string cluster, string appId, string configObject, Action&lt;T&gt;? valueChanged = null); { throw new NotImplementedException(); } public Task&lt;dynamic&gt; GetDynamicAsync(string environment, string cluster, string appId, string configObject, Action&lt;dynamic&gt; valueChanged) { throw new NotImplementedException(); } public Task&lt;dynamic&gt; GetDynamicAsync(string key) { throw new NotImplementedException(); }} 新建类ConfigurationApiManage，为ConfigurationApi提供管理配置的能力 123456789101112131415public class ConfigurationApiManage : IConfigurationApiManage{ // 通过管理端初始化AppId下的远程配置 public Task InitializeAsync(string environment, string cluster, string appId, Dictionary&lt;string, string&gt; configObjects) { throw new NotImplementedException(); } // 通过管理端更新指定配置的信息 public Task UpdateAsync(string environment, string cluster, string appId, string configObject, object value) { throw new NotImplementedException(); }} 新建ConfigurationApiMasaConfigurationOptions类，并继承MasaConfigurationOptions 我们希望其它自定义配置也能根据约定实现自动映射，我们也清楚不同的配置中心中存储配置的名称是不一样的，例如在Apollo中配置对象名称叫做命名空间，因此为了方便开发人员可以使用起来更方便，我们建议不同的配置中心可以有自己专属的属性，比如Apollo的Namespace，以此来降低开发人员的学习成本 12345678910111213141516171819202122232425262728public abstract class ConfigurationApiMasaConfigurationOptions : MasaConfigurationOptions{ /// &lt;summary&gt; /// The name of the parent section, if it is empty, it will be mounted under SectionType, otherwise it will be mounted to the specified section under SectionType /// &lt;/summary&gt; [JsonIgnore] public sealed override string? ParentSection =&gt; AppId; // public virtual string AppId =&gt; StaticConfig.AppId; /// &lt;summary&gt; /// The section null means same as the class name, else load from the specify section /// &lt;/summary&gt; [JsonIgnore] public sealed override string? Section =&gt; Namespace; /// &lt;summary&gt; /// /// &lt;/summary&gt; public virtual string? Namespace { get; } /// &lt;summary&gt; /// Configuration object name /// &lt;/summary&gt; [JsonIgnore] public sealed override SectionTypes SectionType =&gt; SectionTypes.ConfigurationApi;} 选中类库Masa.Contrib.BasicAbility.Apollo，并新建IMasaConfigurationBuilder的扩展方法UseApollo 12345678public static class MasaConfigurationExtensions{ public static IMasaConfigurationBuilder UseApollo(this IMasaConfigurationBuilder builder) { //todo：将IConfigurationApiClient、IConfigurationApiManage注册到到服务集合中，并通过builder.AddRepository()添加ApolloConfigurationRepository return builder; }} 总结 如何使用MasaConfiguration？ 新增：builder.AddMasaConfiguration() 为何通过IOptions获取到的配置为空，但通过IConfiguration或者IMasaConfiguration根据节点可以获取到？ 检查下是否没有绑定节点关系，如何绑定节点关系请查看问题2 检查节点绑定是否错误 IConfigurationApiClient与IConfiguration之间有什么关系？ IConfigurationApiClient、IConfigurationApiManage分别是管理远程Api的客户端以及管理端，与IConfiguration相比，IConfigurationApiClient的信息更全，每次获取配置需要像配置中心请求获取数据，而IConfiguration是通过调用IConfigurationApiClient将需要使用的配置对象获取并添加到IConfiguration中，后续用户获取配置时无需向配置中心请求数据 远程配置对象更新后，IConfiguration中的信息会更新吗？为什么？ 会更新、远程配置更新后会通过valueChanged通知远程配置的提供者，然后远程配置的提供者会刷新本地的远程配置并通知IConfiguration重新刷新数据 Dcc: Distributed Configuration Center 是一个以DDD为指导思想、使用.Net6.0开发的分布式配置中心 本章源码Assignment08 https://github.com/zhenlei520/MasaFramework.Practice 开源地址MASA.Framework：https://github.com/masastack/MASA.Framework MASA.EShop：https://github.com/masalabs/MASA.EShop MASA.Blazor：https://github.com/BlazorComponent/MASA.Blazor 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们","link":"/2022/06/10/masa/framework/practice/8.%20%E9%85%8D%E7%BD%AEIConfiguration/"},{"title":"9. 锁与分布式锁","text":"前言什么是锁？什么是分布式锁？它们之间有什么样的关系？ 什么是锁加锁（lock）是2018年公布的计算机科学技术名词，是指将控制变量置位，控制共享资源不能被其他线程访问。通过加锁，可以确保在同一时刻只有一个线程在访问被锁住的代码片段，我们在单机部署时可使用最简单的加锁完成资源的独享，如: 123456789101112public class Program{ private static readonly object Obj = new { }; public static void Main() { lock (obj) { //同一时刻只有一个线程可以访问 } }} 什么是分布式锁但随着业务发展的需要，原单体单机部署的系统被部署成分布式集群系统后，原来的并发控制策略失效，为了解决这个问题就需要引入分布式锁，那分布式锁应该具备哪些条件？ 原子性：在分布式环境下，一个方法在同一个时间点只能被一台机器下的一个线程所执行，防止数据资源的并发访问，避免数据不一致情况 高可用：具备自动失效机制，防止死锁，获取锁后如果出现错误，并且无法释放锁，则使用租约一段时间后自动释放锁 阻塞性：具备非阻塞锁特性（没有获取到锁时直接返回获取锁失败，不会长时间因等待锁导致阻塞） 高性能：高性能的获取锁与释放锁 可重入性：具备可重入特性，在同一线程外层函数获得锁之后，内层方法会自动获取锁 实现分布式锁是特定于实现的，目前MasaFramework提供了两个实现，分别是Local、Medallion，下面会介绍如何配置并使用它们 本地锁 Medallion Azure FileSystem MySql Oracle PostgreSql Redis SqlServer WaitHandles ZooKeeper 本地锁是基于SemaphoreSlim实现的，它不是真正的分布式锁，我们建议你在开发和测试环境中使用它，不需要联网也不会与其他人冲突 Medallion是基于DistributedLock实现的分布式锁，它提供了很多种技术的实现，包括Microsoft SQL Server、Postgresql、MySQL 或 MariaDB、Oracle、Redis、Azure blob、Apache ZooKeeper、锁文件、操作系统全局WaitHandles（Windows），我们只需要任选一种实现即可，目前Medallion提供的分布式锁并不支持可重入性，点击了解原因 快速入门 安装.NET 6.0 以本地锁单应用锁为例： 新建ASP.NET Core 空项目Assignment.DistributedLock.Local，并安装Masa.Contrib.Data.DistributedLock.Local 123dotnet new web -o Assignment.DistributedLock.Localcd Assignment.DistributedLock.Localdotnet add package Masa.Contrib.Data.DistributedLock.Local --version 0.6.0-preview.10 注册锁，修改类Program 1builder.Services.AddLocalDistributedLock();//注册本地锁 如何使用锁？修改类Program 12345678910app.MapGet(&quot;lock&quot;, (IDistributedLock distributedLock) =&gt;{ using var @lock = distributedLock.TryGet(&quot;test&quot;);//获取锁 if (@lock != null) { //todo: 获取锁成功 return &quot;success&quot;; } return &quot;获取超时&quot;;}); 通过DI获取IDistributedLock，并通过TryGet方法获取锁，如果获取锁失败，则返回null，如果返回到的对象不为null，则表明获取锁成功，最后在获取锁成功后写自己的业务代码即可 TryGet方法拥有以下参数 key (string, 必须): 锁的唯一名称，可通过key来访问不同的资源，执行不同的业务 timeout (TimeSpan): 等待获取锁的最大超时时间. 默认值为: TimeSpan.Zero（代表如果锁已经被另一个应用程序拥有, 它不会等待.） TryGetAsync方法除了拥有TryGet的所有参数之外，还拥有以下参数 cancellationToken: 取消令牌可在触发后取消操作 如果你选择使用Medallion，只需要选择一种技术实现，并根据Readme注册锁即可，在使用锁上是没有区别的 如何扩展其它的分布式锁 新建类库Masa.Contrib.Data.DistributedLock.{分布式锁名}，并添加引用Masa.BuildingBlocks.Data.csproj 新建分布式锁实现类DefaultDistributedLock，并实现IDistributedLock 1234567891011121314public class DefaultDistributedLock : IDistributedLock{ public IDisposable? TryGet(string key, TimeSpan timeout = default) { // 获取锁失败则返回null，当资源被释放时，主动释放锁, 无需人为手动释放 throw new NotImplementedException(); } public Task&lt;IAsyncDisposable?&gt; TryGetAsync(string key, TimeSpan timeout = default, CancellationToken cancellationToken = default) { //获取锁失败则返回null，当资源被释放时，主动释放锁, 无需人为手动释放 throw new NotImplementedException(); }} 新建类ServiceCollectionExtensions，注册分布式锁到服务集合 12345678public static class ServiceCollectionExtensions{ public static IServiceCollection AddDistributedLock(this IServiceCollection services, Action&lt;MedallionBuilder&gt; builder) { services.TryAddSingleton&lt;IDistributedLock, DefaultDistributedLock&gt;(); return services; }} 小知识为什么TryGet、TryGetAsync方法的返回类型分别是IDisposable、IAsyncDisposable？ 我们希望使用锁可以足够的简单，在使用完锁之后可以自动释放锁，而不是必须手动释放，当返回类型为IDisposable、IAsyncDisposable时，使用完毕后会触发Dispose或DisposeAsync，这样一来就可以使得开发者可以忽略释放锁的逻辑 以本地锁为例: 123456789101112131415161718192021222324252627282930313233343536373839public class DefaultLocalDistributedLock : IDistributedLock{ private readonly MemoryCache&lt;string, SemaphoreSlim&gt; _localObjects = new(); public IDisposable? TryGet(string key, TimeSpan timeout = default) { var semaphore = GetSemaphoreSlim(key); if (!semaphore.Wait(timeout)) { return null; } return new DisposeAction(semaphore); } //todo: 以下省略 TryGetAsync 方法 private SemaphoreSlim GetSemaphoreSlim(string key) { ArgumentNullOrWhiteSpaceException.ThrowIfNullOrWhiteSpace(key); return _localObjects.GetOrAdd(key, _ =&gt; new SemaphoreSlim(1, 1)); }}internal class DisposeAction : IDisposable, IAsyncDisposable{ private readonly SemaphoreSlim _semaphore; public DisposeAction(SemaphoreSlim semaphore) =&gt; _semaphore = semaphore; public ValueTask DisposeAsync() { _semaphore.Release(); return ValueTask.CompletedTask; } public void Dispose() =&gt; _semaphore.Release();} 本章源码Assignment09 https://github.com/zhenlei520/MasaFramework.Practice 开源地址MASA.Framework：https://github.com/masastack/MASA.Framework MASA.EShop：https://github.com/masalabs/MASA.EShop MASA.Blazor：https://github.com/BlazorComponent/MASA.Blazor 如果你对我们的 MASA Framework 感兴趣，无论是代码贡献、使用、提 Issue，欢迎联系我们","link":"/2022/06/14/masa/framework/practice/9.%20%E9%94%81%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"}],"tags":[{"name":"MASA Blazor","slug":"MASA-Blazor","link":"/tags/MASA-Blazor/"},{"name":"MAUI","slug":"MAUI","link":"/tags/MAUI/"},{"name":".NET","slug":"NET","link":"/tags/NET/"},{"name":"MASA IoT","slug":"MASA-IoT","link":"/tags/MASA-IoT/"},{"name":"MASA Framework","slug":"MASA-Framework","link":"/tags/MASA-Framework/"},{"name":"C#8.0","slug":"C-8-0","link":"/tags/C-8-0/"},{"name":"dapr","slug":"dapr","link":"/tags/dapr/"},{"name":"Crank","slug":"Crank","link":"/tags/Crank/"},{"name":"Test","slug":"Test","link":"/tags/Test/"},{"name":"K8S","slug":"K8S","link":"/tags/K8S/"},{"name":"Helm","slug":"Helm","link":"/tags/Helm/"},{"name":"Minimal Api","slug":"Minimal-Api","link":"/tags/Minimal-Api/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"OM","slug":"OM","link":"/tags/OM/"},{"name":"Template","slug":"Template","link":"/tags/Template/"},{"name":"Blazor","slug":"Blazor","link":"/tags/Blazor/"},{"name":"MASA Blazor#","slug":"MASA-Blazor","link":"/tags/MASA-Blazor/"},{"name":"MASA Stack","slug":"MASA-Stack","link":"/tags/MASA-Stack/"},{"name":"MASA Auth","slug":"MASA-Auth","link":"/tags/MASA-Auth/"},{"name":"MASA Auth Design","slug":"MASA-Auth-Design","link":"/tags/MASA-Auth-Design/"},{"name":"MASA Framework Design","slug":"MASA-Framework-Design","link":"/tags/MASA-Framework-Design/"},{"name":"DDD","slug":"DDD","link":"/tags/DDD/"},{"name":"UI","slug":"UI","link":"/tags/UI/"},{"name":"SnowFlake","slug":"SnowFlake","link":"/tags/SnowFlake/"},{"name":"EventBus","slug":"EventBus","link":"/tags/EventBus/"},{"name":"MinimalAPIs","slug":"MinimalAPIs","link":"/tags/MinimalAPIs/"},{"name":"CQRS","slug":"CQRS","link":"/tags/CQRS/"},{"name":"Caching","slug":"Caching","link":"/tags/Caching/"},{"name":"Framework","slug":"Framework","link":"/tags/Framework/"},{"name":"i18n","slug":"i18n","link":"/tags/i18n/"},{"name":"HttpClient","slug":"HttpClient","link":"/tags/HttpClient/"},{"name":"Caller","slug":"Caller","link":"/tags/Caller/"},{"name":"Mapster","slug":"Mapster","link":"/tags/Mapster/"},{"name":"EFCore","slug":"EFCore","link":"/tags/EFCore/"},{"name":"Storage","slug":"Storage","link":"/tags/Storage/"},{"name":"DI","slug":"DI","link":"/tags/DI/"},{"name":"Configuration","slug":"Configuration","link":"/tags/Configuration/"},{"name":"Distributed lock","slug":"Distributed-lock","link":"/tags/Distributed-lock/"}],"categories":[{"name":"MASA Blazor","slug":"MASA-Blazor","link":"/categories/MASA-Blazor/"},{"name":"MAUI","slug":"MAUI","link":"/categories/MAUI/"},{"name":"MAUI","slug":"MASA-Blazor/MAUI","link":"/categories/MASA-Blazor/MAUI/"},{"name":"MASA Blazor","slug":"MAUI/MASA-Blazor","link":"/categories/MAUI/MASA-Blazor/"},{"name":".NET","slug":"NET","link":"/categories/NET/"},{"name":"MASA","slug":"MASA","link":"/categories/MASA/"},{"name":"MASA IoT","slug":"MASA-IoT","link":"/categories/MASA-IoT/"},{"name":"MASA Stack","slug":"MASA-Stack","link":"/categories/MASA-Stack/"},{"name":"社区例会","slug":"社区例会","link":"/categories/%E7%A4%BE%E5%8C%BA%E4%BE%8B%E4%BC%9A/"},{"name":"Dapr","slug":"Dapr","link":"/categories/Dapr/"},{"name":"Crank","slug":"NET/Crank","link":"/categories/NET/Crank/"},{"name":"MASA Framework","slug":"NET/MASA-Framework","link":"/categories/NET/MASA-Framework/"},{"name":"K8S","slug":"K8S","link":"/categories/K8S/"},{"name":"Redis","slug":"NET/Redis","link":"/categories/NET/Redis/"},{"name":"Template","slug":"NET/Template","link":"/categories/NET/Template/"},{"name":"Blazor","slug":"NET/Blazor","link":"/categories/NET/Blazor/"},{"name":"MASA Auth","slug":"NET/MASA-Auth","link":"/categories/NET/MASA-Auth/"},{"name":"MASA Stack","slug":"社区例会/MASA-Stack","link":"/categories/%E7%A4%BE%E5%8C%BA%E4%BE%8B%E4%BC%9A/MASA-Stack/"},{"name":"C#","slug":"NET/C","link":"/categories/NET/C/"},{"name":"Framework","slug":"NET/Framework","link":"/categories/NET/Framework/"},{"name":"Helm","slug":"K8S/Helm","link":"/categories/K8S/Helm/"},{"name":"MASA Blazor","slug":"NET/Blazor/MASA-Blazor","link":"/categories/NET/Blazor/MASA-Blazor/"}],"pages":[{"title":"如何投稿","text":"贡献方案 技术博客贡献方案 http://confluence-hz.lonsid.cn/x/3aR 整个技术博客投稿活动，作为今后大家职业晋升的参考依据。 环境准备 node http://nodejs.cn/download/current/ vscode https://code.visualstudio.com/docs/?dv=win64user 获取文档库代码 1git clone http://gitlab-hz.lonsid.cn/Techs-Preview/masa-blogs.git 构建文档 采用 vscode 打开 masa-blogs 文档库代码目录，使用下面的命令，启动可视化文档写作： 12npm inpm start 创建分支，分支名需要 姓名全拼加-加文档简述，比如 feature/zhurong-contributing； 在 /source/_posts 中新建markdown类型的文件，并按照自己的想法命名，文件需要是一句话英文，并用-符号连接，比如 How-to-contributing.md； 文档头需要遵循vuepress的标准格式： 1234567891011121314---title: 烤鸭的做法cover: /gallery/covers/cover.jpgthumbnail: /gallery/thumbnails/thumbnail.jpgdate: 2019-08-08 08:00:00updated: 2020-04-01 00:00:00toc: truecategories: - 烹饪 - 爱好tags: - 烤 - 鸭子--- title：文章标题 cover：文章封面图 thumbnail：文章缩略图 date：文章创建日期，格式 2019-08-08 或 2019-08-08 08:08:08 updated：文章更新时间 toc：否开启侧边栏 categories：所属分类 tags：所属标签 正文创作需要遵循markdown标记语言，可以通过vscode插件markdownlint协助写作。 在你的文章中添加&lt;!-- more --&gt;标签。 标签前面的文章内容会被标记为摘要，而其后的内容不会显示在文章列表上。 文章内标题使用二级标题开始，不需要增加序号 标题下最好跟有一句话描述 补充类可以用引用”&gt;” 其他问题可参阅这里： https://ppoffice.github.io/hexo-theme-icarus/uncategorized/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","link":"/about/index.html"}]}